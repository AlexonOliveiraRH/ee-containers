---
#
# Environment validation and initialization
#
- name: Gather information about execution environment
  block:
    - name: Verify execution environment configuration
      ansible.builtin.stat:
        path: "environments/{{ current_env }}/execution-environment.yml"
      register: ee_config_file

    - name: Set environment status facts
      ansible.builtin.set_fact:
        ee_config_exists: "{{ ee_config_file.stat.exists | default(false) }}"
        ee_config_path: "environments/{{ current_env }}/execution-environment.yml"
  
    - name: Announce environment processing
      ansible.builtin.debug:
        msg: |
          ===============================================
          Starting build for environment: {{ current_env }}
          Config path: {{ ee_config_path }}
          Config exists: {{ 'Yes' if ee_config_exists else 'No' }}
          ===============================================
  
    - name: Validate environment configuration
      ansible.builtin.assert:
        that: ee_config_exists
        fail_msg: |
          Cannot build execution environment for {{ current_env }}
          Missing configuration file: {{ ee_config_path }}
          Please create this file before continuing.
        success_msg: "Environment configuration validated successfully for {{ current_env }}"
  rescue:
    - name: Report environment validation failure
      ansible.builtin.fail:
        msg: |
          Environment initialization failed for {{ current_env }}
          This could be due to missing files or permission issues.
          Error details: {{ ansible_failed_result | default('Unknown error') }}
      when: ansible_failed_task is defined

#
# Directory and file preparation
#
- name: Create required directories
  ansible.builtin.file:
    path: "{{ directory }}"
    state: directory
    mode: '0755'
  loop:
    - "environments/{{ current_env }}"
    - "{{ work_dir }}/context"
    - "{{ work_dir }}/_build"
  loop_control:
    loop_var: directory
  tags: [build, setup, directories]

- name: Check for required files
  ansible.builtin.stat:
    path: "environments/{{ current_env }}/{{ filename }}"
  loop:
    - execution-environment.yml
    - requirements.txt
    - requirements.yml
    - bindep.txt
  register: file_checks
  loop_control:
    loop_var: filename
  tags: [build, setup, check_files]

- name: Create empty requirements.txt if it doesn't exist
  ansible.builtin.file:
    path: "environments/{{ current_env }}/requirements.txt"
    state: touch
    mode: '0644'
  when: not file_checks.results[0].stat.exists

- name: Create default requirements.yml if it doesn't exist
  ansible.builtin.copy:
    content: |
      ---
      collections:
        - name: ansible.utils
          version: ">=2.10.0"
        - name: ansible.posix
          version: ">=1.5.4"
        - name: community.general
          version: ">=7.0.0"
    dest: "environments/{{ current_env }}/requirements.yml"
    mode: '0644'
  when: not file_checks.results[1].stat.exists

- name: Create default bindep.txt if it doesn't exist
  ansible.builtin.copy:
    content: |
      # System dependencies for Python packages
      gcc [platform:rpm]
      make [platform:rpm]
      libxml2-devel [platform:rpm]
      openssl-devel [platform:rpm]
      python3-devel [platform:rpm]
      rpm-build [platform:rpm]
      # Kerberos dependencies
      krb5-devel [platform:rpm]
      krb5-libs [platform:rpm]
      krb5-workstation [platform:rpm]
    dest: "environments/{{ current_env }}/bindep.txt"
    mode: '0644'
  when: not file_checks.results[2].stat.exists

#
# Fix execution-environment.yml issues
#
- name: Check for property issues in execution-environment.yml
  ansible.builtin.shell: |
    grep -l '^[[:space:]]*{{ property.key }}[[:space:]]*:' "environments/{{ current_env }}/execution-environment.yml" || true
  loop:
    - { key: "prepend", name: "prepend" }
    - { key: "append", name: "append" }
  register: property_checks
  changed_when: false
  loop_control:
    loop_var: property  # Added custom loop variable
    label: "{{ property.name }}"  # Updated reference
  args:
    executable: /bin/bash

- name: Fix invalid 'prepend' property
  ansible.builtin.replace:
    path: "environments/{{ current_env }}/execution-environment.yml"
    regexp: '^(\s*)prepend(\s*):(\s*.*)$'
    replace: '\1prepend_builder\2:\3'
  when: >
    property_checks.results | selectattr('property.key', 'eq', 'prepend') | list | length > 0 and
    property_checks.results | selectattr('property.key', 'eq', 'prepend') | first | regex_search('prepend')
  register: prepend_fixed

- name: Fix invalid 'append' property
  ansible.builtin.replace:
    path: "environments/{{ current_env }}/execution-environment.yml"
    regexp: '^(\s*)append(\s*):(\s*.*)$'
    replace: '\1append_builder\2:\3'
  when: >
    property_checks.results | selectattr('property.key', 'eq', 'append') | list | length > 0 and
    property_checks.results | selectattr('property.key', 'eq', 'append') | first | regex_search('append')
  register: append_fixed

- name: Display property fix status
  ansible.builtin.debug:
    msg: "Fixed invalid properties in execution-environment.yml for {{ current_env }}: prepend → prepend_builder, append → append_builder"
    verbosity: 3
  when: prepend_fixed.changed or append_fixed.changed

- name: Fix python package references in execution-environment.yml for RHEL 9
  ansible.builtin.replace:
    path: "environments/{{ current_env }}/execution-environment.yml"
    regexp: 'python39-(pip|devel)'
    replace: 'python3-\1'
  when: "'rhel9' in current_env"
  register: ee_python_fixed

- name: Fix python package references in bindep.txt for RHEL 9
  ansible.builtin.replace:
    path: "environments/{{ current_env }}/bindep.txt"
    regexp: '^python39-devel \[platform:rpm\]$'
    replace: 'python3-devel [platform:rpm]'
  when: "'rhel9' in current_env and (playbook_dir ~ '/environments/' ~ current_env ~ '/bindep.txt') is file"
  register: bindep_python_fixed

#
# Fix requirements.yml issues
#
- name: Check for issues in requirements.yml
  ansible.builtin.shell: |
    grep -l '{{ req_item.pattern }}' "environments/{{ current_env }}/requirements.yml" || true
  loop:
    - { pattern: 'ansible\.builtin', name: 'ansible.builtin' }
    - { pattern: 'infra\.ansible', name: 'infra.ansible' }
  register: req_checks
  changed_when: false
  loop_control:
    loop_var: req_item  # Added custom loop variable
    label: "{{ req_item.name }}"  # Updated reference
  args:
    executable: /bin/bash

- name: Fix ansible.builtin reference in requirements.yml
  ansible.builtin.replace:
    path: "environments/{{ current_env }}/requirements.yml"
    regexp: '(\s+)- name: ansible.builtin(\s+.*)?'
    replace: '# The following line was removed as ansible.builtin is part of ansible-core and cannot be installed separately'
  when: >
    req_checks.results | selectattr('req_item.name', 'eq', 'ansible.builtin') | list | length > 0 and
    req_checks.results | selectattr('req_item.name', 'eq', 'ansible.builtin') | first | regex_search('ansible\.builtin')
  register: builtin_fixed

- name: Fix infra.ansible reference in requirements.yml
  ansible.builtin.replace:
    path: "environments/{{ current_env }}/requirements.yml"
    regexp: '(\s+)- name: infra\.ansible(\s+.*)?'
    replace: '\1- name: infra.ee_utilities\n\1- name: infra.aap_utilities'
  when: >
    req_checks.results | selectattr('req_item.name', 'eq', 'infra.ansible') | list | length > 0 and
    req_checks.results | selectattr('req_item.name', 'eq', 'infra.ansible') | first | regex_search('infra\.ansible')
  register: infra_ansible_fixed

- name: Display collection fixes
  ansible.builtin.debug:
    msg: "Fixed {{ collection.name }} reference in requirements.yml for {{ current_env }}"
    verbosity: 3
  loop:
    - { name: "ansible.builtin", changed: "{{ builtin_fixed.changed | default(false) }}" }
    - { name: "infra.ansible", changed: "{{ infra_ansible_fixed.changed | default(false) }}" }
  loop_control:
    loop_var: collection  # Define a unique loop variable name
  when: collection.changed | bool

#
# Clean up existing resources
#
- name: Find all existing tagged images
  ansible.builtin.shell: |
    podman images --format '{% raw %}{{ .Repository }}:{{ .Tag }}{% endraw %}' | grep -v "<none>:<none>" | sort
  register: all_tagged_images
  changed_when: false
  args:
    executable: /bin/bash
  tags: [build, build_cleanup, image_inventory]

# Build initial protected images list - also move earlier
- name: Set protected images list
  ansible.builtin.set_fact:
    protected_images: "{{ protected_images | default([]) + all_tagged_images.stdout_lines | default([]) | list }}"
  tags: [build, build_cleanup, image_protection]

# Check if the current environment image exists
- name: Check if current image exists with tag
  ansible.builtin.command:
    cmd: "podman image exists {{ current_env }}"
  register: current_image_check
  changed_when: false
  failed_when: false
  tags: [build, build_cleanup, image_protection]

# Ensure current_env is in protected list if it exists
- name: Add current environment image to protected list
  ansible.builtin.set_fact:
    protected_images: "{{ protected_images | default([]) + [current_env] | unique }}"
  when: current_image_check.rc == 0
  tags: [build, build_cleanup, image_protection]

- name: Clean up execution environment resources
  block:
    - name: Find containers related to this build
      ansible.builtin.shell: |
        podman ps -a --filter "name={{ current_env }}" --format '{{ "{{" }}.ID{{ "}}" }}' | tr '\n' ' '
      register: container_ids
      changed_when: false
      args:
        executable: /bin/bash

    - name: Set container facts
      ansible.builtin.set_fact:
        containers_to_remove: "{{ container_ids.stdout.split() }}"

    - name: Report cleanup plan
      ansible.builtin.debug:
        msg: "Found {{ containers_to_remove | length }} container(s) related to {{ current_env }} to remove"
        verbosity: 3

    - name: Remove unprotected containers only
      ansible.builtin.shell: |
        # Get list of all containers
        ALL_CONTAINERS=$(podman ps -a --format '{{ "{{" }}.ID{{ "}}" }}' | tr '\n' ' ')
        
        # Filter out containers using protected images
        for container in $ALL_CONTAINERS; do
          IMAGE=$(podman container inspect $container --format '{{ "{{" }}.Config.Image{{ "}}" }}')
          PROTECTED=false
          
          # Check if image is in protected list
          for protected in {{ protected_images | default([]) | to_json }}; do
            if [ "$IMAGE" == "$protected" ]; then
              PROTECTED=true
              break
            fi
          done
          
          # If not protected and not using the current env, remove it
          if [ "$PROTECTED" == "false" ] && [ "$IMAGE" != "{{ current_env }}" ]; then
            echo "Removing unprotected container $container with image $IMAGE"
            podman rm -f $container || true
          else
            echo "Skipping protected container $container with image $IMAGE"
          fi
        done
      register: container_cleanup
      changed_when: container_cleanup.stdout is search("Removing")
      failed_when: false
      tags: [build, build_cleanup, container_cleanup]
      
    - name: Remove build context directory
      ansible.builtin.file:
        path: "{{ work_dir }}/context"
        state: absent

  rescue:
    - name: Report cleanup failure
      ansible.builtin.debug:
        msg: "Warning: Resource cleanup encountered an issue. Continuing with build anyway."

#
# Build container image
#
- name: Ensure ansible-builder is available
  ansible.builtin.command:
    cmd: which ansible-builder
  register: builder_check
  changed_when: false
  failed_when: false

- name: Check if rebuild was specifically requested
  ansible.builtin.set_fact:
    force_rebuild: "{{ force_rebuild | default(false) | bool or (selected_environments is defined and current_env in selected_environments) }}"

- name: Skip build for existing images unless forced
  ansible.builtin.debug:
    msg: "Image {{ current_env }} already exists. Skipping build. Use menu option to force rebuild."
  when: 
    - image_check is defined
    - image_check.rc == 0
    - not force_rebuild

- name: Report info on build image
  ansible.builtin.debug:
    msg: "Preparing to build image: {{ current_env }}"
  tags: [build, build_cleanup, pre_build_report]
    
- name: Remove existing image if it exists
  ansible.builtin.shell: |
    podman image exists {{ current_env }} && podman rmi -f {{ current_env }} || true
  changed_when: false
  tags: [build, build_cleanup, pre_build_remove_image]

- name: Clear Podman cache for RHEL8 builds
  ansible.builtin.command:
    cmd: |
      rm -rf /var/lib/containers/storage/overlay-layers/*/rhel8*
      rm -rf /var/lib/containers/storage/overlay-images/*/rhel8*
  when: "'rhel8' in current_env"
  ignore_errors: true
  changed_when: true
  tags: [build, build_cleanup]

- name: Clear Podman cache for RHEL9 builds
  ansible.builtin.shell: |
    rm -rf /var/lib/containers/storage/overlay-layers/*/rhel9*
    rm -rf /var/lib/containers/storage/overlay-images/*/rhel9*
  changed_when: true
  when: "'rhel9' in current_env"
  tags: [build, build_cleanup, pre_build_clear_cache]

# Add this task before the build to install the missing dependency
- name: Install systemd development libraries
  ansible.builtin.package:
    name: "systemd-devel"
    state: present
  when: "'rhel9' in current_env"
  ignore_errors: true
  tags: [build, build_deps]

- name: Install additional Python dependencies for RHEL builds
  ansible.builtin.package:
    name: "{{ dependency }}"  # Changed from item to dependency
    state: present
  loop:
    - systemd-devel
    - python3-devel
    - gcc
    - python3-pip
  loop_control:
    loop_var: dependency  # Define a unique loop variable name
  ignore_errors: true
  tags: [build, build_deps]

# Modify the existing task to do a more robust fix
- name: Fix systemd-python dependency in requirements.txt
  ansible.builtin.replace:
    path: "environments/{{ current_env }}/requirements.txt"
    regexp: '^systemd-python.*$'
    replace: "# systemd-python was causing build failures - disabled\n# systemd-python; sys_platform == 'linux' and 'linux' in platform_machine"
  when: "'rhel9' in current_env"
  ignore_errors: true
  tags: [build, build_deps]

# Add this new task to also check the generated files
- name: Fix systemd-python in introspected requirements
  ansible.builtin.shell: |
    # Check if the _build directory and requirements.txt exist
    if [ -d "{{ work_dir }}/context/_build" ]; then
      # Identify all requirement files that might have systemd-python
      find "{{ work_dir }}/context" -type f -name "requirements*.txt" | while read req_file; do
        echo "Fixing systemd-python in $req_file"
        sed -i 's|^systemd-python.*$|# systemd-python was causing build failures|g' "$req_file"
      done
    fi
  changed_when: true
  ignore_errors: true
  tags: [build, build_deps]

# Add this task to provide a clean re-run approach for systemd-dependent environments
- name: Create environment configuration backup
  ansible.builtin.copy:
    src: "environments/{{ current_env }}"
    dest: "environments/{{ current_env }}.bak"
    mode: preserve
    remote_src: yes
  when: not image_exists.rc|default(1) == 0
  ignore_errors: true

- name: Fix systemd-python dependency in Python package list
  ansible.builtin.replace:
    path: "{{ work_dir }}/context/_build/requirements.txt"
    regexp: '^systemd-python.*$'
    replace: '# systemd-python disabled due to build issues'
    backup: true
  when: "'rhel9' in current_env"
  ignore_errors: true
  tags: [build, build_deps]

- name: Set up environment for systemd-python build
  ansible.builtin.shell: |
    # Ensure systemd-devel is installed
    dnf install -y systemd-devel

    # Find the systemd pkg-config file
    SYSTEMD_PC=$(find /usr -name "libsystemd.pc" 2>/dev/null)
    
    if [ -n "$SYSTEMD_PC" ]; then
      # Set the PKG_CONFIG_PATH to include the directory
      export PKG_CONFIG_PATH="$(dirname $SYSTEMD_PC):$PKG_CONFIG_PATH"
      echo "PKG_CONFIG_PATH set to include systemd: $PKG_CONFIG_PATH"
      echo "PKG_CONFIG_PATH=$PKG_CONFIG_PATH" > /tmp/build_env
    else
      echo "Could not find libsystemd.pc, systemd-python build will likely fail"
    fi
  register: pkgconfig_setup
  when: "'rhel9' in current_env"
  ignore_errors: true
  tags: [build, build_deps]

- name: Set up environment for successful builds
  ansible.builtin.shell: |
    # Make sure build context is clean
    rm -rf "{{ work_dir }}/context/_build" || true
    
    # Set build-specific environment variables
    export ANSIBLE_CONFIG="{{ playbook_dir }}/ansible.cfg"
    export PODMAN_IGNORE_CGROUPSV1_WARNING=1
  changed_when: false

- name: Build container image
  ansible.builtin.command:
    cmd: >-
      ansible-builder build 
      --tag {{ current_env }} 
      --container-runtime podman 
      --verbosity 3
      --prune-images
      --context {{ work_dir }}/context
      --build-arg AH_TOKEN={{ automation_hub_token | default('') }}
      -f environments/{{ current_env }}/execution-environment.yml
  environment:
    BUILDAH_FORMAT: docker
    STORAGE_DRIVER: vfs
    BUILDAH_ISOLATION: chroot
    PODMAN_IGNORE_CGROUPSV1_WARNING: "1"
  register: build_output
  failed_when: false
  changed_when: build_output.rc == 0
  tags: [build, build_process]

# Replace with this enhanced implementation
- name: Send build output to log file
  block:  # Just 'block:' instead of 'ansible.builtin.block:'
    - name: Ensure log directory structure exists
      ansible.builtin.file:
        path: /var/log/ansible/ansible-builder
        state: directory
        mode: '0755'
        owner: "{{ ansible_user_id }}"
        recurse: true
      become: true
      ignore_errors: true

    - name: Get current timestamp
      ansible.builtin.command:
        cmd: "date '+%Y%m%d-%H%M%S'"
      register: timestamp
      changed_when: false
      
    - name: Send build output to log file and tmux
      ansible.builtin.shell: |
        # Create a timestamp for the log filename
        TIMESTAMP="{{ timestamp.stdout }}"
        LOG_FILE="/var/log/ansible/ansible-builder/{{ current_env }}-${TIMESTAMP}.log"
        
        # Create log content with extra details
        {
          echo "=== BUILD LOG: {{ current_env }} ==="
          echo "Timestamp: $(date)"
          echo "Environment: {{ current_env }}"
          echo "Build result: {{ 'SUCCESS' if build_output.rc == 0 else 'FAILED' }} (Exit code: {{ build_output.rc }})"
          echo "Ansible user: {{ ansible_user_id }}"
          echo "Build command: ansible-builder build --tag {{ current_env }}"
          echo "============================================="
          echo ""
          echo "STDOUT:"
          echo "{{ build_output.stdout | default('No standard output captured') | replace('"', '\\"') }}"
          echo ""
          echo "STDERR:"
          echo "{{ build_output.stderr | default('No error output') | replace('"', '\\"') }}"
        } | tee "$LOG_FILE" >/dev/null
        
        # Update permissions on log file to ensure it's readable
        chmod 644 "$LOG_FILE" || true
        
        # Update tmux if it's running
        if tmux has-session -t podman-monitor 2>/dev/null; then
          # Send build status with color based on result
          if [ {{ build_output.rc }} -eq 0 ]; then
            tmux send-keys -t podman-monitor:0.0 "echo -e '\e[1;32mBuild {{ current_env }} SUCCEEDED\e[0m'" C-m
          else
            tmux send-keys -t podman-monitor:0.0 "echo -e '\e[1;31mBuild {{ current_env }} FAILED (Exit code: {{ build_output.rc }})\e[0m'" C-m
          fi
          
          # Tell tmux where the log file is located
          tmux send-keys -t podman-monitor:0.0 "echo 'Log saved to: $LOG_FILE'" C-m
          
          # Create a temporary file for tmux display (with limited output to avoid overflow)
          {
            echo -e "=== Build output summary for {{ current_env }} ==="
            echo ""
            echo "STDOUT (last 20 lines):"
            echo "{{ build_output.stdout | default('No standard output captured') | replace('"', '\\"') }}" | tail -20
            echo ""
            echo "STDERR (last 10 lines):"
            echo "{{ build_output.stderr | default('No error output') | replace('"', '\\"') }}" | tail -10
            echo ""
            echo "Full log available at: $LOG_FILE"
          } > /tmp/build_output.txt
          
          # Display the file contents in tmux
          tmux send-keys -t podman-monitor:0.0 "cat /tmp/build_output.txt" C-m
        fi
        
        echo "Build log saved to: $LOG_FILE"
      changed_when: false
      ignore_errors: true
  rescue:
    - name: Report logging failure
      ansible.builtin.debug:
        msg: "Warning: Failed to create log file, but build process will continue"
  tags: [build, build_process, logging]

- name: Display build result summary
  ansible.builtin.debug:
    msg: |
      Build of {{ current_env }} {{ 'succeeded' if build_output.rc|default(1) == 0 else 'failed' }}
      {{ 'Error output:' if build_output.rc|default(1) != 0 else 'Build output:' }}
      {{ build_output.stderr | default(build_output.stdout) | default('No output captured') }}
  tags: [build, build_process]

# Replace the current build failure handling with this enhanced version
- name: Record build failure and clean up artifacts
  block:
    - name: Initialize failed_environments list if not exists
      ansible.builtin.set_fact:
        failed_environments: "{{ failed_environments | default([]) }}"
      run_once: true
      
    - name: Add current environment to failed list
      ansible.builtin.set_fact:
        failed_environments: "{{ failed_environments | default([]) + [current_env] }}"
        
    - name: Report build failure but continue
      ansible.builtin.debug:
        msg: |
          ⚠️ WARNING: Build of {{ current_env }} failed with return code {{ build_output.rc }}
          
          This error is being logged but the playbook will continue with other environments.
          Check the build logs for details:
          /var/log/ansible/ansible-builder/{{ current_env }}*.log
      
    - name: Clean up artifacts from failed build
      block:
        - name: Remove build context directory
          ansible.builtin.file:
            path: "{{ work_dir }}/context"
            state: absent
          ignore_errors: true
          
        - name: Remove temporary build files
          ansible.builtin.shell: |
            # Remove any temporary build files in /tmp
            rm -rf /tmp/ansible-builder.*
            rm -rf /tmp/pip-*
            
            # Clean up dangling containers from failed build
            podman ps -a --filter "name={{ current_env }}" --format "{% raw %}{{.ID}}{% endraw %}" | xargs -r podman rm -f
            
            # Clean up dangling images (untagged) but preserve tagged images
            podman images --filter "dangling=true" --format "{% raw %}{{.ID}}{% endraw %}" | xargs -r podman rmi -f
            
            # Clean podman cache
            podman system prune -f --volumes
            
            echo "Cleaned up build artifacts for {{ current_env }}"
          changed_when: true
          ignore_errors: true
          
        - name: Report cleanup completion
          ansible.builtin.debug:
            msg: "Build artifacts cleaned up for {{ current_env }}. Ready for next build."
      ignore_errors: true
  when: build_output.rc|default(1) != 0
  tags: [build, build_process, error_handling, cleanup]

- name: Verify image was built successfully
  ansible.builtin.command:
    cmd: "podman image exists {{ current_env }}"
  register: image_exists
  changed_when: false
  failed_when: false

- name: Report build verification
  ansible.builtin.debug:
    msg: "{{ 'Image ' + current_env + ' exists in local registry.' if image_exists.rc == 0 else 'WARNING: Image ' + current_env + ' was not found after build!' }}"

- name: Notify if infra.ansible was fixed
  ansible.builtin.debug:
    msg: "Fixed infra.ansible reference in requirements.yml for {{ current_env }}"
  when: infra_ansible_fixed.changed | default(false)

- name: Update protected images in protected_images.yml 
  ansible.builtin.blockinfile:
    path: "tasks/protected_images.yml"
    block: |
      # This list is automatically generated from existing images
      # Images will NOT be deleted unless specifically selected from menu
      protected_images:
      {% for image in protected_images | default([]) %}
        - "{{ image }}"
      {% endfor %}
    marker: "# {mark} ANSIBLE MANAGED PROTECTED IMAGES"
    create: yes
    mode: '0644'
  when: 
    - protected_images is defined 
    - protected_images | length > 0

# Replace any image removal task with this safer version
- name: Clean up only unprotected images
  ansible.builtin.shell: |
    # Get all images
    ALL_IMAGES=$(podman images --format '{{ "{{" }}.Repository{{ "}}" }}:{{ "{{" }}.Tag{{ "}}" }}' | grep -v "<none>:<none>")
    
    # Clean up only images not in protected list and not current_env
    for image in $ALL_IMAGES; do
      PROTECTED=false
      
      # Check if image is in protected list
      for protected in {{ protected_images | default([]) | to_json }}; do
        if [ "$image" == "$protected" ]; then
          PROTECTED=true
          break
        fi
      done
      
      # Skip current environment image always
      if [ "$image" == "{{ current_env }}" ]; then
        PROTECTED=true
      fi
      
      # If not protected, remove it
      if [ "$PROTECTED" == "false" ]; then
        echo "Removing unprotected image: $image"
        podman rmi $image || true
      else
        echo "Skipping protected image: $image"
      fi
    done
  register: image_cleanup
  changed_when: image_cleanup.stdout is search("Removing")
  failed_when: false
  tags: [build, cleanup, image_cleanup]


