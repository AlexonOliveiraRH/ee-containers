---
####################################
# 1. INITIALIZATION AND SETUP
####################################

- name: Install required Python packages for filters
  ansible.builtin.pip:
    name: jmespath
    state: present
  become: true
  tags:
    - setup
    - dependencies
    - python_packages

# Add this task near the beginning of your playbook (after the pip install task)
- name: Install required Ansible collections for filters
  ansible.builtin.command: ansible-galaxy collection install community.general
  changed_when: false
  ignore_errors: true
  tags:
    - setup
    - dependencies
    - ansible_collections

- name: Generate timestamp for image tag
  ansible.builtin.set_fact:
    timestamp: "{{ lookup('pipe', 'date +%Y%m%d%H%M%S') }}"
  tags:
    - setup
    - timestamp
    - always

- name: Initialize environment_configs if not defined
  ansible.builtin.set_fact:
    environment_configs: {}
  when: environment_configs is undefined
  tags:
    - setup
    - initialize
    - variables

- name: Set OS type for environments
  ansible.builtin.set_fact:
    os_type: "{{ 'rhel8' if (environments_to_build | default([]) | select('search', 'rhel8') | list | length > 0) else 'rhel9' }}"
  tags:
    - setup
    - initialize
    - variables
    - os_type

- name: Create required directories
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    mode: "0755"
  loop:
    - "{{ dir_paths.ansible_config }}"
    - "{{ dir_paths.hooks }}"
    - "{{ dir_paths.context }}"
    - "{{ dir_paths.context }}/hooks"
    - "{{ dir_paths.build }}"
    - "{{ dir_paths.containerfiles }}"
  become: true
  tags:
    - setup
    - directories
    - filesystem

- name: Create Ansible configuration files
  ansible.builtin.copy:
    dest: "{{ item.path }}"
    content: "{{ item.content }}"
    mode: "{{ item.mode | default('0644') }}"
  loop:
    - path: "/tmp/ansible_safe/ansible.cfg"
      content: |
        [defaults]
        ansible_log_path = /tmp/ee-containers/ansible.log
        # rest of the ansible.cfg content...
    - path: "/tmp/ansible_safe/inventory"
      content: |
        [local]
        localhost ansible_connection=local
  become: true
  tags:
    - setup
    - config
    - ansible_config

- name: Define Ansible environment variables
  ansible.builtin.set_fact:
    ansible_environment:
      ANSIBLE_CONFIG: "/tmp/ansible_safe/ansible.cfg"
      ANSIBLE_INVENTORY: "/tmp/ansible_safe/inventory" 
      ANSIBLE_HOST_KEY_CHECKING: "False"
      ANSIBLE_DEPRECATION_WARNINGS: "False"
      ANSIBLE_COMMAND_WARNINGS: "False"
      ANSIBLE_SYSTEM_WARNINGS: "False"
  tags:
    - setup
    - environment
    - ansible_config

- name: Run command with custom Ansible environment
  ansible.builtin.command: ansible --version
  environment: "{{ ansible_environment }}"

- name: Debug playbook directory
  ansible.builtin.debug:
    msg: "Playbook directory: {{ playbook_dir }}"
  tags:
    - setup
    - debug
    - paths

- name: Synchronize environments from playbook directory to working directory
  ansible.builtin.synchronize:
    src: "{{ playbook_dir }}/environments/"
    dest: "/tmp/ee-containers/environments/"
    delete: no
    archive: yes
    checksum: yes
    recursive: yes
  delegate_to: "{{ inventory_hostname }}"
  become: true
  register: env_synced
  tags:
    - setup
    - sync
    - environments

- name: Check if environment directories exist
  ansible.builtin.stat:
    path: "{{ paths.environments }}/{{ item }}"
  loop: "{{ environments_to_build | default([]) }}"
  register: env_exists
  when: environments_to_build is defined
  tags:
    - setup
    - validation
    - environments

- name: Debug environments_to_build list
  ansible.builtin.debug:
    msg: "Selected environments: {{ environments_to_build | join(', ') }}"
    verbosity: 1
  tags:
    - setup
    - debug
    - environments

####################################
# 2. ENVIRONMENT VALIDATION
####################################

- name: Set default values for potentially undefined variables
  ansible.builtin.set_fact:
    environments_to_build: "{{ environments_to_build | default([]) }}"
    timestamp: "{{ timestamp | default(lookup('pipe', 'date +%Y%m%d%H%M%S')) }}"
    cleanup_enabled: "{{ cleanup_enabled | default(true) }}"
  tags:
    - validation
    - variables
    - initialize

# IMPORTANT: This must come before any tasks that use env_exists

- name: Check if environments directory exists
  ansible.builtin.stat:
    path: "{{ playbook_dir }}/environments"
  register: env_dir_exists
  tags:
    - validation
    - environments
    - filesystem

- name: Fail if environments directory doesn't exist
  ansible.builtin.fail:
    msg: "Environments directory not found at {{ playbook_dir }}/environments"
  when: not env_dir_exists.stat.exists
  tags:
    - validation
    - environments
    - filesystem
    - always

# 

# CONSOLIDATED: Check for execution-environment.yml files
- name: Check if execution-environment.yml exists for each environment
  ansible.builtin.stat:
    path: "/tmp/ee-containers/environments/{{ item.item }}/execution-environment.yml"
  loop: "{{ env_exists.results }}"
  when: item.stat.exists and item.stat.isdir
  register: ee_yml_exists
  tags:
    - validation
    - environments
    - yaml_files

- name: Warn about missing execution-environment.yml files
  ansible.builtin.debug:
    msg: "WARNING: No execution-environment.yml found for {{ item.item.item }}. This environment will be skipped."
  loop: "{{ ee_yml_exists.results }}"
  when: 
    - item is defined 
    - (item.stat is defined and not item.stat.exists) or item.skipped is defined
  loop_control:
    label: "{{ item.item.item if item.item is defined else 'unknown' }}"
  tags:
    - validation
    - environments
    - warnings
    - yaml_files

####################################
# 3. ENHANCED FILE VALIDATION & ORGANIZATION
####################################

- name: Create directories for organized files
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    mode: "0755"
  loop:
    - "{{ playbook_dir }}/scripts"
    - "{{ playbook_dir }}/files"
  tags:
    - organize
    - directories

- name: Find all execution environment files for validation
  ansible.builtin.find:
    paths: "{{ playbook_dir }}/environments"
    recurse: yes
    patterns:
      - "execution-environment.yml"
      - "requirements.yml"
      - "requirements.txt"
      - "bindep.txt"
  register: ee_files_to_validate
  tags:
    - organize
    - validation

- name: Display all found execution environment files
  ansible.builtin.debug:
    msg: "Found {{ ee_files_to_validate.files | length }} files to validate"
    verbosity: 1
  tags:
    - organize
    - validation
    - debug

# Validate execution-environment.yml files for correct format
- name: Validate execution-environment.yml files
  block:
    - name: Check execution-environment.yml format
      ansible.builtin.command:
        cmd: python3 -c "import yaml; data = yaml.safe_load(open('{{ item.path }}', 'r')); print('Valid' if 'version' in data else 'Invalid')"
      register: ee_yml_validation
      changed_when: false
      failed_when: false
      loop: "{{ ee_files_to_validate.files | selectattr('path', 'search', 'execution-environment.yml') | list }}"
      loop_control:
        label: "{{ item.path | basename }}"

    - name: Display execution-environment.yml validation results
      ansible.builtin.debug:
        msg: "Validation of {{ item.item.path }}: {{ 'PASSED' if 'Valid' in item.stdout else 'FAILED' }}"
      loop: "{{ ee_yml_validation.results }}"
      loop_control:
        label: "{{ item.item.path | regex_replace(playbook_dir ~ '/environments/', '') }}"
      
    - name: Fix common execution-environment.yml issues
      ansible.builtin.copy:
        dest: "{{ item.item.path }}"
        content: |
          ---
          version: 3
          
          build_arg_defaults:
            ANSIBLE_GALAXY_CLI_COLLECTION_OPTS: '--ignore-errors'
            ANSIBLE_GALAXY_CLI_ROLE_OPTS: '--ignore-errors'
          
          images:
            base_image:
              name: '{{ base_image_name | default("registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel9:latest") }}'
          
          dependencies:
            python: requirements.txt
            system: bindep.txt
            galaxy: requirements.yml
          
          additional_build_steps:
            prepend_base: |
              RUN microdnf install -y python3-pip python3-devel
            append_base: |
              RUN microdnf upgrade -y && \
                  python3 -m pip install --no-cache-dir --upgrade pip setuptools wheel
            append_final: |
              USER root
              RUN microdnf clean all && \
                  rm -rf /var/cache/{dnf,yum} && \
                  rm -rf /etc/ansible/ansible.cfg
              RUN pip check || echo "Some packages have issues, but continuing anyway"
        mode: '0644'
        backup: yes
      vars:
        env_name: "{{ item.item.path | dirname | basename }}"
        base_image_name: >-
          {% if 'minimal' in env_name %}
          registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel{% if 'rhel8' in env_name %}8{% else %}9{% endif %}:latest
          {% else %}
          registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel{% if 'rhel8' in env_name %}8{% else %}9{% endif %}:latest
          {% endif %}
      when: "'Invalid' in item.stdout"
      loop: "{{ ee_yml_validation.results }}"
      loop_control:
        label: "{{ item.item.path | regex_replace(playbook_dir ~ '/environments/', '') }}"
  tags:
    - organize
    - validation
    - ee_yml

# Validate and fix requirements.txt files
- name: Fix empty or missing requirements.txt files
  ansible.builtin.copy:
    dest: "{{ playbook_dir }}/environments/{{ item.item }}/requirements.txt"
    content: |
      # Python dependencies required for this execution environment
      # Format: package[extra]==version
      # Example:
      # ansible-core>=2.14.0
      # pywinrm>=0.4.3
    mode: '0644'
    force: no
  loop: "{{ env_exists.results }}"
  when: item.stat.exists and item.stat.isdir
  tags:
    - organize
    - validation
    - requirements

# Validate and fix bindep.txt files
- name: Fix empty or missing bindep.txt files
  ansible.builtin.copy:
    dest: "{{ playbook_dir }}/environments/{{ item.item }}/bindep.txt"
    content: |
      # System dependencies required for this execution environment
      # Format: package [platform:platform_version]
      # Example:
      # gcc [platform:rpm]
      # openssl-devel [platform:rpm]
      # libffi-devel [platform:rpm]
    mode: '0644'
    force: no
  loop: "{{ env_exists.results }}"
  when: item.stat.exists and item.stat.isdir
  tags:
    - organize
    - validation
    - bindep

# Validate and fix requirements.yml files
- name: Fix empty or missing requirements.yml files
  ansible.builtin.copy:
    dest: "{{ playbook_dir }}/environments/{{ item.item }}/requirements.yml"
    content: |
      ---
      # Ansible collections and roles required for this execution environment
      collections:
        # - name: ansible.netcommon
        #   version: ">=4.1.0"
        # - name: ansible.utils
        #   version: ">=2.10.3"
      roles:
        # - name: example.role
        #   version: "1.0.0"
    mode: '0644'
    force: no
  loop: "{{ env_exists.results }}"
  when: item.stat.exists and item.stat.isdir
  tags:
    - organize
    - validation
    - galaxy_reqs

# Find and organize scripts from environment directories
- name: Find scripts in environment directories
  ansible.builtin.find:
    paths: "{{ playbook_dir }}/environments"
    recurse: yes
    file_type: file
    patterns: "*.sh"
    excludes:
      - "execution-environment.yml"
      - "requirements.yml"
      - "requirements.txt"
      - "bindep.txt"
  register: env_scripts
  tags:
    - organize
    - scripts

- name: Move environment scripts to scripts directory
  ansible.builtin.copy:
    src: "{{ item.path }}"
    dest: "{{ playbook_dir }}/scripts/{{ item.path | basename }}"
    mode: '0755'
    remote_src: yes
  loop: "{{ env_scripts.files }}"
  register: moved_scripts
  tags:
    - organize
    - scripts

# Find and organize other non-standard files
- name: Find other files in environment directories
  ansible.builtin.find:
    paths: "{{ playbook_dir }}/environments"
    recurse: yes
    file_type: file
    excludes:
      - "*.sh"
      - "execution-environment.yml"
      - "requirements.yml"
      - "requirements.txt"
      - "bindep.txt"
  register: other_env_files
  tags:
    - organize
    - files

# Add this task right before the "Move other environment files to files directory" task
- name: Ensure files directory exists with proper permissions
  ansible.builtin.file:
    path: "{{ playbook_dir }}/files"
    state: directory
    mode: '0755'
  tags:
    - organize
    - files
    - directories

# Fix the "Move other environment files to files directory" task by adding create: yes
- name: Move other environment files to files directory
  ansible.builtin.copy:
    src: "{{ item.path }}"
    dest: "{{ playbook_dir }}/files/{{ item.path | basename }}"
    mode: '0644'
    remote_src: yes
    # Add this parameter to create parent directories automatically
    directory_mode: '0755'
    # Add this parameter to ensure the directory is created
    create: yes
  loop: "{{ other_env_files.files }}"
  register: moved_files
  tags:
    - organize
    - files

# Re-synchronize files from source to tmp directory
- name: Re-synchronize environments after changes
  ansible.builtin.synchronize:
    src: "{{ playbook_dir }}/environments/{{ item.item }}/"
    dest: "/tmp/ee-containers/environments/{{ item.item }}/"
    delete: no
    archive: yes
    recursive: yes
  delegate_to: "{{ inventory_hostname }}"
  loop: "{{ env_exists.results }}"
  when: item.stat.exists and item.stat.isdir
  tags:
    - organize
    - sync

# Check for duplicate and conflicting requirements
- name: Check for duplicate Python requirements
  ansible.builtin.lineinfile:
    path: "{{ item.path }}/requirements.txt"
    line: "{{ item.line }}"
    state: present
  loop: "{{ lookup('file', '/tmp/ee-containers/environments/*/requirements.txt').split('\n') | select('match', '^[^#]') | list }}"
  tags:
    - organize
    - dedup
    - requirements

- name: Create Python helper script for deduplicating collections
  ansible.builtin.copy:
    dest: "/tmp/ee-containers/deduplicate_collections.py"
    mode: '0755'
    content: |
      #!/usr/bin/env python3
      import yaml, os, sys

      file_path = sys.argv[1]
      try:
          with open(file_path) as f:
              data = yaml.safe_load(f) or {}
          
          if "collections" in data:
              seen_collections = {}
              deduped_collections = []
              
              for coll in data["collections"]:
                  if isinstance(coll, dict) and "name" in coll:
                      name = coll["name"]
                      if name not in seen_collections or "version" in coll:
                          seen_collections[name] = coll
                          deduped_collections.append(coll)
                  elif isinstance(coll, str):
                      if coll not in seen_collections:
                          seen_collections[coll] = coll
                          deduped_collections.append(coll)
              
              data["collections"] = deduped_collections
          
          with open(file_path, "w") as f:
              yaml.dump(data, f, default_flow_style=False)
      except Exception as e:
          print(f"Error processing {file_path}: {e}")
          sys.exit(1)

- name: Check for duplicate Galaxy collection requirements
  ansible.builtin.shell: |
    for dir in /tmp/ee-containers/environments/*/; do
      if [ -f "$dir/requirements.yml" ]; then
        echo "Processing $(basename $dir) galaxy requirements"
        python3 /tmp/ee-containers/deduplicate_collections.py "$dir/requirements.yml"
      fi
    done
  args:
    executable: /bin/bash
  changed_when: false
  tags:
    - organize
    - dedup
    - galaxy_reqs

# Check for issues in execution environment files and provide improved fix
- name: Create fix_pattern task file
  ansible.builtin.copy:
    dest: "{{ playbook_dir }}/roles/ee-builder/tasks/fix_pattern.yml"
    mode: '0644'
    content: |
      ---
      - name: Fix pattern {{ pattern_index }} in {{ environment }}
        ansible.builtin.replace:
          path: "/tmp/ee-containers/environments/{{ environment }}/execution-environment.yml"
          regexp: "{{ item_regexes[pattern_index] }}"
          replace: "{{ item_replaces[pattern_index] }}"
        ignore_errors: true
        vars:
          item_regexes:
            - "additional_build_steps:[\\s\\n]+prepend:"
            - '(\s+)RUN\s+/output/scripts/pip_install'
            - "version:\\s+['\"]?2['\"]?"
            - "ansible.posix:[^\\n]+"
            - "(\n\\s+)(pip|dnf|yum)\\s+install"
          item_replaces:
            - "additional_build_steps:\n  prepend_base:"
            - '\1/output/scripts/pip_install'
            - "version: 3"
            - "ansible.posix: '>=1.5.1'"
            - "\\1microdnf install -y"

- name: Fix common issues in execution environment files
  include_tasks: fix_pattern.yml
  vars:
    environment: "{{ item.0 }}"
    pattern_index: "{{ item.1 }}"
  with_nested:
    - "{{ environments_to_build }}"
    - [0, 1, 2, 3, 4]
  loop_control:
    label: "{{ item.0 }} - pattern {{ item.1 }}"
  tags:
    - organize
    - validation
    - fix

# Comprehensive summary report of all file validations and changes
- name: Generate comprehensive validation report
  ansible.builtin.debug:
    msg: |
      ############################################################
      #             EXECUTION ENVIRONMENT VALIDATION             #
      ############################################################
      
      Total environments validated: {{ env_exists.results | length }}
      Script files relocated: {{ moved_scripts.results | default([]) | length }}
      Other files relocated: {{ moved_files.results | default([]) | length }}
      
      VALIDATION RESULTS:
      - execution-environment.yml files checked: {{ ee_yml_validation.results | default([]) | length }}
      - Fixed execution-environment.yml issues: {{ (ee_yml_validation.results | default([]) | selectattr('stdout', 'search', 'Invalid') | list | length) }}
      
      All environment files have been validated and synchronized back to the
      temporary build directory at /tmp/ee-containers/environments/
      
      The following best practices have been applied:
      1. Removed duplicate requirements
      2. Fixed common syntax errors
      3. Updated to version 3 format
      4. Organized scripts into {{ playbook_dir }}/scripts/
      5. Organized other files into {{ playbook_dir }}/files/
  tags:
    - organize
    - validation
    - summary
    - always

####################################
# 4. REGISTRY AUTHENTICATION
####################################

- name: Create system-wide auth file for podman
  ansible.builtin.copy:
    dest: "{{ registry.redhat.auth_file }}"
    mode: "0644"
    content: |
      {
        "auths": {
          "{{ registry.redhat.url }}": {
            "auth": "{{ (rh_username + ':' + rh_password) | b64encode }}",
            "username": "{{ rh_username }}",
            "password": "{{ rh_password }}"
          }
        }
      }
  become: true
  no_log: true
  register: auth_create
  when: 
    - rh_username is defined and rh_username != ""
    - rh_password is defined and rh_password != ""
  tags:
    - auth
    - registry
    - credentials
    - podman

- name: Create simplified registries.conf
  ansible.builtin.copy:
    dest: "/etc/containers/registries.conf"
    content: |
      [registries.search]
      registries = ['registry.access.redhat.com', 'registry.redhat.io', 'quay.io']
      
      [registries.insecure]
      registries = []
      
      [registries.block]
      registries = []
    mode: '0644'
  become: true
  tags:
    - auth
    - registry
    - config
    - podman

- name: Test registry authentication
  ansible.builtin.command:
    cmd: "podman pull registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel9:latest"
  register: auth_test
  changed_when: false
  ignore_errors: true
  tags:
    - auth
    - registry
    - test
    - podman

- name: Display auth test results
  ansible.builtin.debug:
    msg: "Authentication test result: {{ 'SUCCESS' if auth_test.rc == 0 else 'FAILED - ' + auth_test.stderr }}"
  tags:
    - auth
    - registry
    - debug
    - podman

####################################
# 5. PREPARE ENVIRONMENT FILES
####################################

- name: Load variables from config file
  ansible.builtin.include_vars:
    file: "~/.ansible/vars/config"
    name: config_vars
  ignore_errors: true
  tags:
    - prepare
    - config
    - variables

- name: Create ansible.cfg file from template if not exists
  ansible.builtin.template:
    src: "{{ role_path }}/templates/ansible.cfg.j2"
    dest: "/tmp/ee-containers/ansible.cfg"
    mode: '0644'
    force: no
  vars:
    ansible_vars: "{{ config_vars | default({}) }}"
  tags:
    - prepare
    - config
    - ansible_config
    - templates

- name: Copy ansible.cfg to each environment
  ansible.builtin.copy:
    src: "/tmp/ee-containers/ansible.cfg"
    dest: "/tmp/ee-containers/environments/{{ item }}/ansible.cfg"
    mode: '0644'
  loop: "{{ environments_to_build }}"
  tags:
    - prepare
    - config
    - ansible_config
    - copy

- name: Create requirements.txt for each environment (if needed)
  ansible.builtin.copy:
    dest: "/tmp/ee-containers/environments/{{ item }}/requirements.txt"
    content: |
      # Python dependencies required for this execution environment
      # Format: package[extra]==version
      # Example:
      # ansible-core>=2.14.0
      # pywinrm>=0.4.3
    mode: "0644"
    force: false
  loop: "{{ environments_to_build }}"
  failed_when: false
  tags:
    - prepare
    - config
    - python
    - requirements

####################################
# 6. CREATE HELPER SCRIPTS
####################################

# Copy pre-built custom assemble script
- name: Copy custom assemble script
  ansible.builtin.copy:
    src: "{{ playbook_dir }}/roles/ee-builder/scripts/custom-assemble.sh"
    dest: "/tmp/ee-containers/custom-assemble.sh"
    mode: "0755"
  tags:
    - scripts
    - copy
    - assemble

- name: Create Containerfile template with version 3 compatibility
  ansible.builtin.copy:
    dest: "/tmp/ee-containers/containerfiles/Containerfile.j2"
    mode: "0644"
    content: |
      FROM {{ '{{' }} base_image {{ '}}' }} AS base
      USER root
      ENV PIP_BREAK_SYSTEM_PACKAGES=1
      
      # Fix missing package managers
      RUN if [ ! -f /usr/bin/dnf ] && [ -f /usr/bin/microdnf ]; then \
            ln -s /usr/bin/microdnf /usr/bin/dnf || true; \
          fi
      
      # Version 3 builder configuration
      ARG EE_BASE_IMAGE
      ARG PYCMD=python3
      ARG PKGMGR=dnf
      
      # Install Python requirements and collections
      COPY --chown=root:root ansible.cfg /etc/ansible/ansible.cfg
  tags:
    - scripts
    - templates
    - containerfile
    - create

# Copy pre-built hook script from scripts directory
- name: Copy pre-build hook
  ansible.builtin.copy:
    src: "{{ playbook_dir }}/roles/ee-builder/scripts/hooks/pre-build"
    dest: "{{ paths.hooks }}/pre-build"
    mode: "0755"
  tags:
    - scripts
    - copy
    - hooks

####################################
# 7. FIX EXECUTION ENVIRONMENT YAML FILES
####################################

# Add this task FIRST in the section to find all the execution-environment.yml files
- name: Find all execution-environment.yml files
  ansible.builtin.find:
    paths: "/tmp/ee-containers/environments"
    patterns: "execution-environment.yml"
    recurse: yes
  register: ee_yml_files
  tags:
    - yaml
    - find
    - validation

# FIRST run validation to capture which files have YAML errors
- name: Verify execution-environment.yml files are properly formatted
  ansible.builtin.command:
    cmd: python3 -c "import yaml; yaml.safe_load(open('{{ item.path }}'))"
  loop: "{{ ee_yml_files.files }}"
  register: yaml_validation
  ignore_errors: true
  changed_when: false
  tags:
    - yaml
    - validation
    - verify

# Then keep your existing tasks
- name: Create backup directory for original files
  ansible.builtin.file:
    path: "/tmp/ee-containers/backups"
    state: directory
    mode: "0755"
  tags:
    - yaml
    - backup
    - directories

# Find all execution-environment.yml files first
- name: Find all execution-environment.yml files for backup
  ansible.builtin.find:
    paths: "/tmp/ee-containers"
    patterns: "execution-environment.yml"
    recurse: yes
  register: ee_yml_files_to_backup
  tags:
    - yaml
    - backup
    - find

# Then back up each file to the backup directory
- name: Back up all execution-environment.yml files
  ansible.builtin.copy:
    src: "{{ item.path }}"
    dest: "/tmp/ee-containers/backups/{{ item.path | dirname | basename }}-execution-environment.yml"
    mode: preserve
    remote_src: yes
  loop: "{{ ee_yml_files_to_backup.files }}"
  tags:
    - yaml
    - backup
    - copy

# THEN fix the broken files based on validation results
- name: Force-fix all execution-environment.yml files
  ansible.builtin.copy:
    dest: "{{ item.path }}"
    content: |
      ---
      version: 3
      
      build_arg_defaults:
        ANSIBLE_GALAXY_CLI_COLLECTION_OPTS: '--ignore-errors'
        ANSIBLE_GALAXY_CLI_ROLE_OPTS: '--ignore-errors'
      
      images:
        base_image:
          name: 'registry.redhat.io/ansible-automation-platform-25/ee-{% if "minimal" in item.path %}minimal{% else %}supported{% endif %}-rhel{% if "rhel8" in item.path %}8{% else %}9{% endif %}:latest'
      
      options:
        package_manager_path: /usr/bin/microdnf  # More consistent than dnf
      
      dependencies:
        python: requirements.txt
        system: bindep.txt
        galaxy: requirements.yml

      additional_build_steps:
        prepend_base: |
          # Commands to run before the base build
        append_base: |
          # Commands to run after the base build
        prepend_galaxy: |
          # Commands to run before galaxy install
        append_galaxy: |
          # Commands to run after galaxy install
        prepend_final: |
          # Commands to run before final stage
        append_final: |
          # Commands to run after final stage
    mode: '0644'
  loop: "{{ ee_yml_files.files }}"
  when: 
    - item.path.endswith('execution-environment.yml')
    - item.path in (yaml_validation.results | selectattr('rc', 'defined') | rejectattr('rc', 'eq', 0) | map(attribute='item.path') | list)
  ignore_errors: true
  tags:
    - yaml
    - fix
    - create

- name: Verify execution-environment.yml files are properly formatted
  ansible.builtin.command:
    cmd: python3 -c "import yaml; yaml.safe_load(open('{{ item.path }}'))"
  loop: "{{ ee_yml_files.files }}"
  register: yaml_validation
  ignore_errors: true
  changed_when: false
  tags:
    - yaml
    - validation
    - verify

- name: Display validation results for execution-environment.yml files
  ansible.builtin.debug:
    msg: |
      Valid YAML files: {{ yaml_validation.results | selectattr('rc', 'defined') | selectattr('rc', 'eq', 0) | list | length }}
      Invalid YAML files: {{ yaml_validation.results | selectattr('rc', 'defined') | rejectattr('rc', 'eq', 0) | list | length }}
      {% if yaml_validation.results | selectattr('rc', 'defined') | rejectattr('rc', 'eq', 0) | list | length > 0 %}
      Warning: Some files still have YAML errors. The build may fail.
      {% endif %}
  tags:
    - yaml
    - validation
    - debug

- name: Fix invalid 'prepend' property in execution-environment.yml files
  ansible.builtin.replace:
    path: "/tmp/ee-containers/environments/{{ item }}/execution-environment.yml"
    regexp: "additional_build_steps:[\\s\\n]+prepend:"
    replace: "additional_build_steps:\n  prepend_base:"
  loop: "{{ environments_to_build }}"
  ignore_errors: true
  tags:
    - yaml
    - fix
    - schema

- name: Fix extra RUN command in execution environment files
  ansible.builtin.replace:
    path: "/tmp/ee-containers/environments/{{ item }}/execution-environment.yml"
    regexp: '(\s+)RUN\s+/output/scripts/pip_install'
    replace: '\1/output/scripts/pip_install'
  loop: "{{ environments_to_build }}"
  ignore_errors: true
  tags:
    - yaml
    - fix
    - containerfile

####################################
# 8. MONITORING SETUP
####################################

- name: Check if tmux is installed
  ansible.builtin.command: which tmux
  register: tmux_install
  failed_when: false
  changed_when: false
  tags:
    - monitor
    - tmux

- name: Install tmux if missing
  ansible.builtin.package:
    name: tmux
    state: present
  when: tmux_install.rc != 0
  become: true
  ignore_errors: true
  tags:
    - monitor
    - tmux

- name: Create improved TMux launcher script with persistent window
  ansible.builtin.copy:
    dest: "{{ playbook_dir }}/scripts/ee-tmux-monitor.sh"
    content: |
      #!/bin/bash
      
      # Terminal colors and styling
      BOLD="\033[1m"
      GREEN="\033[32m"
      YELLOW="\033[33m"
      BLUE="\033[34m"
      MAGENTA="\033[35m"
      CYAN="\033[36m"
      RESET="\033[0m"
      
      # Session name and build information
      SESSION="ansible-builder"
      TIMESTAMP="$1"
      ENVS="$2"
      
      # Kill any existing session
      tmux kill-session -t $SESSION 2>/dev/null || true
      
      # Create new tmux session
      tmux new-session -d -s $SESSION -n "EE Builder"
      
      # Create layout: 3 panes stacked vertically
      tmux split-window -v -p 70 -t $SESSION:0
      tmux split-window -v -p 50 -t $SESSION:0
      
      # Top pane: Title with fancy formatting
      tmux send-keys -t $SESSION:0.0 "clear && echo -e '${BLUE}${BOLD}╔═══════════════════════════════════════╗${RESET}'" C-m
      tmux send-keys -t $SESSION:0.0 "echo -e '${BLUE}${BOLD}║  ANSIBLE EXECUTION ENVIRONMENT BUILDER  ║${RESET}'" C-m
      tmux send-keys -t $SESSION:0.0 "echo -e '${BLUE}${BOLD}╚═══════════════════════════════════════╝${RESET}'" C-m
      
      # Middle pane: Show build progress with spinner
      tmux send-keys -t $SESSION:0.1 "clear && echo -e '${CYAN}${BOLD}Building:${RESET} $ENVS'" C-m
      tmux send-keys -t $SESSION:0.1 "echo" C-m
      tmux send-keys -t $SESSION:0.1 "function show_spinner() {" C-m
      tmux send-keys -t $SESSION:0.1 "  local spinstr='⣾⣽⣻⢿⡿⣟⣯⣷'" C-m
      tmux send-keys -t $SESSION:0.1 "  while true; do" C-m
      tmux send-keys -t $SESSION:0.1 "    for i in \$(seq 0 7); do" C-m
      tmux send-keys -t $SESSION:0.1 "      printf \"\\r${YELLOW}${BOLD}⏳ Building...${RESET} \${spinstr:\$i:1}\"" C-m
      tmux send-keys -t $SESSION:0.1 "      sleep 0.1" C-m
      tmux send-keys -t $SESSION:0.1 "      if ! pgrep -f ansible-builder >/dev/null; then" C-m
      tmux send-keys -t $SESSION:0.1 "        printf \"\\r${GREEN}${BOLD}✅ Build completed!${RESET}           \\n\"" C-m
      tmux send-keys -t $SESSION:0.1 "        return" C-m
      tmux send-keys -t $SESSION:0.1 "      fi" C-m
      tmux send-keys -t $SESSION:0.1 "    done" C-m
      tmux send-keys -t $SESSION:0.1 "  done" C-m
      tmux send-keys -t $SESSION:0.1 "}" C-m
      tmux send-keys -t $SESSION:0.1 "(pgrep -f ansible-builder && show_spinner) || echo -e '${MAGENTA}Waiting for build to start...${RESET}'" C-m
      
      # Bottom pane: Watch podman images refreshing quickly
      tmux send-keys -t $SESSION:0.2 "watch -n 0.5 'podman images | grep ${TIMESTAMP} || echo \"No images built yet\"'" C-m
      
      # This is the key change - choose how to handle TMux based on environment
      if [ -n "$DISPLAY" ] || [ -n "$WSL_DISTRO_NAME" ] || [ "$OSTYPE" == "darwin"* ]; then
        # We have a GUI - try to launch in a new terminal window
        if [ -n "$WSL_DISTRO_NAME" ]; then
          # WSL environment
          which wt.exe > /dev/null 2>&1 && wt.exe new-tab -p "Ubuntu" bash -c "tmux attach -t $SESSION" || \
          cmd.exe /c "start bash -c \"tmux attach -t $SESSION\"" 
        elif [ "$OSTYPE" == "darwin"* ]; then
          # macOS
          osascript -e 'tell app "Terminal" to do script "tmux attach -t '$SESSION'"'
        else
          # Linux with GUI
          which gnome-terminal > /dev/null 2>&1 && gnome-terminal -- tmux attach -t $SESSION || \
          which konsole > /dev/null 2>&1 && konsole -e "tmux attach -t $SESSION" || \
          which xterm > /dev/null 2>&1 && xterm -e "tmux attach -t $SESSION" &
        fi
      else
        # Just attach directly (headless or fallback)
        echo -e "${BLUE}${BOLD}=====================================================================${RESET}"
        echo -e "${GREEN}${BOLD}TMux monitoring session started${RESET}"
        echo -e "${BLUE}${BOLD}=====================================================================${RESET}"
        echo -e ""
        echo -e "Connect to the monitoring session with:"
        echo -e "${CYAN}${BOLD}tmux attach -t $SESSION${RESET}"
        echo -e ""
        echo -e "The monitor shows:"
        echo -e "  - ${YELLOW}Top pane:${RESET} Title banner"
        echo -e "  - ${YELLOW}Middle pane:${RESET} Build progress with animated spinner"
        echo -e "  - ${YELLOW}Bottom pane:${RESET} Real-time image listing (refreshes every 0.5s)"
        echo -e ""
        echo -e "To detach from the session: Press ${CYAN}Ctrl+B${RESET} then ${CYAN}D${RESET}"
        echo -e "${BLUE}${BOLD}=====================================================================${RESET}"
        echo ""
        echo -e "${MAGENTA}Press ENTER to attach to monitoring session now...${RESET}"
        read
        
        # Direct attach - this will keep terminal window open
        exec tmux attach -t $SESSION
      fi
  tags:
    - monitor
    - tmux
    - scripts

- name: Copy TMux monitor script to working directory
  ansible.builtin.copy:
    src: "{{ playbook_dir }}/scripts/ee-tmux-monitor.sh"
    dest: "/tmp/ee-containers/ee-tmux-monitor.sh" 
    mode: '0755'
  tags:
    - monitor
    - tmux

# IMPORTANT: Remove async/poll to keep the terminal window open
- name: Launch persistent TMux monitoring session
  ansible.builtin.command: 
    cmd: "/tmp/ee-containers/ee-tmux-monitor.sh {{ timestamp }} '{{ environments_to_build | join(', ') }}'"
  # Remove the async/poll to keep terminal attached
  when: environments_to_build is defined and environments_to_build | length > 0
  tags:
    - monitor
    - tmux

# Copy Python helper script
- name: Copy deduplication script to working directory
  ansible.builtin.copy:
    src: "{{ playbook_dir }}/scripts/deduplicate_collections.py"
    dest: "/tmp/ee-containers/deduplicate_collections.py"
    mode: '0755'
  tags:
    - organize
    - dedup
    - galaxy_reqs

- name: Create universal TMux launcher script
  ansible.builtin.copy:
    dest: "{{ playbook_dir }}/scripts/universal-tmux-launcher.sh"
    content: |
      #!/bin/bash

      # Terminal colors and styling
      BOLD="\033[1m"
      GREEN="\033[32m"
      YELLOW="\033[33m"
      BLUE="\033[34m"
      MAGENTA="\033[35m"
      CYAN="\033[36m"
      RESET="\033[0m"
      
      # Session name and parameters
      SESSION="ansible-builder"
      TIMESTAMP="$1"
      ENVS="$2"
      
      # Function to detect environment
      detect_environment() {
        # Check for WSL
        if [[ -n "$WSL_DISTRO_NAME" || -f /proc/version ]] && grep -qi microsoft /proc/version 2>/dev/null; then
          echo "wsl"
          return
        fi

        # Check for macOS
        if [[ "$OSTYPE" == "darwin"* ]]; then
          echo "macos"
          return
        fi

        # Check for various Linux desktop environments
        if [[ -n "$XDG_CURRENT_DESKTOP" ]]; then
          echo "linux-desktop-${XDG_CURRENT_DESKTOP,,}"  # Lowercase the name
          return
        fi

        # Check for SSH session
        if [[ -n "$SSH_CLIENT" || -n "$SSH_TTY" || -n "$SSH_CONNECTION" ]]; then
          echo "ssh"
          return
        fi

        # Check for PuTTY
        if [[ -n "$TERM" && "$TERM" == "putty" || -n "$PUTTY_PORT" ]]; then
          echo "putty"
          return
        fi

        # Check for MobaXterm
        if [[ -n "$TERM" && "$TERM" == "xterm" && -n "$CHERE_INVOKING" ]]; then
          echo "mobaxterm"
          return
        fi

        # Default to basic terminal
        echo "basic"
      }

      # Function to set up tmux session
      setup_tmux_session() {
        # Kill any existing session
        tmux kill-session -t $SESSION 2>/dev/null || true
        
        # Create new tmux session
        tmux new-session -d -s $SESSION -n "EE Builder"
        
        # Create layout: 3 panes stacked vertically
        tmux split-window -v -p 70 -t $SESSION:0
        tmux split-window -v -p 50 -t $SESSION:0
        
        # Top pane: Title with fancy formatting
        tmux send-keys -t $SESSION:0.0 "clear && echo -e '${BLUE}${BOLD}╔═══════════════════════════════════════╗${RESET}'" C-m
        tmux send-keys -t $SESSION:0.0 "echo -e '${BLUE}${BOLD}║  ANSIBLE EXECUTION ENVIRONMENT BUILDER  ║${RESET}'" C-m
        tmux send-keys -t $SESSION:0.0 "echo -e '${BLUE}${BOLD}╚═══════════════════════════════════════╝${RESET}'" C-m
        
        # Middle pane: Show build progress with spinner
        tmux send-keys -t $SESSION:0.1 "clear && echo -e '${CYAN}${BOLD}Building:${RESET} $ENVS'" C-m
        tmux send-keys -t $SESSION:0.1 "echo" C-m
        tmux send-keys -t $SESSION:0.1 "function show_spinner() {" C-m
        tmux send-keys -t $SESSION:0.1 "  local spinstr='⣾⣽⣻⢿⡿⣟⣯⣷'" C-m
        tmux send-keys -t $SESSION:0.1 "  while true; do" C-m
        tmux send-keys -t $SESSION:0.1 "    for i in \$(seq 0 7); do" C-m
        tmux send-keys -t $SESSION:0.1 "      printf \"\\r${YELLOW}${BOLD}⏳ Building...${RESET} \${spinstr:\$i:1}\"" C-m
        tmux send-keys -t $SESSION:0.1 "      sleep 0.1" C-m
        tmux send-keys -t $SESSION:0.1 "      if ! pgrep -f ansible-builder >/dev/null; then" C-m
        tmux send-keys -t $SESSION:0.1 "        printf \"\\r${GREEN}${BOLD}✅ Build completed!${RESET}           \\n\"" C-m
        tmux send-keys -t $SESSION:0.1 "        return" C-m
        tmux send-keys -t $SESSION:0.1 "      fi" C-m
        tmux send-keys -t $SESSION:0.1 "    done" C-m
        tmux send-keys -t $SESSION:0.1 "  done" C-m
        tmux send-keys -t $SESSION:0.1 "}" C-m
        tmux send-keys -t $SESSION:0.1 "(pgrep -f ansible-builder && show_spinner) || echo -e '${MAGENTA}Waiting for build to start...${RESET}'" C-m
        
        # Bottom pane: Watch podman images refreshing quickly
        tmux send-keys -t $SESSION:0.2 "watch -n 0.5 'podman images | grep ${TIMESTAMP} || echo \"No images built yet\"'" C-m
      }

      # Function to launch terminal and attach tmux session
      launch_terminal() {
        local env=$1
        local success=false
        
        case "$env" in
          wsl)
            # Try Windows Terminal first, then fallback to cmd
            if command -v wt.exe &>/dev/null; then
              wt.exe new-tab --title "Ansible EE Builder" wsl.exe -d $(wslpath -w ~ | cut -d'\' -f3) bash -c "tmux attach -t $SESSION" && success=true
            fi
            
            # Fallback to cmd.exe if wt.exe failed
            if [[ "$success" != "true" ]]; then
              cmd.exe /c "start bash.exe -c \"tmux attach -t $SESSION\"" && success=true
            fi
            ;;
            
          macos)
            # Try iTerm first, then Terminal.app
            if osascript -e 'id of application "iTerm"' &>/dev/null; then
              osascript -e 'tell application "iTerm" to create window with default profile command "tmux attach -t '$SESSION'"' && success=true
            fi
            
            if [[ "$success" != "true" ]]; then
              osascript -e 'tell app "Terminal" to do script "tmux attach -t '$SESSION'"' && success=true
            fi
            ;;
            
          linux-desktop-gnome | linux-desktop-unity)
            # GNOME/Unity environments
            if command -v gnome-terminal &>/dev/null; then
              gnome-terminal -- bash -c "tmux attach -t $SESSION" && success=true
            fi
            ;;
            
          linux-desktop-kde)
            # KDE environment
            if command -v konsole &>/dev/null; then
              konsole -e bash -c "tmux attach -t $SESSION" && success=true
            fi
            ;;
            
          linux-desktop-xfce)
            # XFCE environment
            if command -v xfce4-terminal &>/dev/null; then
              xfce4-terminal -e "tmux attach -t $SESSION" && success=true
            fi
            ;;
            
          linux-desktop-mate)
            # MATE environment
            if command -v mate-terminal &>/dev/null; then
              mate-terminal -e "tmux attach -t $SESSION" && success=true
            fi
            ;;
            
          linux-desktop-cinnamon)
            # Cinnamon environment
            if command -v gnome-terminal &>/dev/null; then
              gnome-terminal -- bash -c "tmux attach -t $SESSION" && success=true
            fi
            ;;
            
          *)
            # Try various common terminal emulators as fallbacks
            for term in x-terminal-emulator xterm urxvt terminology alacritty kitty terminator termite; do
              if command -v $term &>/dev/null; then
                if [[ "$term" == "xterm" ]]; then
                  $term -e "tmux attach -t $SESSION" && success=true && break
                else
                  $term -e "tmux attach -t $SESSION" && success=true && break
                fi
              fi
            done
            ;;
        esac
        
        echo "$success"
      }

      # Function to display instructions
      display_instructions() {
        echo -e "${BLUE}${BOLD}=====================================================================${RESET}"
        echo -e "${GREEN}${BOLD}TMux monitoring session created${RESET}"
        echo -e "${BLUE}${BOLD}=====================================================================${RESET}"
        echo -e ""
        echo -e "Connect to the monitoring session with:"
        echo -e "${CYAN}${BOLD}tmux attach -t $SESSION${RESET}"
        echo -e ""
        echo -e "The monitor shows:"
        echo -e "  - ${YELLOW}Top pane:${RESET} Title banner"
        echo -e "  - ${YELLOW}Middle pane:${RESET} Build progress with animated spinner"
        echo -e "  - ${YELLOW}Bottom pane:${RESET} Real-time image listing (refreshes every 0.5s)"
        echo -e ""
        echo -e "To detach from the session: Press ${CYAN}Ctrl+B${RESET} then ${CYAN}D${RESET}"
        echo -e "${BLUE}${BOLD}=====================================================================${RESET}"
      }

      # Main process
      ENVIRONMENT=$(detect_environment)
      echo "Detected environment: $ENVIRONMENT"

      # Set up tmux session
      setup_tmux_session
      
      # Try to launch terminal
      LAUNCH_RESULT=$(launch_terminal "$ENVIRONMENT")
      
      if [[ "$LAUNCH_RESULT" != "true" ]]; then
        # No GUI or couldn't launch terminal automatically
        display_instructions
        
        if [[ "$SSH_TTY" || "$ENVIRONMENT" == "putty" || "$ENVIRONMENT" == "mobaxterm" || "$ENVIRONMENT" == "ssh" || "$ENVIRONMENT" == "basic" ]]; then
          echo -e "${MAGENTA}Press ENTER to attach to the monitoring session now...${RESET}"
          read
          exec tmux attach -t $SESSION
        fi
      fi
    mode: '0755'
  tags:
    - monitor
    - tmux
    - scripts

- name: Copy universal TMux launcher to working directory
  ansible.builtin.copy:
    src: "{{ playbook_dir }}/scripts/universal-tmux-launcher.sh"
    dest: "/tmp/ee-containers/universal-tmux-launcher.sh"
    mode: '0755'
  tags:
    - monitor
    - tmux

- name: Launch universal TMux monitoring session
  ansible.builtin.command:
    cmd: "/tmp/ee-containers/universal-tmux-launcher.sh {{ timestamp }} '{{ environments_to_build | join(', ') }}'"
  when: environments_to_build is defined and environments_to_build | length > 0
  tags:
    - monitor
    - tmux

####################################
# 9. GENERATE CUSTOM CONTAINERFILES
####################################

- name: Copy custom assemble script to context directory
  ansible.builtin.copy:
    dest: "/tmp/ee-containers/context/_build/scripts/assemble"
    src: "/tmp/ee-containers/custom-assemble.sh"
    mode: "0755"
  ignore_errors: true
  tags:
    - containerfiles
    - copy
    - scripts
    - assemble

# CONSOLIDATED: Generate custom Containerfile for each environment
- name: Generate custom Containerfile for each environment
  ansible.builtin.template:
    src: "Containerfile.j2"
    dest: "{{ paths.environments }}/{{ item.item }}/Containerfile"
    mode: "0644"
  vars:
    ee_file_path: "{{ paths.environments }}/{{ item.item }}/execution-environment.yml"
    base_image: "{{ lookup('file', ee_file_path, errors='ignore') | default('version: 3') | from_yaml | json_query('images.base_image.name') | default('registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel9:latest') }}"
  loop: "{{ env_exists.results }}"
  when: item.stat.exists and item.stat.isdir
  register: containerfile_gen
  tags:
    - containerfiles
    - templates
    - generate

- name: Debug environment verification start
  ansible.builtin.debug:
    msg: "Checking if {{ item.item }} environment still exists..."
  loop: "{{ env_exists.results }}"
  when: item.stat.exists and item.stat.isdir
  tags:
    - containerfiles
    - verification
    - debug

- name: Check environment directory existence
  ansible.builtin.stat:
    path: "/tmp/ee-containers/environments/{{ item.item }}"
  register: env_dir_check_loop
  loop: "{{ env_exists.results }}"
  when: item.stat.exists and item.stat.isdir
  tags:
    - containerfiles
    - verification
    - debug

- name: List files in environment directory
  ansible.builtin.find:
    paths: "/tmp/ee-containers/environments/{{ item.item }}"
    file_type: any
    recurse: no
  register: env_files
  loop: "{{ env_exists.results }}"
  when: item.stat.exists and item.stat.isdir
  tags:
    - containerfiles
    - verification
    - debug

- name: Display environment directory contents (header)
  ansible.builtin.debug:
    msg: "Files in {{ item.item }} environment:"
  loop: "{{ env_exists.results }}"
  when: item.stat.exists and item.stat.isdir
  tags:
    - containerfiles
    - verification
    - debug

- name: List directory files with shell command
  ansible.builtin.shell: "ls -la /tmp/ee-containers/environments/{{ item.item }}"
  register: dir_listing
  loop: "{{ env_exists.results }}"
  when: item.stat.exists and item.stat.isdir
  changed_when: false
  tags:
    - containerfiles
    - verification
    - debug

- name: Show directory listing
  ansible.builtin.debug:
    msg: "{{ dir_listing.results[index].stdout }}"
  loop: "{{ env_exists.results }}"
  loop_control:
    index_var: index
  when: item.stat.exists and item.stat.isdir and dir_listing.results[index] is defined
  tags:
    - containerfiles
    - verification
    - debug

- name: Check execution-environment.yml existence
  ansible.builtin.stat:
    path: "/tmp/ee-containers/environments/{{ item.item }}/execution-environment.yml"
  register: ee_yml_file
  loop: "{{ env_exists.results }}"
  when: item.stat.exists and item.stat.isdir
  tags:
    - containerfiles
    - verification
    - debug

- name: Read execution-environment.yml content
  ansible.builtin.slurp:
    src: "/tmp/ee-containers/environments/{{ item.0.item }}/execution-environment.yml"
  register: ee_yml_content
  loop: "{{ env_exists.results | zip(ee_yml_file.results) | list }}"
  when: item.0.stat.exists and item.0.stat.isdir and item.1.stat.exists
  loop_control:
    label: "{{ item.0.item }}"
  tags:
    - containerfiles
    - verification
    - debug

# First, fix the display task
- name: Display execution-environment.yml content
  ansible.builtin.debug:
    msg: |
      execution-environment.yml found
      Content:
      {{ item.1.content | b64decode }}
  loop: "{{ env_exists.results | zip(ee_yml_content.results) | list }}"
  when: item.0.stat.exists and item.0.stat.isdir and item.1 is defined and not item.1.skipped | default(false)
  loop_control:
    label: "{{ item.0.item }}"
  tags:
    - containerfiles
    - verification
    - debug

# Also fix the "Report missing" task which has the same issue
- name: Report missing execution-environment.yml
  ansible.builtin.debug:
    msg: "execution-environment.yml NOT found"
  loop: "{{ env_exists.results | zip(ee_yml_file.results) | list }}"
  when: item.0.stat.exists and item.0.stat.isdir and not item.1.stat.exists
  loop_control:
    label: "{{ item.0.item }}"
  tags:
    - containerfiles
    - verification
    - debug

- name: Report missing environment directory
  ansible.builtin.debug:
    msg: "Directory for {{ item.0.item }} does NOT exist"
  loop: "{{ env_exists.results | zip(env_dir_check_loop.results) | list }}"
  when: not item.1.stat.exists
  loop_control:
    label: "{{ item.0.item }}"
  tags:
    - containerfiles
    - verification
    - debug

- name: Create required _build directory structure for each environment
  ansible.builtin.file:
    path: "/tmp/ee-containers/environments/{{ item.item }}/_build/scripts"
    state: directory
    mode: "0755"
  loop: "{{ env_exists.results }}"
  when: item.stat.exists and item.stat.isdir
  tags:
    - containerfiles
    - directories
    - setup

- name: Copy assemble script to each environment's build context
  ansible.builtin.copy:
    src: "{{ playbook_dir }}/scripts/custom-assemble.sh"
    dest: "/tmp/ee-containers/environments/{{ item.item }}/_build/scripts/assemble"
    mode: "0755"
  loop: "{{ env_exists.results }}"
  when: item.stat.exists and item.stat.isdir
  tags:
    - containerfiles
    - copy
    - scripts
    - assemble

# Create entrypoint script in central scripts directory first
- name: Create entrypoint script in scripts directory
  ansible.builtin.copy:
    dest: "{{ playbook_dir }}/scripts/entrypoint.sh"
    content: |
      #!/bin/bash
      exec "$@"
    mode: "0755"
  tags:
    - containerfiles
    - copy
    - scripts
    - entrypoint

# Then copy from there to each environment
- name: Copy entrypoint script to each environment's build context
  ansible.builtin.copy:
    src: "{{ playbook_dir }}/scripts/entrypoint.sh"
    dest: "/tmp/ee-containers/environments/{{ item.item }}/_build/scripts/entrypoint"
    mode: "0755"
  loop: "{{ env_exists.results }}"
  when: item.stat.exists and item.stat.isdir
  tags:
    - containerfiles
    - copy
    - scripts
    - entrypoint

####################################
# 10. BUILD IMAGES
####################################

# Copy pre-built assemble script from scripts directory
- name: Copy modified assemble script
  ansible.builtin.copy:
    src: "{{ playbook_dir }}/roles/ee-builder/scripts/build/assemble"
    dest: "{{ paths.build }}"
    mode: "0755"
  tags:
    - build
    - copy
    - scripts
    - assemble

# Replace the synchronous build task with this async version
- name: Start container builds asynchronously
  ansible.builtin.command:
    cmd: "ansible-builder build -v3 --prune --file execution-environment.yml --tag {{ item.item }}:{{ timestamp }}"
    chdir: "/tmp/ee-containers/environments/{{ item.item }}"
  become: true
  environment:
    REGISTRY_AUTH_FILE: "/etc/containers/auth.json"
  async: 3600  # Allow up to 1 hour for completion
  poll: 0  # Don't wait for completion
  register: build_jobs
  loop: "{{ env_exists.results }}"
  when: item.stat.exists and item.stat.isdir
  loop_control:
    label: "{{ item.item }}"
  tags:
    - build
    - images
    - ansible_builder

- name: Display background build status
  ansible.builtin.debug:
    msg: "Build jobs started in background: {{ environments_to_build | length }}"

# Periodically check build status and write to log file
- name: Add build monitoring task
  ansible.builtin.shell: |
    while true; do
      echo "$(date) - Checking build status..." >> /tmp/ee-containers/build_monitor.log
      podman ps -a >> /tmp/ee-containers/build_monitor.log
      echo "Current images:" >> /tmp/ee-containers/build_monitor.log
      podman images | grep {{ timestamp }} >> /tmp/ee-containers/build_monitor.log 2>&1
      sleep 30
    done &
  args:
    executable: /bin/bash
  async: 3600
  poll: 0

# Create a status file that can be viewed with "watch cat"
- name: Create build status file for monitoring
  ansible.builtin.copy:
    dest: "/tmp/ee-containers/build_status.txt"
    content: |
      Build Status Monitor
      ===================
      Started: {{ lookup('pipe', 'date') }}
      Environments: {{ environments_to_build | join(', ') }}
      
      Run this command to monitor builds:
      watch -n 5 "cat /tmp/ee-containers/build_status.txt"
      
      Or check images with:
      watch -n 5 "podman images | grep {{ timestamp }}"
    mode: '0644'

- name: Display monitoring instructions
  ansible.builtin.debug:
    msg: |
      ✅ Builds started in the background!
      
      To monitor progress:
        - Run: watch -n 5 "cat /tmp/ee-containers/build_status.txt"
        - Or: watch -n 5 "podman images | grep {{ timestamp }}"
        - Or: tail -f /tmp/ee-containers/build_monitor.log
      
      Builds will take several minutes to complete.

- name: Set build log path for each environment
  ansible.builtin.set_fact:
    build_log: "/tmp/ee-containers/environments/{{ item.item }}/build-direct-{{ timestamp }}.log"
  loop: "{{ env_exists.results }}"
  when: item.stat.exists and item.stat.isdir
  register: build_logs
  tags:
    - build
    - images
    - ansible_builder

- name: Create empty build log file
  ansible.builtin.copy:
    dest: "{{ build_log }}"
    content: "Begin direct build for {{ item.item }} at {{ lookup('pipe', 'date') }}\n"
    mode: '0644'
  loop: "{{ env_exists.results }}"
  when: item.stat.exists and item.stat.isdir
  loop_control:
    label: "{{ item.item }}"
  tags:
    - build
    - images
    - ansible_builder

# First, add this task to wait for the async builds to complete
- name: Wait for builds to complete
  ansible.builtin.async_status:
    jid: "{{ item.ansible_job_id }}"
  register: build_commands
  until: build_commands.finished
  retries: 36  # Retry for up to an hour (36 * 100s = 3600s = 1h)
  delay: 100  # Check every 100 seconds
  loop: "{{ build_jobs.results | selectattr('ansible_job_id', 'defined') | list }}"
  loop_control:
    label: "{{ item.item }}"
  when: build_jobs is defined and build_jobs.results is defined
  tags:
    - build
    - images
    - async_status

# Then fix your append task
- name: Append build output to log files
  ansible.builtin.copy:
    dest: "/tmp/ee-containers/environments/{{ item.item.item }}/build-direct-{{ timestamp }}.log"
    content: "{{ item.stdout | default('') }}\n{{ item.stderr | default('') }}\n"
    mode: '0644'
    backup: no
  loop: "{{ build_commands.results }}"
  when: not item.skipped | default(false)  # Proper way to check if skipped
  loop_control:
    label: "{{ item.item.item }}"
  tags:
    - build
    - images
    - ansible_builder

- name: Verify image existence
  ansible.builtin.command:
    cmd: "podman images --format '{% raw %}{{.Repository}}:{{.Tag}}{% endraw %}'"
  register: image_list
  changed_when: false
  tags:
    - build
    - verification
    - images

- name: Set build results with verification
  ansible.builtin.set_fact:
    build_results:
      results: >-
        {% for result in build_commands.results %}
        {% set build_rc = result.rc|default(1) %}
        {% set image_name = result.item.item + ":" + timestamp %}
        {% set image_exists = image_name in image_list.stdout_lines %}
        [
          {
            "item": {"item": "{{ result.item.item }}"},
            "rc": {{ build_rc }},
            "skipped": {{ result.skipped|default(false) }},
            "verified": {{ image_exists }}
          }
        ]{% if not loop.last %},{% endif %}
        {% endfor %}
  tags:
    - build
    - verification
    - images

# First, create a new file for the debug tasks
- name: Create debug task file
  ansible.builtin.copy:
    dest: "{{ playbook_dir }}/roles/ee-builder/tasks/debug_build.yml"
    content: |
      ---
      - name: Debug header
        ansible.builtin.debug:
          msg: "=== BUILD FAILURE DEBUGGING FOR {{ failed_build.item.item }} ==="

      # 1. Check file permissions
      - name: Check file permissions
        ansible.builtin.command:
          cmd: "ls -la"
          chdir: "{{ debug_env_path }}"
        register: file_permissions
        ignore_errors: true
        
      - name: Display file permissions
        ansible.builtin.debug:
          msg: "1. File permissions:\n{{ file_permissions.stdout }}"

      # Add all the rest of your debug tasks here...
    mode: '0644'

# Then replace your block with this include_tasks
- name: Debug build failures
  include_tasks: debug_build.yml
  vars:
    debug_env_path: "/tmp/ee-containers/environments/{{ item.item.item }}"
    failed_build: "{{ item }}"
  loop: "{{ build_results.results | selectattr('failed', 'defined') | selectattr('failed') | list }}"
  loop_control:
    label: "{{ item.item.item }}"
  when: build_results.results | selectattr('failed', 'defined') | selectattr('failed') | list | length > 0
  tags:
    - debug
    - build
    - troubleshooting

# Replace the shell-based verification with native Ansible tasks
- name: Get complete list of container images
  ansible.builtin.command:
    cmd: "podman images --format '{% raw %}{{.Repository}}:{{.Tag}}{% endraw %}'"
  register: all_podman_images
  changed_when: false
  tags:
    - reporting
    - verification
    - images

- name: Initialize verified and missing lists
  ansible.builtin.set_fact:
    verified_builds: []
    missing_builds: []
  tags:
    - reporting
    - verification
    - variables

- name: Check image existence for each environment
  ansible.builtin.set_fact:
    verified_builds: "{{ verified_builds + [item] }}"
  when: >
    'localhost/' + item + ':' + timestamp in all_podman_images.stdout_lines or
    item + ':' + timestamp in all_podman_images.stdout_lines
  loop: "{{ environments_to_build }}"
  tags:
    - reporting
    - verification
    - images

- name: Identify missing images
  ansible.builtin.set_fact:
    missing_builds: "{{ environments_to_build | difference(verified_builds) }}"
  tags:
    - reporting
    - verification
    - variables

- name: Display image verification results
  ansible.builtin.debug:
    msg: |
      === IMAGE VERIFICATION RESULTS ===
      Verified images ({{ verified_builds | length }}):
      {% for build in verified_builds %}
      - {{ build }}:{{ timestamp }}
      {% endfor %}
      
      Missing images ({{ missing_builds | length }}):
      {% for build in missing_builds %}
      - {{ build }}:{{ timestamp }}
      {% endfor %}
  tags:
    - reporting
    - verification
    - debug

####################################
# 11. REPORTING
####################################

- name: Initialize build_results if no builds ran
  ansible.builtin.set_fact:
    build_results: {"results": []}
  when: build_results is not defined or build_results.results | length == 0
  tags:
    - reporting
    - variables
    - initialize

- name: Count build successes and failures
  ansible.builtin.set_fact:
    successful_builds: "{{ build_results.results | default([]) | selectattr('rc', 'defined') | selectattr('rc', 'eq', 0) | list | length }}"
    failed_builds: "{{ build_results.results | default([]) | selectattr('rc', 'defined') | rejectattr('rc', 'eq', 0) | list | length }}"
    skipped_builds: "{{ build_results.results | default([]) | selectattr('skipped', 'defined') | list | length }}"
    total_environments: "{{ environments_to_build | length }}"
  tags:
    - reporting
    - variables
    - summary

- name: Show build summary
  ansible.builtin.debug:
    msg: |
      
      ********************************************************************
      *                     BUILD SUMMARY REPORT                         *
      ********************************************************************
      
      Total environments selected: {{ total_environments }}
      Successfully built: {{ successful_builds }}
      Failed builds: {{ failed_builds }}
      Skipped builds: {{ skipped_builds }}
      
      DETAILED RESULTS:
      {% for result in build_results.results %}
      {% if result.skipped is defined %}
      - SKIPPED: {{ result.item.item }} - Missing execution-environment.yml
      {% elif result.rc is defined and result.rc == 0 %}
      - SUCCESS: {{ result.item.item }} - Image tag: {{ result.item.item }}:{{ timestamp }}
      {% elif result.rc is defined %}
      - FAILED: {{ result.item.item }} - Error code: {{ result.rc }}
      {% endif %}
      {% endfor %}
      
      {% if successful_builds != 0 %}
      Successfully built containers are available with 'podman images'
      {% endif %}
  tags:
    - reporting
    - summary
    - debug
    - always

- name: Show build summary with verified images
  ansible.builtin.debug:
    msg: |
      
      ********************************************************************
      *                     BUILD SUMMARY REPORT                         *
      ********************************************************************
      
      Total environments selected: {{ total_environments }}
      Successfully built: {{ verified_builds | length }}
      Failed builds: {{ failed_builds + missing_builds | length }}
      Skipped builds: {{ skipped_builds }}
      
      DETAILED RESULTS:
      {% for result in build_results.results %}
      {% if result.skipped is defined %}
      - SKIPPED: {{ result.item.item }} - Missing execution-environment.yml
      {% elif result.item.item in verified_builds %}
      - SUCCESS: {{ result.item.item }} - Image tag: {{ result.item.item }}:{{ timestamp }} ✅ VERIFIED
      {% elif result.rc is defined and result.rc == 0 and result.item.item in missing_builds %}
      - PHANTOM SUCCESS: {{ result.item.item }} - Build reported success but image doesn't exist ❌
      {% else %}
      - FAILED: {{ result.item.item }} - Error code: {{ result.rc }}
      {% endif %}
      {% endfor %}
      
      {% if verified_builds | length > 0 %}
      Successfully built containers: {{ verified_builds | join(", ") }}
      Check them with: podman images
      {% endif %}
      
      {% if missing_builds | length > 0 %}
      WARNING: {{ missing_builds | length }} builds reported success but images weren't found!
      Missing images: {{ missing_builds | join(", ") }}
  tags:
    - reporting
    - summary
    - debug
    - always

####################################
# 12. CLEANUP AND FINALIZATION
####################################

- name: Remove all dangling images
  ansible.builtin.shell: |
    podman image ls -a | grep '<none>' | awk '{print $3}' | xargs -r podman rmi -f || true
  ignore_errors: true
  tags:
    - cleanup
    - podman
    - images

####################################
# CENTRALIZED SCRIPT MANAGEMENT
####################################

- name: Ensure scripts directory exists
  ansible.builtin.file:
    path: "{{ playbook_dir }}/scripts"
    state: directory
    mode: "0755"
  tags:
    - scripts
    - setup

- name: Create all required scripts in central location
  ansible.builtin.copy:
    dest: "{{ playbook_dir }}/scripts/{{ item.name }}"
    content: "{{ item.content }}"
    mode: "{{ item.mode | default('0755') }}"
  loop:
    - name: smart-tmux-monitor.sh
      content: |
        #!/bin/bash
        
        # Terminal colors and styling
        BOLD="\033[1m"
        GREEN="\033[32m"
        YELLOW="\033[33m"
        BLUE="\033[34m"
        MAGENTA="\033[35m"
        CYAN="\033[36m"
        RESET="\033[0m"
        
        # Session name
        SESSION="ansible-builder"
        
        # Kill any existing session
        tmux kill-session -t $SESSION 2>/dev/null || true
        
        # Create new tmux session
        tmux new-session -d -s $SESSION -n "EE Builder"
        
        # Create layout: 3 panes stacked vertically
        tmux split-window -v -p 70 -t $SESSION:0
        tmux split-window -v -p 50 -t $SESSION:0
        
        # Top pane: Title with fancy formatting
        tmux send-keys -t $SESSION:0.0 "clear && echo -e '${BLUE}${BOLD}╔═══════════════════════════════════════╗${RESET}'" C-m
        tmux send-keys -t $SESSION:0.0 "echo -e '${BLUE}${BOLD}║  ANSIBLE EXECUTION ENVIRONMENT BUILDER  ║${RESET}'" C-m
        tmux send-keys -t $SESSION:0.0 "echo -e '${BLUE}${BOLD}╚═══════════════════════════════════════╝${RESET}'" C-m
        
        # Middle pane: Show build progress with spinner
        tmux send-keys -t $SESSION:0.1 "clear && echo -e '${CYAN}${BOLD}Building:${RESET} {{ environments_to_build | join(', ') }}'" C-m
        tmux send-keys -t $SESSION:0.1 "echo" C-m
        tmux send-keys -t $SESSION:0.1 "function show_spinner() {" C-m
        tmux send-keys -t $SESSION:0.1 "  local spinstr='⣾⣽⣻⢿⡿⣟⣯⣷'" C-m
        tmux send-keys -t $SESSION:0.1 "  while true; do" C-m
        tmux send-keys -t $SESSION:0.1 "    for i in \$(seq 0 7); do" C-m
        tmux send-keys -t $SESSION:0.1 "      printf \"\\r${YELLOW}${BOLD}⏳ Building...${RESET} \${spinstr:\$i:1}\"" C-m
        tmux send-keys -t $SESSION:0.1 "      sleep 0.1" C-m
        tmux send-keys -t $SESSION:0.1 "      if ! pgrep -f ansible-builder >/dev/null; then" C-m
        tmux send-keys -t $SESSION:0.1 "        printf \"\\r${GREEN}${BOLD}✅ Build completed!${RESET}           \\n\"" C-m
        tmux send-keys -t $SESSION:0.1 "        return" C-m
        tmux send-keys -t $SESSION:0.1 "      fi" C-m
        tmux send-keys -t $SESSION:0.1 "    done" C-m
        tmux send-keys -t $SESSION:0.1 "  done" C-m
        tmux send-keys -t $SESSION:0.1 "}" C-m
        tmux send-keys -t $SESSION:0.1 "(pgrep -f ansible-builder && show_spinner) || echo -e '${MAGENTA}Waiting for build to start...${RESET}'" C-m
        
        # Bottom pane: Watch podman images refreshing quickly
        tmux send-keys -t $SESSION:0.2 "watch -n 0.5 'podman images | grep timestamp_placeholder || echo \"No images built yet\"'" C-m
        
        echo -e "${BLUE}${BOLD}=====================================================================${RESET}"
        echo -e "${GREEN}${BOLD}TMux monitoring session started${RESET}"
        echo -e "${BLUE}${BOLD}=====================================================================${RESET}"
        echo -e ""
        echo -e "Connect to the monitoring session with:"
        echo -e "${CYAN}${BOLD}tmux attach -t $SESSION${RESET}"
        echo -e ""
        echo -e "The monitor shows:"
        echo -e "  - ${YELLOW}Top pane:${RESET} Title banner"
        echo -e "  - ${YELLOW}Middle pane:${RESET} Build progress with animated spinner"
        echo -e "  - ${YELLOW}Bottom pane:${RESET} Real-time image listing (refreshes every 0.5s)"
        echo -e ""
        echo -e "To detach from the session: Press ${CYAN}Ctrl+B${RESET} then ${CYAN}D${RESET}"
        echo -e "${BLUE}${BOLD}=====================================================================${RESET}"

    - name: deduplicate_collections.py
      mode: '0755'
      content: |
        #!/usr/bin/env python3
        import yaml, os, sys

        file_path = sys.argv[1]
        try:
            with open(file_path) as f:
                data = yaml.safe_load(f) or {}
            
            if "collections" in data:
                seen_collections = {}
                deduped_collections = []
                
                for coll in data["collections"]:
                    if isinstance(coll, dict) and "name" in coll:
                        name = coll["name"]
                        if name not in seen_collections or "version" in coll:
                            seen_collections[name] = coll
                            deduped_collections.append(coll)
                    elif isinstance(coll, str):
                        if coll not in seen_collections:
                            seen_collections[coll] = coll
                            deduped_collections.append(coll)
                
                data["collections"] = deduped_collections
            
            with open(file_path, "w") as f:
                yaml.dump(data, f, default_flow_style=False)
        except Exception as e:
            print(f"Error processing {file_path}: {e}")
            sys.exit(1)

    - name: custom-assemble.sh
      content: |
        #!/bin/bash
        
        # Custom assemble script for Ansible EE
        echo "Running custom assemble script..."
        
        # Create the output directory structure
        mkdir -p /output/scripts/
        
        # Copy the assemble script from bind-mount to output
        if [ -f /build/scripts/assemble ]; then
          cp /build/scripts/assemble /output/scripts/
          chmod +x /output/scripts/assemble
        fi
        
        # Create helper scripts
        cat > /output/scripts/pip_install << 'EOF'
        #!/bin/bash
        pip3 install --no-cache-dir "$@"
        EOF
        chmod +x /output/scripts/pip_install
        
        # Copy entrypoint if it exists
        if [ -f /build/scripts/entrypoint ]; then
          cp /build/scripts/entrypoint /output/scripts/
          chmod +x /output/scripts/entrypoint
        fi
        
        echo "Custom assemble script completed successfully"
        exit 0

    - name: pre-build
      content: |
        #!/bin/bash
        
        # Pre-build hook for Ansible EE
        echo "Running pre-build hook..."
        
        # Ensure the container's package cache is up to date
        if command -v microdnf &> /dev/null; then
          microdnf clean all
          microdnf update -y
        elif command -v dnf &> /dev/null; then  
          dnf clean all
          dnf update -y
        fi
        
        # Create any required directories
        mkdir -p /etc/ansible
        
        # Set appropriate permissions
        chmod -R a+rwx /etc/ansible
        
        echo "Pre-build hook completed successfully"
        exit 0

    - name: build-monitor.sh
      content: |
        #!/bin/bash
        
        # Build monitoring script
        TIMESTAMP=$1
        LOG_FILE="/tmp/ee-containers/build_monitor.log"
        STATUS_FILE="/tmp/ee-containers/build_status.txt"
        
        echo "Starting build monitor for timestamp: $TIMESTAMP" > $LOG_FILE
        
        while true; do
          echo "$(date) - Checking build status..." >> $LOG_FILE
          podman ps -a >> $LOG_FILE
          echo "Current images:" >> $LOG_FILE
          podman images | grep $TIMESTAMP >> $LOG_FILE 2>&1
          
          # Update the status file
          echo "Build Status Monitor" > $STATUS_FILE
          echo "===================" >> $STATUS_FILE
          echo "Updated: $(date)" >> $STATUS_FILE
          echo "" >> $STATUS_FILE
          echo "ACTIVE BUILDS:" >> $STATUS_FILE
          podman ps | grep -v CONTAINER >> $STATUS_FILE || echo "No active builds" >> $STATUS_FILE
          echo "" >> $STATUS_FILE
          echo "COMPLETED IMAGES:" >> $STATUS_FILE
          podman images | grep $TIMESTAMP >> $STATUS_FILE || echo "No completed images yet" >> $STATUS_FILE
          
          # Sleep between checks
          sleep 30
        done
  tags:
    - scripts
    - setup
    - templates
