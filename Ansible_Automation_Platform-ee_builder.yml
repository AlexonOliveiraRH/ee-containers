---
# Ansible Automation Platform - Execution Environment Builder
# This playbook builds customized execution environments based on Red Hat AAP base images

# Play 1: Verify or collect credentials
- name: Setup and store credentials
  hosts: localhost
  connection: local
  gather_facts: true
  tasks:
    # Clear screen as the very first action
    - name: Clear screen at playbook start
      ansible.builtin.shell: reset
      changed_when: false
      tags: [always]
      
    # Create static ansible.cfg before any template processing
    - name: Create static ansible.cfg file for initial setup
      ansible.builtin.copy:
        dest: "{{ playbook_dir }}/ansible.cfg"
        mode: '0644'
        force: false  # Don't overwrite if exists
        content: |
          [defaults]
          inventory = localhost,
          ansible_localhost_warning=false
          ansible_deprecation_warnings=false
          force_color = True

          [galaxy]
          server_list = validated, published, galaxy

          [galaxy_server.published]
          url=https://console.redhat.com/api/automation-hub/content/published/
          auth_url=https://sso.redhat.com/auth/realms/redhat-external/protocol/openid-connect/token

          [galaxy_server.validated]
          url=https://console.redhat.com/api/automation-hub/content/validated/
          auth_url=https://sso.redhat.com/auth/realms/redhat-external/protocol/openid-connect/token

          [galaxy_server.galaxy]
          url=https://galaxy.ansible.com/
      tags: [always]

    - name: Create collections requirements file
      ansible.builtin.copy:
        dest: "/tmp/requirements.yml"
        mode: '0644'
        content: |
          ---
          collections:
            - name: ansible.utils
            - name: ansible.posix
            - name: community.general
            - name: infra.aap_configuration
            - name: infra.aap_utilities
            - name: infra.ah_configuration
            - name: infra.ansible
            - name: infra.ansible_collections
            - name: infra.ansible_rekey_variables
            - name: infra.eda_configuration
            - name: infra.ee_ansible_collections
            - name: infra.ee_collections
            - name: infra.ee_configuration
            - name: infra.ee_rekey_variables
            - name: infra.ee_utilities
            - name: infra.osbuild
      tags: [setup, always, collections]

    - name: Create requirements.txt file
      ansible.builtin.copy:
        dest: "/tmp/requirements.txt"
        mode: '0644'
        content: |
          ansible-builder>=3.0.0
          ansible-core>=2.15.0,<2.16
          ansible-creator>=1.0.0
          ansible-lint>=24.0.0
          ansible-navigator>=3.0.0
          ansible-runner>=2.3.1
          ansible-sign>=0.1.0
      tags: [setup, always, collections]

    - name: Create inventory file
      ansible.builtin.copy:
        dest: "/tmp/inventory"
        mode: '0644'
        content: |
          [devnode]
          localhost ansible_connection=localhost
      tags: [always, setup]
     
    - name: Force install community.general collection system-wide
      ansible.builtin.command:
        cmd: "sudo ansible-galaxy collection install community.general ansible.posix -p /usr/share/ansible/collections --force"
      register: galaxy_install
      changed_when: galaxy_install.rc == 0
      failed_when: galaxy_install.rc != 0

    - name: Verify community.general collection installation
      ansible.builtin.command:
        cmd: "ansible-galaxy collection list community.general"
      register: collection_verify
      failed_when: collection_verify.rc != 0

    - name: Show installation path
      ansible.builtin.debug:
        msg: "Collection installed at: {{ collection_verify.stdout_lines | select('search', 'Path:') | first | default('Unknown location') }}"

    # Improved user detection logic
    - name: Get effective and real user info
      ansible.builtin.shell: |
        echo "EUID=$(id -u)"
        if [ -n "$SUDO_USER" ]; then
          echo "SUDO_USER=$SUDO_USER"
          echo "SUDO_UID=$(id -u $SUDO_USER)"
          echo "SUDO_HOME=$(eval echo ~$SUDO_USER)"
        else
          echo "SUDO_USER="
          echo "SUDO_UID="
          echo "SUDO_HOME="
        fi
        echo "USER=$(whoami)"
        echo "HOME=$HOME"
      register: user_info_output
      changed_when: false
      tags: [always]
    
    - name: Parse user info
      ansible.builtin.set_fact:
        parsed_user_info: "{{ dict(user_info_output.stdout_lines | map('regex_replace', '^([^=]+)=(.*)$', '\\1:\\2') | map('split', ':') | list) }}"
      tags: [always]
    
    - name: Set user facts
      ansible.builtin.set_fact:
        is_root: "{{ ansible_user_id == '0' }}"
        actual_user: "{{ ansible_user_id }}"
        user_home: "{{ ansible_env.HOME }}"
      tags: [always]
    
    - name: Debug user detection
      ansible.builtin.debug:
        msg: |
          User detection results:
          - Effective UID: {{ parsed_user_info.EUID }}
          - Running as root: {{ is_root }}
          - Original user: {{ actual_user }}
          - User home: {{ user_home }}
      tags: [always]

    # Skip credential setup if running as root directly (not via sudo)
    - name: Skip credential setup if running as root directly
      ansible.builtin.set_fact:
        skip_credential_setup: "{{ ansible_user_id == 'root' and lookup('env', 'SUDO_USER') == '' }}"
      tags: [always]

    - name: Show credential setup status
      ansible.builtin.debug:
        msg: "{{ skip_credential_setup | ternary('Running as direct root user - skipping credential setup', 'Setting up credentials for user ' + actual_user) }}"
      tags: [always]

    # Only run credential setup if not skipping
    - name: Setup user credentials
      when: not skip_credential_setup
      block:
        - name: Ensure ansible vars directory exists in user's home
          ansible.builtin.file:
            path: "{{ user_home }}/.ansible/vars"
            state: directory
            mode: '0700'
          tags: [setup, credential_setup]
    
        - name: Check if credentials file exists
          ansible.builtin.stat:
            path: "{{ user_home }}/.ansible/vars/config"
          register: config_file
          tags: [always]
    
        - name: Set first run flag 
          ansible.builtin.set_fact:
            first_run: "{{ not config_file.stat.exists }}"
          tags: [always]
    
        - name: Load stored credentials if they exist
          ansible.builtin.include_vars:
            file: "{{ user_home }}/.ansible/vars/config"
            name: stored_credentials
          when: config_file.stat.exists
          tags: [always]
    
        - name: Request credentials if needed
          block:
            - name: Collect Red Hat CDN username
              ansible.builtin.pause:
                prompt: "Enter your Red Hat CDN username"
                echo: true
              register: rh_username_input
              when: stored_credentials is not defined or stored_credentials.rh_username is not defined
              
            - name: Collect Red Hat CDN password
              ansible.builtin.pause:
                prompt: "Enter your Red Hat CDN password"
                echo: false
              register: rh_password_input
              when: stored_credentials is not defined or stored_credentials.rh_password is not defined
              
            - name: Collect Automation Hub token
              ansible.builtin.pause:
                prompt: "Enter your Automation Hub token (or press enter to skip)"
                echo: false
              register: automation_hub_token_input
              when: stored_credentials is not defined or stored_credentials.automation_hub_token is not defined
              
            - name: Collect Galaxy token
              ansible.builtin.pause:
                prompt: "Enter your Galaxy token (or press enter to skip)"
                echo: false
              register: galaxy_token_input
              when: stored_credentials is not defined or stored_credentials.galaxy_token is not defined
              
            - name: Set collected credential facts
              ansible.builtin.set_fact:
                rh_username: "{{ rh_username_input.user_input | default(stored_credentials.rh_username | default('')) }}"
                rh_password: "{{ rh_password_input.user_input | default(stored_credentials.rh_password | default('')) }}"
                automation_hub_token: "{{ automation_hub_token_input.user_input | default(stored_credentials.automation_hub_token | default('')) }}"
                galaxy_token: "{{ galaxy_token_input.user_input | default(stored_credentials.galaxy_token | default('')) }}"
              no_log: true
              
            - name: Create credentials file
              ansible.builtin.copy:
                dest: "{{ user_home }}/.ansible/vars/config"
                content: |
                  ---
                  # Ansible EE Builder Configuration - Last updated {{ ansible_date_time.iso8601 }}
                  rh_username: '{{ rh_username }}'
                  rh_password: '{{ rh_password }}'
                  automation_hub_token: '{{ automation_hub_token }}'
                  galaxy_token: '{{ galaxy_token }}'
                mode: '0600'
                # Remove owner and group attributes when running as root
              no_log: true
              
            - name: Set proper ownership on credentials file when needed
              ansible.builtin.file:
                path: "{{ user_home }}/.ansible/vars/config"
                owner: "{{ actual_user }}"
                group: "{{ actual_user }}"
                mode: '0600'
              when: actual_user != 'root' and actual_user != ''
              no_log: true
              
            - name: Report stored credentials
              ansible.builtin.debug:
                msg: |
                  ┌────────────────────────────────────────────────────────────────┐
                  │                  CREDENTIALS STORED                            │
                  ├────────────────────────────────────────────────────────────────┤
                  │ Credentials have been stored at: {{ user_home }}/.ansible/vars/config │
                  │ These will be used for future runs.                            │
                  └────────────────────────────────────────────────────────────────┘
          when: first_run or (stored_credentials is not defined)
          tags: [always]

    - name: Show run mode
      ansible.builtin.debug:
        msg: |
          ┌────────────────────────────────────────────────────────────────────┐
          │                     RUN MODE INFORMATION                           │
          ├────────────────────────────────────────────────────────────────────┤
          │ {{ "FIRST RUN DETECTED: Running full setup" if first_run | default(false) else "SUBSEQUENT RUN: Using stored configuration" }} │
          │                                                                    │
          │ User: {{ actual_user | default('Unknown') }}                                            │
          │ Credentials: {{ "New" if first_run | default(false) else "Loaded from file" }}      │
          └────────────────────────────────────────────────────────────────────┘
      tags: [always]

    # Use sudo_user's home directory for config in the main play
    - name: Set config path for main play
      ansible.builtin.set_fact:
        config_path: "{{ user_home }}/.ansible/vars/config"
      tags: [always]

# Play 2: Display title and introduction
- name: Display title screen
  hosts: localhost
  connection: local
  gather_facts: false
  environment:
    ANSIBLE_LOCALHOST_WARNING: "False" 
    ANSIBLE_DEPRECATION_WARNINGS: "False"
    ANSIBLE_COMMAND_WARNINGS: "False"
    ANSIBLE_SYSTEM_WARNINGS: "False"
  tasks:
    - name: Clear screen before showing title
      ansible.builtin.shell: clear
      changed_when: false
      
    - name: Show ascii title
      ansible.builtin.debug:
        msg: |
          ┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
          │                                                                                      ..:-=@@@@=-:..          │
          │                                                                                    .*%@@@@@@@@@@@@%*.        │
          │                                                                                 .:@@@@@@@@@@@@@@@@@@@@:.     │
          │                                                                                .*@@@@@@@@@@*-@@@@@@@@@@*.    │
          │                                                                               .@@@@@@@@@@@*. =@@@@@@@@@@@.   │
          │                                                                              .%@@@@@@@@@@@ .@ +@@@@@@@@@@%.  │
          │                                                                              -%@@@@@@@@@@..@%-.*@@@@@@@@@%-  │
          │     "A Streamlined Approach to Building Ansible Execution Environments"     .+@@@@@@@@@@= =@@@.:@@@@@@@@@@+. │
          │                                                                             .+@@@@@@@@@@ ..:+@%.-@@@@@@@@@+. │
          │                                                                             .=@@@@@@@@@ .@@+. *+.-@@@@@@@%=  │
          │                                                                              .%@@@@@@@:.*@@@@%.  .+@@@@@@%.  │
          │                                                                               .@@@@@@= =@@@@@@@%=.:%@@@@@.   │
          │                                                                                :%@@@@@@@@@@@@@@@@@@@@@@%:    │
          │                                                                                 .*@@@@@@@@@@@@@@@@@@@@*.     │
          │                                                                                   .+@@@@@@@@@@@@@@@@+..      │
          │                                                                                     ..+*%@@@@@@%*+..         │
          └──────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
      tags: [always]

    - name: Pause for title screen
      ansible.builtin.pause:
        seconds: 3
        prompt: "Starting Execution Environment Builder..."
      tags: [always]

# New Play: Install required collections
- name: Install Required Ansible Collections
  hosts: localhost
  become: true
  gather_facts: false
  tasks:
      
    - name: Install required collections system-wide
      ansible.builtin.command:
        cmd: "ansible-galaxy collection install community.general -p /usr/share/ansible/collections --force"
      register: galaxy_install
      failed_when: galaxy_install.rc != 0
    
    - name: Verify collection installation
      ansible.builtin.command:
        cmd: "ansible-galaxy collection list community.general"
      register: collection_verify
      failed_when: collection_verify.rc != 0
      
    - name: Show installation path
      ansible.builtin.debug:
        msg: "Collection installed at: {{ collection_verify.stdout_lines | select('search', 'Path:') | first | default('Unknown location') }}"

    - name: Check if required collections are installed
      ansible.builtin.command:
        cmd: "ansible-galaxy collection list -p /usr/share/ansible/collections"
      register: collection_check
      changed_when: false
      failed_when: false

    - name: Install required collections system-wide
      ansible.builtin.command:
        cmd: "ansible-galaxy collection install -r /tmp/requirements.yml -p /usr/share/ansible/collections"
      register: galaxy_install
      changed_when: galaxy_install.rc == 0
      failed_when: galaxy_install.rc != 0
      when: collection_check.rc != 0 or (force_collection_reinstall | default(false)) | bool

    - name: Check if required collections are installed
      ansible.builtin.fail:
        msg: "Required collections not installed. Run: sudo ansible-galaxy collection install community.general ansible.posix -p /usr/share/ansible/collections"
      when: lookup('ansible.builtin.first_found', '/usr/share/ansible/collections/ansible_collections/community/general', errors='ignore') == ""

# Play 3: Main execution environment building process
- name: Build Execution Environments for Ansible Automation Platform
  hosts: localhost
  become: true
  gather_facts: true
  vars_files:
    - "{{ hostvars.localhost.config_path | default('~/.ansible/vars/config') }}"

  # Variables definition section remains the same
  vars:
    # Connection variables
    container_registries:
      - registry.redhat.io
      - console.redhat.com
      - registry.access.redhat.com
      - quay.io
      - registry.connect.redhat.com
    dns_servers:
      - '8.8.8.8'
      - '8.8.4.4'
    
    # Package and dependency variables
    required_packages:
      - python3-pip
      - ansible-builder
      - ansible-core
      - git
      - podman
      - podman-docker
      - tmux
      - xdg-utils
      - yum-utils
    
    # Always update the protected_images list in defaults/main.yml
    update_protected_list: true
    
    # Repository variables  
    git_repos:
      - url: 'https://github.com/cloin/ee-builds.git'
        dest: 'examples/ee-builds'
    work_dir: '/tmp/ee-containers'
    
    # Container image variables
    required_images:
      - registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel8
      - registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel9
      - registry.redhat.io/ansible-automation-platform-25/de-supported-rhel8
      - registry.redhat.io/ansible-automation-platform-25/de-supported-rhel9
      - registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel8
      - registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel9
      - registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel8
      - registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel9

  # Interactive variables - now using defaults from config file
  vars_prompt:
    - name: distribution_selection
      prompt: "Select distribution to build images for (8/9/both)"
      private: false
      default: "both"

  pre_tasks:
    - name: Check root status
      ansible.builtin.command: id -u
      register: user_id
      changed_when: false

    - name: Set root flag
      ansible.builtin.set_fact:
        is_root: "{{ user_id.stdout == '0' }}"
      tags: [always]

    - name: Debug is_root variable
      ansible.builtin.debug:
        msg: "is_root is set to: {{ is_root }}"

    - name: Warning if running as non-root
      ansible.builtin.debug:
        msg: |
          Running in LIMITED MODE as non-root user.
          Only setup tasks will be executed.
          For full functionality, run with sudo.
      when: not is_root
      tags: [always]

    # Rest of the tasks with proper conditional checks
    - name: Set Podman warning suppression environment variable
      ansible.builtin.set_fact:
        podman_env:
          PODMAN_IGNORE_CGROUPSV1_WARNING: "1"
      tags: [setup, env_config, podman_warnings]
      
    - name: Check if Podman warning suppression is already in environment files
      ansible.builtin.shell: |
        grep -q "PODMAN_IGNORE_CGROUPSV1_WARNING=1" ~/.bashrc || 
        grep -q "PODMAN_IGNORE_CGROUPSV1_WARNING=1" /etc/profile || 
        grep -q "PODMAN_IGNORE_CGROUPSV1_WARNING=1" /etc/environment || 
        grep -q "PODMAN_IGNORE_CGROUPSV1_WARNING=1" /etc/profile.d/podman.sh
      register: podman_warning_check
      changed_when: false
      failed_when: false
      tags: [setup, env_config, podman_warnings]
      
    - name: Add Podman warning suppression to environment files
      ansible.builtin.lineinfile:
        path: "{{ item }}"
        regexp: '^export PODMAN_IGNORE_CGROUPSV1_WARNING='
        line: 'export PODMAN_IGNORE_CGROUPSV1_WARNING=1'
        create: true
        mode: '0644'
      with_items:
        - /etc/environment
        - /etc/profile.d/podman.sh
      when: is_root and podman_warning_check.rc != 0
      tags: [setup, env_config, podman_env_files]
      
    - name: Create systemd environment override for podman
      ansible.builtin.copy:
        content: |
          [Service]
          Environment=PODMAN_IGNORE_CGROUPSV1_WARNING=1
        dest: /etc/systemd/system/podman.service.d/environment.conf
        mode: '0644'
        create: true
      when: is_root
      
    - name: Reload systemd configuration
      ansible.builtin.systemd:
        daemon_reload: true
      when: is_root

    - name: Initialize protected_images variable
      ansible.builtin.set_fact:
        protected_images: "{{ protected_images | default([]) }}"
      tags: [setup, images, protect_images]

    - name: Ensure protected_images list is unique and sorted
      ansible.builtin.set_fact:
        protected_images: "{{ protected_images | unique | sort }}"
      tags: [setup, images, protect_images]
    
    #
    # SECTION 1: Distribution Selection
    #
    - name: Process distribution selection
      ansible.builtin.set_fact:
        build_rhel8: "{{ distribution_selection == '8' or distribution_selection == 'both' }}"
        build_rhel9: "{{ distribution_selection == '9' or distribution_selection == 'both' }}"
      tags: [setup, distribution, dist_selection]
        
    - name: Show selected distributions
      ansible.builtin.debug:
        msg: "Building images for: {{ (build_rhel8 | bool) | ternary('RHEL 8', '') }}{{ (build_rhel8 and build_rhel9) | ternary(' and ', '') }}{{ (build_rhel9 | bool) | ternary('RHEL 9', '') }}"
      tags: [setup, distribution, dist_show_selected]
    
    - name: Filter required images based on distribution selection
      ansible.builtin.set_fact:
        filtered_images: >-
          {{
            (build_rhel8 | bool) | ternary(required_images | select('search', 'rhel8') | list, []) +
            (build_rhel9 | bool) | ternary(required_images | select('search', 'rhel9') | list, [])
          }}

    - name: Show filtered image list
      ansible.builtin.debug:
        msg: |
          Images selected for download:
          {% for image in filtered_images %}
          - {{ image }}
          {% endfor %}
      when: filtered_images | length > 0
        
    - name: Update required_images with filtered list
      ansible.builtin.set_fact:
        required_images: "{{ filtered_images }}"
      when: filtered_images is defined and filtered_images | length > 0

    - name: Update protected images with distribution-specific images
      block:
        - name: Add required RHEL8 images to protected list
          ansible.builtin.set_fact:
            protected_images: >-
              {{ 
                (protected_images | default([])) + 
                (required_images | select('search', 'rhel8') | list)
              }}
          when: build_rhel8 | bool
          
        - name: Add required RHEL9 images to protected list
          ansible.builtin.set_fact:
            protected_images: >-
              {{ 
                (protected_images | default([])) + 
                (required_images | select('search', 'rhel9') | list)
              }}
          when: build_rhel9 | bool
          
        - name: Ensure protected_images list is unique and sorted
          ansible.builtin.set_fact:
            protected_images: "{{ protected_images | unique | sort }}"
            
        - name: Update protected_images.yml after distribution selection
          ansible.builtin.template:
            src: templates/protected_images.j2
            dest: "{{ playbook_dir }}/tasks/protected_images.yml"
            mode: '0644'
          vars:
            consolidated_images: "{{ protected_images }}"
      tags: [setup, distribution, image_protection]

    #
    # SECTION 2: Base System Configuration
    #
    - name: Detect RHEL version
      ansible.builtin.set_fact:
        rhel_version: "{{ ansible_distribution_major_version | default('9') }}"
      tags: [setup, system_config, detect_rhel]
      
    - name: Enable required RHEL repositories based on version
      block:
        - name: Define repository lists by RHEL version
          ansible.builtin.set_fact:
            rhel8_repos: >
              [
                "rhel-8-for-x86_64-baseos-rpms",
                "rhel-8-for-x86_64-appstream-rpms",
                "ansible-automation-platform-2.4-for-rhel-8-x86_64-rpms",
                "rhel-8-for-x86_64-supplementary-rpms",
                "codeready-builder-for-rhel-8-x86_64-rpms"
              ]
            rhel9_repos: >
              [
                "rhel-9-for-x86_64-baseos-rpms",
                "rhel-9-for-x86_64-appstream-rpms",
                "ansible-automation-platform-2.4-for-rhel-9-x86_64-rpms",
                "rhel-9-for-x86_64-supplementary-rpms",
                "codeready-builder-for-rhel-9-x86_64-rpms"
              ]

        - name: Select appropriate repositories based on detected RHEL version
          ansible.builtin.set_fact:
            repos_to_enable: "{{ (rhel_version == '8') | ternary(rhel8_repos, rhel9_repos) }}"
        
        - name: Check enabled status of defined repositories
          ansible.builtin.shell: |
            if command -v subscription-manager >/dev/null 2>&1; then
              subscription-manager repos --list-enabled | grep "Repo ID" | awk '{print $3}'
            fi
          register: enabled_repos
          changed_when: false
          ignore_errors: true
          args:
            executable: /bin/bash
            
        - name: Report status of required repositories
          ansible.builtin.debug:
            msg: |
              Status of required repositories:
              {% set enabled_repos_list = enabled_repos.stdout_lines | default([]) %}
              {% for repo in repos_to_enable %}
              - {{ repo }}: {{ "ENABLED" if repo in enabled_repos_list else "NOT ENABLED" }}
              {% endfor %}
          when: enabled_repos.stdout_lines | default([]) | length > 0

        - name: Create list of repositories that need enabling
          ansible.builtin.set_fact:
            repos_to_enable_now: "{{ repos_to_enable | difference(enabled_repos.stdout_lines | default([])) }}"

        - name: Show repositories to be enabled
          ansible.builtin.debug:
            msg: "Will enable: {{ repos_to_enable_now }}"
          when: repos_to_enable_now | length > 0

        - name: Enable only repositories that are not already enabled
          community.general.rhsm_repository:
            name: "{{ item }}"
            state: enabled
          loop: "{{ repos_to_enable_now }}"
          register: repo_enable_result
          failed_when: false
          when: repos_to_enable_now | length > 0
      rescue:
        - name: Handle repository configuration failure
          ansible.builtin.debug:
            msg: "Warning: Unable to enable repositories. Continuing with available repositories."
      tags: [setup, system_config, repositories]

    #
    # SECTION 3: DNS and Network Setup
    #
    - name: Verify DNS resolution
      ansible.builtin.uri:
        url: "http://{{ item }}"
        method: HEAD
        status_code: -1
        timeout: 5
      loop:
        - github.com
        - cdn-ubi.redhat.com
        - galaxy.ansible.com
      register: dns_checks
      changed_when: false
      failed_when: false
      loop_control:
        label: "{{ item }}"

    - name: Set DNS servers for Podman
      ansible.builtin.template:
        src: templates/registries.conf.j2
        dest: /etc/containers/registries.conf
        mode: '0644'
        backup: true
      when: is_root
      tags: [setup, network_config, dns_servers]

    #
    # SECTION 4: Podman Configuration Reset
    #
    - name: Complete Podman storage system reset
      block:
        - name: Show critical error message
          ansible.builtin.debug:
            msg: |
              Performing complete system reset of Podman storage.
              This will delete all local container images and data!

        - name: Stop all Podman processes
          ansible.builtin.shell: |
            # Kill all running containers
            podman ps -qa | xargs -r podman kill
            podman ps -qa | xargs -r podman rm -f
            
            # Stop podman service
            systemctl stop podman.service podman.socket || true
            
            # Kill any remaining podman processes
            pkill -9 podman || true
          changed_when: true
          ignore_errors: true
          
        - name: Safely clean container configuration
          block:
            - name: Get list of all existing tagged images
              ansible.builtin.shell: |
                podman images --format '{{ .Repository }}:{{ .Tag }}' | grep -v "<none>:<none>"
              register: existing_images
              changed_when: false
              
            - name: Create protected images list
              ansible.builtin.set_fact:
                protected_images: "{{ existing_images.stdout_lines | default([]) }}"
              
            - name: Display protected images
              ansible.builtin.debug:
                msg: |
                  Protected images that will NOT be removed:
                  {% for image in protected_images %}
                  - {{ image }}
                  {% endfor %}
            
            - name: Remove dangling containers safely
              ansible.builtin.shell: |
                # Only remove containers that are not using protected images
                for container in $(podman ps -a --format '{{ .ID }}'); do
                  image=$(podman inspect --format '{{ .Config.Image }}' $container)
                  if echo "$image" | grep -q "<none>" || ! echo "{{ protected_images | join(' ') }}" | grep -q "$image"; then
                    echo "Removing container $container with image $image"
                    podman rm -f $container
                  fi
                done
              changed_when: true
              
            - name: Remove only dangling images
              ansible.builtin.shell: |
                # Remove only <none>:<none> images
                podman images --filter "dangling=true" --format '{{ .ID }}' | xargs -r podman rmi -f
              changed_when: true
              
            - name: Clean unused volumes and networks only
              ansible.builtin.shell: |
                podman volume prune -f
                podman network prune -f
              changed_when: true
              
            - name: Clean temporary files
              ansible.builtin.shell: |
                # Remove only temporary build files
                rm -rf /tmp/ansible-builder.*
                rm -rf /tmp/pip-*
              changed_when: true
              
            - name: Remove images that are not tagged as latest
              ansible.builtin.shell: |
                podman images --format '{{.ID}} {{.Tag}}' | 
                grep -v "latest" | awk '{print $1}' | xargs -r podman rmi
              changed_when: true
          ignore_errors: true
          
        - name: Create basic container configuration files
          ansible.builtin.shell: |
            mkdir -p /etc/containers/containers.conf.d
            mkdir -p /etc/containers/storage.conf.d
            
            # Create base storage configuration
            cat > /etc/containers/storage.conf << EOF
            [storage]
            driver = "overlay"
            runroot = "/run/containers/storage"
            graphroot = "/var/lib/containers/storage"
            
            [storage.options]
            additionalimagestores = []
            
            [storage.options.overlay]
            mountopt = "nodev,metacopy=on"
            mount_program = "/usr/bin/fuse-overlayfs"
            ignore_chown_errors = "false"
            EOF
            
            # Create minimal registries configuration
            cat > /etc/containers/registries.conf << EOF
            [registries.search]
            registries = ['docker.io', 'registry.fedoraproject.org', 'registry.access.redhat.com', 'quay.io']
            
            [registries.insecure]
            registries = []
            
            [registries.block]
            registries = []
            EOF
          changed_when: true
          ignore_errors: true
          
        - name: Create container directory structure
          ansible.builtin.file:
            path: "{{ item }}"
            state: directory
            mode: '0755'
            owner: root
            group: root
          loop:
            - /var/lib/containers/storage/overlay
            - /var/lib/containers/storage/overlay-layers
            - /var/lib/containers/storage/overlay-images
            - /var/lib/containers/storage/vfs
            - /var/lib/containers/storage/vfs-containers
            - /var/lib/containers/storage/vfs-images
            - /var/lib/containers/storage/vfs-layers
            - /run/containers/storage
          become: true
          
        - name: Export environment variables to disable warnings
          ansible.builtin.shell: |
            # Add to environment
            export PODMAN_IGNORE_CGROUPSV1_WARNING=1
            
            # Add to current shell and .bashrc
            echo 'export PODMAN_IGNORE_CGROUPSV1_WARNING=1' >> ~/.bashrc
            
            # Create systemd override for podman service
            mkdir -p /etc/systemd/system/podman.service.d/
            cat > /etc/systemd/system/podman.service.d/environment.conf << EOF
            [Service]
            Environment=PODMAN_IGNORE_CGROUPSV1_WARNING=1
            EOF
            
            # Reload systemd to pick up changes
            systemctl daemon-reload
            systemctl restart podman.socket podman.service || true
          changed_when: true
      when: is_root
    
    #
    # SECTION 5: Registry Authentication
    #
    - name: Setup Red Hat registry authentication
      block:
        - name: Verify podman is working properly
          ansible.builtin.command:
            cmd: "podman info --format 'Driver: {{ '{{' }} .Store.GraphDriverName {{ '}}' }}'"
          environment:
            PODMAN_IGNORE_CGROUPSV1_WARNING: "1"
          register: podman_check
          failed_when: podman_check.rc != 0
        
        - name: Initialize registry login tracking
          ansible.builtin.set_fact:
            registry_login_success: false
            registry_login_results: {}
        
        - name: Login to Podman registry
          ansible.builtin.command:
            cmd: "podman login -u {{ rh_username }} -p {{ rh_password }} {{ item }}"
          loop: "{{ container_registries }}"
          register: podman_login_results
          failed_when: podman_login_results.rc != 0
            
        - name: Process registry login results
          ansible.builtin.set_fact:
            registry_login_success: >-
              {{ registry_login_success or 
                 (item.item != 'quay.io' and item.rc == 0) }}
            registry_login_results: "{{ registry_login_results | combine({item.item: (item.rc == 0)}) }}"
          loop: "{{ podman_login_results.results }}"
          loop_control:
            label: "{{ item.item }}"
            
        - name: Display registry login status
          ansible.builtin.debug:
            msg: |
              Registry Authentication Results:
              {% for registry, success in registry_login_results.items() %}
              - {{ registry }}: {{ 'SUCCESS' if success else 'FAILED' }}
              {% endfor %}
              
        - name: Fail if authentication failed for all critical registries
          ansible.builtin.fail:
            msg: |
              CRITICAL ERROR: Failed to authenticate with any required container registries.
              Authentication to at least one Red Hat registry is required for this playbook to function.
              Please check your Red Hat credentials and network connectivity.
          when: not registry_login_success



    #
    # SECTION 6: Builder Configuration
    #
    - name: Configure ansible-builder
      block:
        - name: Check if ansible-builder is already installed
          ansible.builtin.shell: which ansible-builder || echo "not found"
          register: ansible_builder_check
          changed_when: false

        - name: Install ansible-builder via pip if not found
          ansible.builtin.pip:
            name: ansible-builder
            state: present
            extra_args: "--user"
          when: "'not found' in ansible_builder_check.stdout"
          
        - name: Ensure _build/configs directory exists
          ansible.builtin.file:
            path: "{{ playbook_dir }}/_build/configs"
            state: directory
            mode: '0755'
          tags: [setup, builder_config]

        - name: Create ansible.cfg in build context
          ansible.builtin.template:
            src: templates/ansible.cfg.j2
            dest: "{{ playbook_dir }}/_build/configs/ansible.cfg"
            mode: '0644'
          vars:
            automation_hub_token_value: "{{ automation_hub_token | default('') }}"
            current_user: "{{ ansible_user_id | default('root') }}"
          tags: [setup, builder_config, ansible_cfg]

        - name: Copy ansible.cfg to system locations
          block:
            - name: Create destination directory if needed
              ansible.builtin.file:
                path: "{{ playbook_dir }}"
                state: directory
                mode: '0755'
              
            - name: Touch ansible.cfg file to ensure it exists
              ansible.builtin.file:
                path: "{{ playbook_dir }}/ansible.cfg"
                state: touch
                mode: '0644'
                
            - name: Copy ansible.cfg to /etc/ansible
              ansible.builtin.template:
                src: templates/ansible.cfg.j2
                dest: "/etc/ansible/ansible.cfg"
                mode: '0644'
              vars:
                automation_hub_token_value: "{{ automation_hub_token | default('') }}"
                current_user: "{{ ansible_user_id | default('root') }}"

    - name: Ensure ansible.cfg exists in current directory
      block:
        - name: Check if ansible.cfg exists in current directory
          ansible.builtin.stat:
            path: "ansible.cfg"
          register: ansible_cfg_check
          
        - name: Create ansible.cfg from template if it doesn't exist
          ansible.builtin.template:
            src: templates/ansible.cfg.j2
            dest: "ansible.cfg"
            mode: '0644'
          when: not ansible_cfg_check.stat.exists
          vars:
            automation_hub_token: "{{ automation_hub_token | default('') }}"
            
        - name: Ensure ansible.cfg has correct permissions
          ansible.builtin.file:
            path: "ansible.cfg"
            mode: '0644'
            owner: "{{ actual_user | default(ansible_user_id) }}"
            group: "{{ actual_user | default(ansible_user_id) }}"
          when: actual_user is defined and actual_user != ""
          failed_when: false
      tags: [setup, ansible_config, config_files]

    - name: Update ansible.cfg with token information
      block:
        - name: Set token value for template
          ansible.builtin.set_fact:
            token_for_template: "{{ automation_hub_token | default('') }}"

        - name: Apply token to ansible.cfg from template
          ansible.builtin.template:
            src: templates/ansible.cfg.j2
            dest: "ansible.cfg"
            mode: '0644'
          vars:
            automation_hub_token_value: "{{ token_for_template }}"
            current_user: "{{ actual_user | default(ansible_user_id) }}"
            
        - name: Report ansible.cfg update
          ansible.builtin.debug:
            msg: "ansible.cfg has been updated with authentication tokens"
          when: automation_hub_token is defined and automation_hub_token != ""
      tags: [setup, ansible_config, config_files]

    - name: Update ansible.cfg with token information
      block:
        - name: Update ansible.cfg with token
          ansible.builtin.lineinfile:
            path: "ansible.cfg"
            regexp: '^token='
            insertafter: '^auth_url=https://sso.redhat.com/auth/realms/redhat-external/protocol/openid-connect/token'
            line: "token={{ automation_hub_token | default('') }}"
            state: present
          with_items:
            - validated
            - published
          ignore_errors: true
      when: automation_hub_token is defined and automation_hub_token != ""
      tags: [setup, ansible_config, config_files]

    - name: Save valid token to ansible.cfg
      ansible.builtin.template:
        src: templates/ansible.cfg.j2
        dest: "ansible.cfg"
        mode: '0644'
      vars:
        current_user: "{{ actual_user | default(ansible_user_id) }}"
        automation_hub_token_value: "{{ automation_hub_token | default('') }}"
      when: automation_hub_token is defined and automation_hub_token != ""
      tags: [setup, token_validation]

    - name: Fix Copy ansible.cfg to playbook directory
      block:
        - name: Create _build/configs directory if it doesn't exist
          ansible.builtin.file:
            path: "{{ playbook_dir }}/_build/configs"
            state: directory
            mode: '0755'
          
        - name: Create ansible.cfg in _build/configs directly
          ansible.builtin.template:
            src: templates/ansible.cfg.j2
            dest: "{{ playbook_dir }}/_build/configs/ansible.cfg"
            mode: '0644'
          vars:
            automation_hub_token_value: "{{ automation_hub_token | default('') }}"
            current_user: "{{ ansible_user_id | default('root') }}"
            
        - name: Create ansible.cfg in playbook directory directly
          ansible.builtin.template:
            src: templates/ansible.cfg.j2
            dest: "{{ playbook_dir }}/ansible.cfg"
            mode: '0644'
          vars:
            automation_hub_token_value: "{{ automation_hub_token | default('') }}"
            current_user: "{{ ansible_user_id | default('root') }}"
            
        - name: Create ansible.cfg in /etc/ansible directory
          ansible.builtin.template:
            src: templates/ansible.cfg.j2
            dest: "/etc/ansible/ansible.cfg"
            mode: '0644'
          vars:
            automation_hub_token_value: "{{ automation_hub_token | default('') }}"
            current_user: "{{ ansible_user_id | default('root') }}"
      ignore_errors: true

    #
    # SECTION 7: Image Management
    #
    - name: Check and pull required container images
      block:
        - name: Check if required container images exist
          ansible.builtin.command:
            cmd: "podman image exists {{ item }}"
          environment: "{{ podman_env }}"
          loop: "{{ required_images }}"
          register: image_check_results
          changed_when: false
          failed_when: false
          loop_control:
            label: "{{ item }}"
          tags: [setup, images, check_images]

        - name: Display missing images to pull
          ansible.builtin.set_fact:
            missing_images: "{{ image_check_results.results | selectattr('rc', 'defined') | selectattr('rc', 'ne', 0) | map(attribute='item') | list }}"
          tags: [setup, images, identify_missing]

        - name: Show missing image count
          ansible.builtin.debug:
            msg: "Found {{ missing_images | length }} images that need to be pulled"
          tags: [setup, images, count_missing]

        # Skip subsequent tasks if no images are missing
        - name: Skip message when no images need to be pulled
          ansible.builtin.debug:
            msg: "All required images already present, skipping pull operations"
          when: missing_images | length == 0
          tags: [setup, images, skip_message]

        # Only run these tasks when images need to be pulled
        - name: Handle missing images
          when: missing_images | length > 0
          block:
            - name: Pull missing container images
              ansible.builtin.command:
                cmd: "podman pull {{ item }}"
              environment: "{{ podman_env }}"
              loop: "{{ missing_images }}"
              register: pull_results
              changed_when: pull_results.rc == 0
              failed_when: false
              retries: 3
              delay: 5
              until: pull_results is succeeded
              loop_control:
                label: "{{ item }}"
                pause: 1.0
              tags: [setup, images, pull_images]

            - name: Process image pull results
              ansible.builtin.set_fact:
                successful_pulls: "{{ pull_results.results | default([]) | selectattr('rc', 'defined') | selectattr('rc', 'eq', 0) | list }}"
                failed_pulls: "{{ pull_results.results | default([]) | selectattr('rc', 'defined') | selectattr('rc', 'ne', 0) | list }}"
              tags: [setup, images, process_results]

            - name: Summarize image pull results
              ansible.builtin.debug:
                msg: |
                  Image Pull Summary:
                  ───────────────────────────
                  Successfully pulled images:
                  {% for image in successful_pulls | default([]) %}
                  - {{ image }}
                  {% endfor %}
                  
                  Failed to pull images:
                  {% for image in failed_pulls | default([]) %}
                  - {{ image }}
                  {% endfor %}
              tags: [setup, images, summarize]

            - name: Fail if any required images could not be pulled
              ansible.builtin.fail:
                msg: |
                  CRITICAL ERROR: Failed to pull the following required images:
                  {% for image in failed_pulls | default([]) %}
                  - {{ image }}
                  {% endfor %}
                  
                  These images are required for execution environment building.
                  Please check your network connection, registry authentication,
                  and ensure these images are accessible.
              when: failed_pulls is defined and failed_pulls | length > 0
              tags: [setup, images, validation]
          tags: [setup, images, pull_process]
      rescue:
        - name: Critical failure in image pulling
          ansible.builtin.fail:
            msg: |
              CRITICAL ERROR: Failed to pull required container images.
              This playbook cannot continue without the necessary base images.
              
              Please verify:
              1. Registry authentication is working (podman login)
              2. Network connectivity to container registries
              3. The required images exist and are accessible
      tags: [setup, images]

    #
    # SECTION 8: Dependencies Management
    #
    - name: Manage dependencies
      block:
        - name: Check if requirements.txt exists
          ansible.builtin.stat:
            path: "files/requirements.txt"
          register: requirements_txt

        - name: Install Python packages from requirements.txt
          ansible.builtin.pip:
            requirements: "files/requirements.txt"
            extra_args: "--upgrade"
          when: requirements_txt.stat.exists
          register: pip_install_result
          retries: 2
          delay: 3
          until: pip_install_result is succeeded
          failed_when: false

        - name: Check if requirements.yml exists
          ansible.builtin.stat:
            path: "files/requirements.yml"
          register: requirements_yml

        - name: Install required collections system-wide
          ansible.builtin.command:
            cmd: "ansible-galaxy collection install -r /tmp/requirements.yml -p /usr/share/ansible/collections"
          register: galaxy_install
          changed_when: galaxy_install.rc == 0
          failed_when: galaxy_install_result.rc != 0
          when: collection_check.rc != 0 or (force_collection_reinstall | default(false)) | bool
          tags: [always, collections]

    # 
    # SECTION 8.5: Environment Selection Filtering
    #
    - name: Filter available environments based on distribution selection
      block:
        - name: Get all available environments
          ansible.builtin.find:
            paths: "environments"
            file_type: directory
          register: all_environments
          
        - name: Process environments for filtering
          ansible.builtin.set_fact:
            rhel8_environments: "{{ all_environments.files | selectattr('path', 'search', 'rhel8') | rejectattr('path', 'search', '\\.bak$') | map(attribute='path') | list }}"
            rhel9_environments: "{{ all_environments.files | selectattr('path', 'search', 'rhel9') | rejectattr('path', 'search', '\\.bak$') | map(attribute='path') | list }}"
            neutral_environments: "{{ all_environments.files | rejectattr('path', 'search', 'rhel[89]') | rejectattr('path', 'search', '\\.bak$') | map(attribute='path') | list }}"
            
        - name: Set available environments based on distribution selection
          ansible.builtin.set_fact:
            available_environments: "{{ 
                neutral_environments + 
                (build_rhel8 | bool) | ternary(rhel8_environments, []) + 
                (build_rhel9 | bool) | ternary(rhel9_environments, [])
              }}"
              
        - name: Debug available environments
          ansible.builtin.debug:
            msg: "Available environments based on distribution selection: {{ available_environments | map('basename') | list }}"
            
        # Pass the filtered environment list to the environment_menu.yml
        - name: Set environment_paths for menu
          ansible.builtin.set_fact:
            environment_paths: >-
              {{
                neutral_environments +
                ((build_rhel8 | bool) | ternary(rhel8_environments, [])) +
                ((build_rhel9 | bool) | ternary(rhel9_environments, []))
              }}
          when: build_rhel8 is defined or build_rhel9 is defined

    - name: Clean up backup directories
      ansible.builtin.file:
        path: "{{ item.path }}"
        state: absent
      with_items: "{{ all_environments.files | selectattr('path', 'search', '\\.bak$') | list }}"
      when: cleanup_backups|default(true)

    - name: Display environment selection menu header
      ansible.builtin.debug:
        msg: |
          **************************************************
          ENVIRONMENT SELECTION MENU

          Selected distribution: RHEL {{ distribution_selection }}

          Available environments:
          {% for env in environment_paths %}
          {{ loop.index }}. {{ env | basename }}
          {% endfor %}
          **************************************************

    - name: Prompt for environment selection
      ansible.builtin.pause:
        prompt: |
          **************************************************
          ENVIRONMENT SELECTION MENU

          Selected distribution: RHEL {{ distribution_selection }}

          Available environments:
          {% for env in environment_paths %}
          {{ loop.index }}. {{ env | basename }}
          {% endfor %}
          **************************************************

          Enter numbers for environments to build (comma-separated, max {{ environment_paths | length }}):
          Enter 'all' to select all environments
          Enter 'q' to quit without selecting:
      register: user_input

    - name: Debug user input
      ansible.builtin.debug:
        var: user_input

    - name: Parse user input for environment selection
      ansible.builtin.set_fact:
        selected_environments: >-
          {{
            environment_paths if user_input.user_input == 'all' else
            environment_paths | zip(range(1, environment_paths | length + 1)) |
            selectattr(1, 'in', user_input.user_input.split(',')) |
            map(attribute=0) | list
          }}
      vars:
        user_input: "{{ user_input.user_input | default('') }}"

    - name: Debug selected environments
      ansible.builtin.debug:
        var: selected_environments

    - name: Validate selected environment paths
      ansible.builtin.stat:
        path: "{{ item }}"
      register: environment_path_check
      loop: "{{ selected_environments }}"
      failed_when: environment_path_check.results | selectattr('stat.exists', 'equalto', false) | list | length > 0

    - name: Debug environment path check results
      ansible.builtin.debug:
        var: environment_path_check

    - name: Include environment menu tasks
      ansible.builtin.include_tasks: tasks/environment_menu.yml
      register: environment_menu_result
      tags: [environment, menu, env_selection]

    - name: Debug selected environments
      ansible.builtin.debug:
        msg: "Selected environments to process: {{ selected_environments | join(', ') }}"
      when: selected_environments | default([]) | length > 0

    - name: Debug environment paths
      ansible.builtin.debug:
        var: environment_paths

    - name: Debug selected environments
      ansible.builtin.debug:
        var: selected_environments

    - name: Debug environment paths
      ansible.builtin.debug:
        var: environment_paths

    - name: Debug user input
      ansible.builtin.debug:
        var: user_input

    # Add after menu selections
    - name: Update protected images after menu selections
      block:
        - name: Add selected environments to protected list
          ansible.builtin.set_fact:
            protected_images: "{{ (protected_images | default([])) + selected_environments | map('basename') | list }}"
          when: selected_environments is defined and selected_environments | length > 0
            
        - name: Ensure protected_images list is unique and sorted
          ansible.builtin.set_fact:
            protected_images: "{{ protected_images | unique | sort }}"
            
        - name: Update protected_images.yml after menu selections
          ansible.builtin.template:
            src: templates/protected_images.j2
            dest: "{{ playbook_dir }}/tasks/protected_images.yml"
            mode: '0644'
          vars:
            consolidated_images: "{{ protected_images }}"
      tags: [setup, menu, image_protection]
      
    # SECTION 8: Monitoring Setup
    #
    - name: Setup basic podman monitoring
      block:
        - name: Ensure scripts directory exists
          ansible.builtin.file:
            path: "scripts"
            state: directory
            mode: '0755'
          tags: [monitoring, monitoring_dir]

        - name: Create monitoring script
          ansible.builtin.copy:
            dest: "scripts/start_monitor.sh"
            mode: '0755'
            content: |
              #!/bin/bash
              # Enhanced monitoring script for podman with auto-popup terminal and title screen

              # Kill any existing session
              tmux kill-session -t podman-monitor 2>/dev/null || true
              
              # Create the basic session
              tmux new-session -d -s podman-monitor
              
              # Configure the session with proper formatting
              tmux set -g default-terminal "screen-256color"
              tmux set -g terminal-overrides ",xterm-256color:Tc"
              
              # Set larger history limit for better scrollback
              tmux set -g history-limit 10000
              
              # Split into 2 panes
              tmux split-window -v -p 30
              
              # Put commands in each pane
              tmux select-pane -t 0
              tmux send-keys "clear" C-m
              tmux send-keys "printf '\e[1;36m%s\e[0m\n' '=== BUILD OUTPUT ==='" C-m
              tmux send-keys "echo 'Waiting for builds to start...'" C-m

              tmux select-pane -t 1
              tmux send-keys "printf '\e[1;32m%s\e[0m\n' '=== IMAGES ==='" C-m
              tmux send-keys "watch -n .5 'podman images'" C-m
              
              tmux select-pane -t 0

              # Auto-open terminal with tmux session attached
              function open_terminal_with_tmux {
                if [ -n "$TMUX" ]; then
                  tmux new-window "tmux attach -t podman-monitor"
                  return 0
                fi
                
                for terminal in gnome-terminal konsole xfce4-terminal terminator mate-terminal x-terminal-emulator xterm; do
                  if command -v $terminal >/dev/null 2>&1; then
                    case $terminal in
                      gnome-terminal)
                        nohup $terminal --geometry=120x40 -- tmux attach -t podman-monitor >/dev/null 2>&1 &
                        ;;
                      konsole|xfce4-terminal|terminator|mate-terminal|x-terminal-emulator)
                        nohup $terminal --geometry=120x40 -e "tmux attach -t podman-monitor" >/dev/null 2>&1 &
                        ;;
                      xterm)
                        nohup $terminal -geometry 120x40 -e "tmux attach -t podman-monitor" >/dev/null 2>&1 &
                        ;;
                    esac
                    echo "Opened monitoring in $terminal"
                    return 0
                  fi
                done
                
                if (grep -q Microsoft /proc/version 2>/dev/null); then
                  nohup cmd.exe /c start wt.exe -w 0 new-tab --title "Podman Monitor" bash -c "tmux attach -t podman-monitor" >/dev/null 2>&19 &
                  if [ $? -eq 0 ]; then
                    echo "Opened monitoring in Windows Terminal"
                    return 0
                  fi
                fi
                
                return 1
              }

              if ! open_terminal_with_tmux; then
                echo "Could not automatically open a terminal. Connect with: tmux attach -t podman-monitor"
              fi
          tags: [monitoring, monitoring_create_script]

        - name: Run monitoring script
          ansible.builtin.command:
            cmd: "scripts/start_monitor.sh"
          changed_when: true
          tags: [monitoring, monitoring_start]

        - name: Display monitoring availability message
          ansible.builtin.debug:
            msg: |
              ┌────────────────────────────────────────────────────────┐
              │                  BUILD MONITORING AVAILABLE            │
              ├────────────────────────────────────────────────────────┤
              │ To monitor build progress, run:                        │
              │ tmux attach -t podman-monitor                          │
              └────────────────────────────────────────────────────────┘
          tags: [monitoring]

    #
    # SECTION 9: Build execution environments
    #
    - name: Set build ready flag
      ansible.builtin.set_fact:
        build_ready: "{{ selected_environments | default([]) | length > 0 }}"
      tags: [build, build_set_ready_flag]

    - name: Skip message if environment is not compatible with selected distributions
      ansible.builtin.debug:
        msg: "Skipping environment '{{ item }}' as it's not compatible with selected distributions."
      loop: "{{ selected_environments | default([]) }}"
      when: >
        (not build_rhel8 and 'rhel8' in item) or
        (not build_rhel9 and 'rhel9' in item)
      loop_control:
        label: "{{ item }}"
      tags: [build, build_process, skip_incompatible]

    - name: Filter out backup directories from build list
      ansible.builtin.set_fact:
        filtered_selected_environments: "{{ selected_environments | reject('search', '\\.bak$') | list }}"

    - name: Show filtered build environments
      ansible.builtin.debug:
        msg: "Building environments (excluding .bak): {{ filtered_selected_environments | join(', ') }}"
            
    - name: Build compatible selected environments
      include_tasks: tasks/build_environment.yml
      vars:
        current_env: "{{ item | basename }}"
        environment_dir: "{{ item }}"
      loop: "{{ filtered_selected_environments }}"
      when: >
        (build_rhel8 and 'rhel8' in item) or
        (build_rhel9 and 'rhel9' in item) or
        ('rhel8' not in item and 'rhel9' not in item)
      loop_control:
        label: "{{ item }}"
      tags: [build, build_process, execute_environment]

    - name: Ensure all execution environment files have ansible-core dependency
      ansible.builtin.lineinfile:
        path: "{{ item }}/execution-environment.yml"
        regexp: '  ansible_core:'
        insertafter: '^dependencies:'
        line: '  ansible_core:'
        create: yes
      with_items: "{{ filtered_selected_environments }}"
      when: lookup('ansible.builtin.file', '{{ item }}/execution-environment.yml') is defined

    - name: Add version specification for ansible-core
      ansible.builtin.lineinfile:
        path: "{{ item }}/execution-environment.yml"
        regexp: '  ansible_core:'
        insertafter: '  ansible_core:'
        line: '    package_pip: "ansible-core>=2.13.0"'
        create: no
      with_items: "{{ filtered_selected_environments }}"
      when: lookup('ansible.builtin.file', '{{ item }}/execution-environment.yml') is defined

    # Keep this section for final cleanup only - NOT between builds
    - name: Final Cleanup (runs only once after all builds)
      block:
        - name: Ensure _build directory structure exists
          ansible.builtin.file:
            path: "{{ work_dir }}/context/_build"
            state: directory
            mode: '0755'
          ignore_errors: true
          tags: [build, build_deps]

        - name: Fix systemd-python dependency in Python package list
          ansible.builtin.replace:
            path: "{{ work_dir }}/context/_build/requirements.txt"
            regexp: '^systemd-python.*$'
            replace: '# systemd-python disabled due to build issues'
            backup: true
          when: 
            - lookup('ansible.builtin.first_found', 'paths="{{ work_dir }}/context/_build/requirements.txt" errors=ignore') != ""
          ignore_errors: true
          tags: [build, build_deps]

        - name: Ensure requirements files are properly copied to build context
          block:
            - name: Create build context directory structure
              ansible.builtin.file:
                path: "{{ work_dir }}/context/_build"
                state: directory
                mode: '0755'
              
            - name: Copy requirements.txt from environment directory if it exists
              ansible.builtin.copy:
                src: "{{ environment_dir }}/requirements.txt"
                dest: "{{ work_dir }}/context/_build/requirements.txt"
                mode: '0644'
              ignore_errors: true
              when: lookup('ansible.builtin.first_found', ['{{ environment_dir }}/requirements.txt'], errors='ignore') != ''
              
            - name: Copy requirements.yml from environment directory if it exists
              ansible.builtin.copy:
                src: "{{ environment_dir }}/requirements.yml"
                dest: "{{ work_dir }}/context/_build/requirements.yml"
                mode: '0644'
              ignore_errors: true
              when: lookup('ansible.builtin.first_found', ['{{ environment_dir }}/requirements.yml'], errors='ignore') != ''
              
            - name: Copy requirements.txt from files directory if environment file doesn't exist
              ansible.builtin.copy:
                src: "{{ playbook_dir }}/files/requirements.txt"
                dest: "{{ work_dir }}/context/_build/requirements.txt"
                mode: '0644'
              ignore_errors: true
              when: >
                lookup('ansible.builtin.first_found', ['{{ environment_dir }}/requirements.txt'], errors='ignore') == '' and
                lookup('ansible.builtin.first_found', ['{{ playbook_dir }}/files/requirements.txt'], errors='ignore') != ''
              
            - name: Copy requirements.yml from files directory if environment file doesn't exist
              ansible.builtin.copy:
                src: "{{ playbook_dir }}/files/requirements.yml"
                dest: "{{ work_dir }}/context/_build/requirements.yml"
                mode: '0644'
              ignore_errors: true
              when: >
                lookup('ansible.builtin.first_found', ['{{ environment_dir }}/requirements.yml'], errors='ignore') == '' and
                lookup('ansible.builtin.first_found', ['{{ playbook_dir }}/files/requirements.yml'], errors='ignore') != ''
          tags: [build, build_deps]
      run_once: true
      when: is_root and build_ready | default(false) | bool
      tags: [build]

    #
    # SECTION 10: Create Sample Environments
    #
    - name: Check for existing environments
      ansible.builtin.find:
        paths: "environments"
        file_type: directory
      register: existing_env_dirs
      
    - name: Create sample environment directories with clear RHEL version indicators
      ansible.builtin.file:
        path: "environments/{{ item }}"
        state: directory
        mode: '0755'
      with_items:
        - "rhel8"
        - "rhel9"
      when: existing_env_dirs.files | length == 0

    #
    # SECTION 11: Environment Filtering and Selection
    #
    - name: Filter available environments based on distribution selection
      block:
        - name: Get all available environments
          ansible.builtin.find:
            paths: "environments"
            file_type: directory
          register: all_environments
          
        - name: Display all discovered environments before filtering
          ansible.builtin.debug:
            msg: |  
              All available environments before filtering:
              {% for env in all_environments.files %}
              - {{ env.path | basename }}
              {% endfor %}
        
        - name: Process environments for filtering
          ansible.builtin.set_fact:
            rhel8_environments: "{{ all_environments.files | selectattr('path', 'search', 'rhel8') | rejectattr('path', 'search', '\\.bak$') | map(attribute='path') | list }}"
            rhel9_environments: "{{ all_environments.files | selectattr('path', 'search', 'rhel9') | rejectattr('path', 'search', '\\.bak$') | map(attribute='path') | list }}"
            neutral_environments: "{{ all_environments.files | rejectattr('path', 'search', 'rhel[89]') | rejectattr('path', 'search', '\\.bak$') | map(attribute='path') | list }}"

        - name: Display filtered environment lists
          ansible.builtin.debug:
            msg: |
              RHEL 8 environments: {{ rhel8_environments | map('basename') | list }}
              RHEL 9 environments: {{ rhel9_environments | map('basename') | list }}
              Neutral environments: {{ neutral_environments | map('basename') | list }}

        - name: Set available environments based on distribution selection
          ansible.builtin.set_fact:
            available_environments: "{{ 
                neutral_environments + 
                (build_rhel8 | bool) | ternary(rhel8_environments, []) + 
                (build_rhel9 | bool) | ternary(rhel9_environments, [])
              }}"
              
        - name: Set environment_paths for menu
          ansible.builtin.set_fact:
            environment_paths: "{{ 
                neutral_environments + 
                (build_rhel8 | bool) | ternary(rhel8_environments, []) + 
                (build_rhel9 | bool) | ternary(rhel9_environments, [])
              }}"
              
        - name: Display final filtered environment list
          ansible.builtin.debug:
            msg: |
              Final environment list for {{ (build_rhel8 | bool) | ternary('RHEL 8', '') }}{{ (build_rhel8 and build_rhel9) | ternary(' and ', '') }}{{ (build_rhel9 | bool) | ternary('RHEL 9', '') }}:
              {{ environment_paths | map('basename') | list }}

    - name: Build summary report
      ansible.builtin.debug:
        msg: |
          ====================================================
                         BUILD SUMMARY REPORT
          ====================================================
          Total environments processed: {{ selected_environments | length }}
          
          {% if failed_environments | default([]) | length > 0 %}
          FAILED ENVIRONMENTS:
          {% for env in failed_environments | default([]) %}
          ✗ {{ env }}
          {% endfor %}
                    
          These environments were skipped due to build failures.
          Check logs in /var/log/ansible/ansible-builder/ for details.
          {% else %}
          All builds completed successfully!
          {% endif %}
      run_once: true
      tags: [build, summary]

    - name: Update protected images list
      block:
        - name: Get all tagged images
          ansible.builtin.shell: |
            podman images --format '{% raw %}{{ .Repository }}:{{ .Tag }}{% endraw %}' | grep -v "<none>:<none>"
          register: current_images
          changed_when: false
          
        - name: Read existing protected_images file if it exists
          ansible.builtin.slurp:
            src: "protected_images.yml"
          register: existing_protected_file
          ignore_errors: true
          
        - name: Parse existing protected images
          ansible.builtin.set_fact:
            existing_protected: "{{ (existing_protected_file.content | b64decode | from_yaml).protected_images | default([]) }}"
          when: existing_protected_file is succeeded
          
        - name: Combine all protected images
          ansible.builtin.set_fact:
            consolidated_images: "{{ (existing_protected | default([])) + current_images.stdout_lines | unique }}"
          
        - name: Update protected_images.yml
          ansible.builtin.template:
            src: templates/protected_images.j2
            dest: "protected_images.yml"
            mode: '0644'
      tags: [setup, images, protect_images, token_refresh, cron]

    - name: Create token refresh script
      ansible.builtin.copy:
        dest: "scripts/refresh_rh_token.sh"
        mode: '0755'
        content: |
          #!/bin/bash
          # Set variables
          CONFIG_PATH="{{ user_home }}/.ansible/vars/config"
          LOG_FILE="{{ user_home }}/.ansible/vars/token_refresh.log"

          # Create log directory if it doesn't exist
          mkdir -p "$(dirname $LOG_FILE)"

          # Create log entry for this run
          echo "===== Token refresh attempt started at $(date) =====" >> $LOG_FILE
          
          # Check if config file exists
          if [ ! -f "$CONFIG_PATH" ]; then
            echo "ERROR: Config file not found at $CONFIG_PATH" >> $LOG_FILE
            exit 1
          fi

          # Extract refresh token from config
          REFRESH_TOKEN=$(grep "automation_hub_token" "$CONFIG_PATH" | cut -d "'" -f 2)
          
          if [ -z "$REFRESH_TOKEN" ]; then
            echo "ERROR: No token found in config file" >> $LOG_FILE
            exit 1
          fi
          
          # Make token refresh request
          echo "Making token refresh request..." >> $LOG_FILE
          RESPONSE=$(curl https://sso.redhat.com/auth/realms/redhat-external/protocol/openid-connect/token \
            -d grant_type=refresh_token \
            -d client_id="cloud-services" \
            -d refresh_token="$REFRESH_TOKEN" \
            --fail \
            --silent \
            --show-error 2>&1)
          
          # Check result
          if [ $? -eq 0 ]; then
            echo "SUCCESS: Token refresh completed successfully" >> $LOG_FILE
            
            # Extract and update new token
            NEW_TOKEN=$(echo $RESPONSE | jq -r '.refresh_token')
            if [ "$NEW_TOKEN" != "null" ] && [ -n "$NEW_TOKEN" ]; then
              # Create a backup of the config
              cp "$CONFIG_PATH" "${CONFIG_PATH}.bak"
              
              # Replace the token in the config file
              sed -i "s|automation_hub_token: '$REFRESH_TOKEN'|automation_hub_token: '$NEW_TOKEN'|g" "$CONFIG_PATH"
              echo "Token updated in config file" >> $LOG_FILE
            else
              echo "WARNING: Response didn't contain a valid refresh token" >> $LOG_FILE
            fi
          else
            echo "ERROR: Token refresh failed" >> $LOG_FILE
            echo "Response: $RESPONSE" >> $LOG_FILE
          fi
          
          echo "===== Token refresh attempt completed at $(date) =====" >> $LOG_FILE
          echo "" >> $LOG_FILE

    - name: Handle token verification
      block:
        - name: Test token with API request
          ansible.builtin.uri:
            url: https://console.redhat.com/api/automation-hub/api/v3/collections/
            method: GET
            headers:
              Authorization: "Bearer {{ automation_hub_token | default('') }}"
          register: token_test
          failed_when: false

        - name: Display token status
          ansible.builtin.debug:
            msg: "Token is {{ token_test.status == 200 | ternary('valid', 'invalid') }}"

    - name: Create cron job to refresh token
      ansible.builtin.cron:
        name: "Refresh Red Hat Automation Hub token"
        user: "{{ actual_user }}"
        minute: "0"
        hour: "4"
        day: "*/14"
        job: "scripts/refresh_rh_token.sh > /dev/null 2>&1"
      ignore_errors: true

    - name: Install jq for JSON parsing
      ansible.builtin.package:
        name: jq
        state: present 
      ignore_errors: true

    - name: Create cron job to refresh the token every 2 weeks
      ansible.builtin.cron:
        name: "Refresh Red Hat Automation Hub token"
        job: "scripts/refresh_rh_token.sh > /dev/null 2>&1"
        minute: "0"
        hour: "4"
        day: "*/14"
        user: "{{ actual_user }}"
      tags: [setup, token_refresh, cron]

    - name: Setup protected images management
      block:
        - name: Ensure tasks directory exists
          ansible.builtin.file:
            path: "{{ playbook_dir }}/tasks"
            state: directory
            mode: '0755'
            
        - name: Initialize protected_images list management
          ansible.builtin.set_fact:
            protected_images: "{{ protected_images | default([]) }}"
            
        - name: Add base required images to protected list
          ansible.builtin.set_fact:
            protected_images: >-
              {{ 
                protected_images +
                [
                  'registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel8:latest',
                  'registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel9:latest',
                  'registry.redhat.io/ansible-automation-platform-25/de-supported-rhel8:latest',
                  'registry.redhat.io/ansible-automation-platform-25/de-supported-rhel9:latest',
                  'registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel8:latest',
                  'registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel9:latest',
                  'registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel8:latest',
                  'registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel9:latest'
                ]
              }}

    - name: Update protected_images.yml
      ansible.builtin.template:
        src: templates/protected_images.j2
        dest: "{{ playbook_dir }}/tasks/protected_images.yml"
        mode: '0644'
      vars:
        consolidated_images: "{{ protected_images | unique | sort }}"

    - name: Clean dangling images while preserving protected images
      block:
        - name: Get list of all images
          ansible.builtin.shell: podman images --format '{{.Repository}}:{{.Tag}} {{.ID}}'
          register: all_images_info
          changed_when: false

        - name: Parse image information
          ansible.builtin.set_fact:
            images: "{{ all_images_info.stdout_lines | map('split', ' ') | map('list') | list }}"

        - name: Display parsed images
          ansible.builtin.debug:
            msg: |
              Parsed images:
              {% for image in images %}
              - Repository: {{ image[0] }}
                Tag: {{ image[1] }}
                ID: {{ image[2] }}
              {% endfor %}

        - name: Extract protected image IDs
          ansible.builtin.set_fact:
            protected_image_ids: "{{ all_images_info.stdout_lines | map('split', ' ') | selectattr(0, 'in', protected_images) | map('last') | list }}"
          
        - name: Find dangling images
          ansible.builtin.set_fact:
            dangling_image_ids: "{{ all_images_info.images | 
                                 selectattr('RepoTags', 'defined') | 
                                 selectattr('RepoTags', 'equalto', ['<none>:<none>']) |
                                 map(attribute='Id') | list }}"
          
        - name: Remove unprotected dangling images
          ansible.builtin.shell: |
            for image in {{ dangling_image_ids | difference(protected_image_ids) | join(' ') }}; do
              podman rmi -f $image || true
            done
          changed_when: true
      ignore_errors: true

    - name: Check if image exists using podman inspect
      ansible.builtin.shell: podman inspect "{{ image_name }}"
      register: image_info
      failed_when: false
      changed_when: false

    - name: Determine if image exists
      ansible.builtin.set_fact:
        image_exists: "{{ image_info.rc == 0 }}"

    - name: Build environment if image does not exist
      when: not image_exists
      block:
        - name: Create context directory
          ansible.builtin.file:
            path: "{{ work_dir }}/context"
            state: directory
            mode: '0755'

        - name: Copy execution environment file
          ansible.builtin.copy:
            src: "{{ current_path }}/execution-environment.yml"
            dest: "{{ work_dir }}/context/execution-environment.yml"
            mode: '0644'

        - name: Build container image using ansible-builder
          ansible.builtin.command:
            cmd: >-
              ansible-builder build
              --tag {{ image_name }}
              --container-runtime podman
              --verbosity 2
              --prune-images
              --context {{ work_dir }}/context
              -f {{ work_dir }}/context/execution-environment.yml
            chdir: "{{ work_dir }}/context"
          register: build_output
          changed_when: "'Downloaded newer image' in build_output.stdout or 'Successfully built' in build_output.stdout"
          environment:
            ANSIBLE_BUILDER_HOME: "{{ work_dir }}/context"
