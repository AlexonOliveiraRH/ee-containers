---
- name: Comprehensive Setup Playbook
  hosts: localhost
  become: true

  vars:
    container_registries:
      - registry.redhat.io
      - console.redhat.com
      - registry.access.redhat.com
      - quay.io
      - registry.connect.redhat.com
    dns_servers:
      - '8.8.8.8'
      - '8.8.4.4'
    required_packages:
      - python3-pip
      - ansible-core
      - git
      - podman
      - ansible-dev-tools
      - podman-docker
      - podman-compose
      - podman-plugins
      - podman-remote
      - yum-utils
    git_repo:
      url: 'https://github.com/cloin/ee-builds.git'
      branch: 'main'
    work_dir: '/tmp/ee-containers'

  vars_prompt:
    - name: rh_username
      prompt: "Enter your Red Hat CDN username"
      private: false
    - name: rh_password
      prompt: "Enter your Red Hat CDN password"
      private: true
    - name: automation_hub_token
      prompt: "Enter your Automation Hub token from https://console.redhat.com/ansible/automation-hub/token (or press enter to skip)"
      private: true
    - name: galaxy_token
      prompt: "Enter your Galaxy token from https://galaxy.ansible.com/ui/token (or press enter to skip)"
      private: true
      default: ""

  pre_tasks:
    - name: Verify internet connectivity
      ansible.builtin.uri:
        url: https://google.com
        method: GET
      register: connectivity_check
      failed_when: connectivity_check.status != 200
      changed_when: false

    - name: Fail if no internet connection is detected
      ansible.builtin.fail:
        msg: "No internet connection detected."
      when: connectivity_check.status != 200

    - name: Install prerequisites
      tags: [setup, packages]
      vars:
        packages:
          - python3-pip
          - ansible-core
          - git
          - podman
          - ansible-dev-tools
          - podman-docker
          - podman-compose
          - podman-plugins
          - podman-remote
          - yum-utils
      block:
        - name: Install required packages
          ansible.builtin.package:
            name: "{{ packages }}"
            state: present

    - name: Do dnf upgrade all packages
      ansible.builtin.dnf:
        name: '*'
        state: latest

    - name: Ensure container policy directory exists
      ansible.builtin.file:
        path: /etc/containers/policy.d
        state: directory
        mode: '0755'

    - name: Create container policy file
      ansible.builtin.copy:
        dest: /etc/containers/policy.d/default.json
        mode: '0644'
        content: |
          {
            "default": [{"type": "reject"}],
            "transports": {
              "docker": {
                "registry.redhat.io": [{"type": "insecureAcceptAnything"}],
                "registry.access.redhat.com": [{"type": "insecureAcceptAnything"}],
                "quay.io": [{"type": "insecureAcceptAnything"}],
                "docker.io": [{"type": "insecureAcceptAnything"}]
              }
            }
          }

    - name: Check directories
      ansible.builtin.stat:
        path: "{{ item }}"
      loop:
        - environments
        - /tmp/ee-containers/environments
        - environments/.git
        - /tmp/ee-containers/environments/.git
        - /etc/containers/policy.d/
      register: dir_checks

    - name: Check if local environments directory exists
      ansible.builtin.stat:
        path: environments
      register: local_environments_dir

    - name: Check if local environments directory is empty
      ansible.builtin.find:
        paths: environments
        recurse: false
      register: local_environments_dir_content
      when: local_environments_dir.stat.exists

    - name: Ensure /tmp/ee-containers/environments directory exists
      ansible.builtin.file:
        path: /tmp/ee-containers/environments
        state: directory
        mode: '0755'

    - name: Check if /tmp/ee-containers/environments directory exists
      ansible.builtin.stat:
        path: /tmp/ee-containers/environments
      register: environments_dir

    - name: Check if /tmp/ee-containers/environments directory is empty
      ansible.builtin.find:
        paths: /tmp/ee-containers/environments
        recurse: false
      register: environments_dir_content
      when: environments_dir.stat.exists

    - name: Check if /tmp/ee-containers/environments is a git repository
      ansible.builtin.stat:
        path: /tmp/ee-containers/environments/.git
      register: git_repo_exists

    - name: Remove existing directory if it's not a git repository
      ansible.builtin.file:
        path: /tmp/ee-containers/environments
        state: absent
      when: environments_dir.stat.exists and not git_repo_exists.stat.exists

    - name: Clone or update GitHub repository
      ansible.builtin.git:
        repo: 'https://github.com/cloin/ee-builds.git'
        dest: /tmp/ee-containers/environments/
        version: 'main'
        clone: true
        update: true
        force: true
      when: not environments_dir.stat.exists or not git_repo_exists.stat.exists or environments_dir_content.matched == 0

    - name: Check if repository is already cloned in current directory
      ansible.builtin.stat:
        path: environments/.git
      register: repo_cloned_local

    - name: Clone GitHub repository to current directory if not already cloned
      ansible.builtin.git:
        repo: 'https://github.com/cloin/ee-builds.git'
        dest: environments/
        version: 'main'  # Specify the branch or commit
        clone: true
        update: true
        force: true
      when: not repo_cloned_local.stat.exists and not local_environments_dir.stat.exists

    - name: Install required collections
      ansible.builtin.command:
        cmd: ansible-galaxy collection install community.general
      changed_when: false

  tasks:
    - name: Check if already logged in to registries
      ansible.builtin.command:
        cmd: "podman login -u {{ rh_username }} -p {{ rh_password }} {{ item }}"
        creates: "/root/.config/containers/auth.json"
      loop:
        - registry.redhat.io
        - console.redhat.com
        - registry.access.redhat.com
        - quay.io
        - registry.connect.redhat.com
      register: login_result
      failed_when:
        - login_result.rc != 0
        - item != 'console.redhat.com'  # Ignore failures for console.redhat.com
      ignore_errors: "{{ item == 'console.redhat.com' }}"  # Only ignore errors for console.redhat.com
#      no_log: true  # Hide sensitive information from logs

    - name: Pull required container images
      ansible.builtin.command:
        cmd: "podman pull {{ item }}"
      loop:
        - registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel8
        - registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel9
        - registry.redhat.io/ansible-automation-platform-25/de-supported-rhel8
        - registry.redhat.io/ansible-automation-platform-25/de-supported-rhel9
        - registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel8
        - registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel9
        - registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel8
        - registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel9
      register: pull_results
      changed_when: "'Downloaded newer image' in pull_results.stdout"
      retries: 3
      delay: 5
      until: pull_results is success

    - name: Display pulled images status
      ansible.builtin.debug:
        msg: "{{ pull_results }}"

    - name: Clean up container registry
      block:
        - name: Remove unused images
          ansible.builtin.command:
            cmd: podman image prune -af
          register: prune_result
          changed_when: prune_result.stdout != ""

        - name: Clean registry cache
          ansible.builtin.command:
            cmd: podman system prune -f
          register: system_prune_result
          changed_when: system_prune_result.stdout != ""

        - name: Display cleanup results
          ansible.builtin.debug:
            msg:
              - "Image pruning results: {{ prune_result.stdout }}"
              - "System pruning results: {{ system_prune_result.stdout }}"

    - name: Check if requirements.txt exists
      ansible.builtin.stat:
        path: /tmp/ee-containers/files/requirements.txt
      register: requirements_txt

    - name: Install Python packages from requirements.txt if it exists
      ansible.builtin.pip:
        requirements: /tmp/ee-containers/files/requirements.txt
      when: requirements_txt.stat.exists

    - name: Check if requirements.yml exists
      ansible.builtin.stat:
        path: /tmp/ee-containers/files/requirements.yml
      register: requirements_yml

    - name: Install ansible-galaxy collections from requirements.yml if it exists
      ansible.builtin.command:
        cmd: "ansible-galaxy collection install -r /tmp/ee-containers/files/requirements.yml"
        creates: "/root/.ansible/collections/ansible_collections"
      when: requirements_yml.stat.exists
      failed_when: requirements_yml.rc != 0

    - name: Ensure /tmp/ee-containers/_build/configs directory exists
      ansible.builtin.file:
        path: /tmp/ee-containers/_build/configs
        state: directory
        mode: '0755'

    - name: Create ansible.cfg in /tmp/ee-containers/_build/configs
      ansible.builtin.copy:
        dest: /tmp/ee-containers/_build/configs/ansible.cfg
        mode: '0644'
        content: |
          [defaults]
          inventory = /etc/ansible/hosts
          remote_user = root
          host_key_checking = False
          retry_files_enabled = False
          collections_paths = ~/.ansible/collections:/usr/share/ansible/collections
          roles_path = ~/.ansible/roles:/usr/share/ansible/roles:/etc/ansible/roles

          [galaxy]
          server_list = validated, published, galaxy

          [galaxy_server.published]
          url=https://console.redhat.com/api/automation-hub/content/published/
          auth_url=https://sso.redhat.com/auth/realms/redhat-external/protocol/openid-connect/token
          token={{ automation_hub_token }}

          [galaxy_server.validated]
          url=https://console.redhat.com/api/automation-hub/content/validated/
          auth_url=https://sso.redhat.com/auth/realms/redhat-external/protocol/openid-connect/token
          token={{ automation_hub_token }}

          [galaxy_server.galaxy]
          url=https://galaxy.ansible.com/
          token={{ galaxy_token if galaxy_token != "" else omit }}

    - name: Verify DNS resolution
      ansible.builtin.command:
        cmd: "nslookup {{ item }}"
      loop:
        - github.com
        - cdn-ubi.redhat.com
        - galaxy.ansible.com
      register: dns_checks
      changed_when: false
      failed_when: dns_checks.rc != 0

    - name: Set DNS servers for Podman
      ansible.builtin.copy:
        dest: /etc/containers/registries.conf
        content: |
          [registries.search]
          registries = ['docker.io', 'quay.io', 'registry.fedoraproject.org', 'registry.access.redhat.com', 'registry.redhat.io']

          [registries.insecure]
          registries = []

          [registries.block]
          registries = []

          [registries]
          registries = ['docker.io', 'quay.io', 'registry.fedoraproject.org', 'registry.access.redhat.com', 'registry.redhat.io']

          [engine]
          dns_servers = ['8.8.8.8', '8.8.4.4']
        mode: '0644'

    - name: Build a numeric menu for the user to select environment
      block:
        - name: Find EE environment directories
          ansible.builtin.find:
            paths: "environments/"
            patterns: "ee-*"
            recurse: false
            file_type: directory
          register: found_ee_dirs

        - name: Display EE environment directories
          ansible.builtin.debug:
            var: found_ee_dirs

        - name: Find DE environment directories
          ansible.builtin.find:
            paths: "environments/"
            patterns: "de-*"
            recurse: false
            file_type: directory
          register: found_de_dirs

        - name: Display DE environment directories
          ansible.builtin.debug:
            var: found_de_dirs

        - name: Combine and sort environment directories
          ansible.builtin.set_fact:
            all_dirs: "{{ (found_ee_dirs.files + found_de_dirs.files) | sort(attribute='path') }}"

        - name: Display combined environment directories
          ansible.builtin.debug:
            var: all_dirs

        - name: Build menu options string
          ansible.builtin.set_fact:
            menu_options: |
              {% for item in all_dirs %}
              {{ loop.index }}: {{ item.path | basename }}
              {% endfor %}

        - name: Display menu options
          ansible.builtin.debug:
            msg: "{{ menu_options }}"

        - name: Prompt user for environment selection
          ansible.builtin.pause:
            prompt: |
              Select an environment (number):
              {{ menu_options }}
          register: user_selection

        - name: Set selected environment based on user input
          ansible.builtin.set_fact:
            selected_env: "{{ all_dirs[user_selection.user_input | int - 1].path }}"

        - name: Display selected environment
          ansible.builtin.debug:
            var: selected_env

    - name: Ensure repository configuration directory exists
      ansible.builtin.file:
        path: "{{ selected_env }}/repos.d"
        state: directory
        mode: '0755'

#    - name: Create UBI 9 BaseOS repository configuration file
#      ansible.builtin.copy:
#        dest: "{{ selected_env }}/repos.d/ubi-9-baseos.repo"
#        content: |
#          [ubi-9-baseos-rpms]
#          name=Red Hat Universal Base Image 9 BaseOS
#          baseurl=https://cdn-ubi.redhat.com/content/public/ubi/dist/ubi9/9/x86_64/baseos/os/
#          enabled=1
#          gpgcheck=1
#          gpgkey=https://access.redhat.com/security/pki/keys/redhat/redhat-ubi-9-key.pub
#        mode: '0644'

#    - name: Create UBI 9 AppStream repository configuration file
#      ansible.builtin.copy:
#        dest: "{{ selected_env }}/repos.d/ubi-9-appstream.repo"
#        content: |
#          [ubi-9-appstream-rpms]
#          name=Red Hat Universal Base Image 9 AppStream
#          baseurl=https://cdn-ubi.redhat.com/content/public/ubi/dist/ubi9/9/x86_64/appstream/os/
#          enabled=1
#          gpgcheck=1
#          gpgkey=https://access.redhat.com/security/pki/keys/redhat/redhat-ubi-9-key.pub
#        mode: '0644'

    - name: Check if image already exists
      ansible.builtin.command:
        cmd: "podman images -q {{ selected_env | basename }}"
      register: image_exists
      changed_when: false

    - name: Handle image building
      block:
        - name: Build container image if it does not exist
          ansible.builtin.command:
            cmd: "/usr/local/bin/ansible-builder build --prune-images --no-cache -v3 -f {{ selected_env }}/execution-environment.yml --context /tmp/ee-containers --tag {{ selected_env | basename }}"
          async: 2800
          poll: 0
          register: build_job
          when: image_exists.stdout == ""
          changed_when: false

        - name: Wait for build to finish
          ansible.builtin.async_status:
            jid: "{{ build_job.ansible_job_id }}"
          register: build_result
          until: build_result.finished
          retries: 30
          delay: 60

        - name: Display build log
          ansible.builtin.command:
            cmd: "cat /tmp/build.log"
          register: build_log
          when: build_result.rc != 0
          changed_when: false

        - name: Display build log output
          ansible.builtin.debug:
            var: build_log.stdout
          when: build_result.rc != 0

        - name: Cleanup build artifacts
          ansible.builtin.file:
            path: /tmp/build.log
            state: absent
          when: build_result.rc != 0

    - name: Check if build log exists
      ansible.builtin.stat:
        path: /tmp/build.log
      register: build_log_file

    - name: Display build log
      ansible.builtin.command:
        cmd: cat /tmp/build.log
      register: build_log
      when: build_log_file.stat.exists
      changed_when: false

    - name: Display build log output
      ansible.builtin.debug:
        var: build_log.stdout
      when: build_log is defined and build_log.stdout is defined

    - name: Clean up build log
      ansible.builtin.file:
        path: /tmp/build.log
        state: absent
      changed_when: false
      when: build_log_file.stat.exists

    - name: Clean up unused images and build artifacts
      block:
        - name: Get list of images to keep
          ansible.builtin.set_fact:
            keep_images: "{{ all_dirs | map(attribute='path') | map('basename') | list }}"

        - name: Create temporary script for cleanup
          ansible.builtin.copy:
            dest: /tmp/cleanup_images.sh
            mode: '0755'
            content: |
              #!/bin/bash
              
              # Store selected environment
              SELECTED_ENV="{{ selected_env | basename }}"
              
              # List of protected base images with tags
              declare -a PROTECTED_IMAGES=(
                "registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel8:latest"
                "registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel9:latest"
                "registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel8:latest"
                "registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel9:latest"
                "registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel8:latest"
                "registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel9:latest"
                "registry.redhat.io/ansible-automation-platform-25/de-supported-rhel8:latest"
                "registry.redhat.io/ansible-automation-platform-25/de-supported-rhel9:latest"
              )
              
              # Function to check if image should be protected
              is_protected() {
                local image="$1"
                local tag="$2"
                
                # Always protect the selected environment
                if [[ "$image" == *"$SELECTED_ENV"* ]]; then
                  echo "Protecting selected environment: $image:$tag"
                  return 0
                fi
                
                # Check protected images list
                for protected in "${PROTECTED_IMAGES[@]}"; do
                  local p_image="${protected%:*}"
                  if [[ "$image" == *"$p_image"* ]]; then
                    echo "Protecting base image: $image:$tag"
                    return 0
                  fi
                done
                
                return 1
              }
              
              echo "Protected Environment: $SELECTED_ENV"
              echo "Current images before cleanup:"
              podman images
              
              # Only remove unprotected images
              echo -e "\nChecking images for cleanup..."
              FORMAT='{% raw %}{{.Repository}}|{{.Tag}}|{{.ID}}{% endraw %}'
              podman images --format "$FORMAT" | while IFS='|' read -r image tag id; do
                if ! is_protected "$image" "$tag"; then
                  if [[ "$image" != *"registry.redhat.io/ansible-automation-platform-25"* ]]; then
                    echo "Removing unprotected image: $image:$tag"
                    podman rmi -f "$id" 2>/dev/null || true
                  fi
                fi
              done
              
              echo -e "\nRemaining images after cleanup:"
              sleep 2 
              reset
              podman images

        - name: Execute cleanup script
          ansible.builtin.command:
            cmd: /tmp/cleanup_images.sh
          register: cleanup_result
          changed_when: cleanup_result.rc == 0

        - name: Remove temporary cleanup script
          ansible.builtin.file:
            path: /tmp/cleanup_images.sh
            state: absent

        - name: Display cleanup results
          ansible.builtin.debug:
            msg: "Cleanup completed. Results: {{ cleanup_result.stdout }}"

    - name: List podman images
      ansible.builtin.command:
        cmd: podman images --format {% raw %}'{{.Repository}}|{{.Tag}}|{{.ID}}|{{.Created}}|{{.Size}}'{% endraw %}
      register: images
      changed_when: false

    - name: Display podman images
      ansible.builtin.debug:
        msg: |
          REPOSITORY          TAG         IMAGE ID      CREATED            SIZE
          {%- for line in images.stdout_lines -%}
          {%- set fields = line.split('|') -%}
          {{ "%-18s" | format(fields[0]) }}{{ "%-11s" | format(fields[1]) }}{{ "%-12s" | format(fields[2]) }}{{ "%-18s" | format(fields[3]) }}{{ fields[4] }}
          {%- endfor %}

  handlers:
    - name: Cleanup temp files
      ansible.builtin.file:
        path: "{{ item }}"
        state: absent
      loop:
        - /tmp/build.log
        - /tmp/cleanup_images.sh

    - name: Restart podman
      ansible.builtin.service:
        name: podman
        state: restarted
