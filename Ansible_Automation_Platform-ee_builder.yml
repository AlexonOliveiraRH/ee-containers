- name: Automaticly build Execution Environments for Ansible Automation Platform
  hosts: localhost
  become: true

  vars:
    container_registries:
      - registry.redhat.io
      - console.redhat.com
      - registry.access.redhat.com
      - quay.io
      - registry.connect.redhat.com
    dns_servers:
      - '8.8.8.8'
      - '8.8.4.4'
    required_packages:
      - python3-pip
      - ansible-core
      - git
      - podman
      - ansible-dev-tools
      - podman-docker
      - podman-compose
      - podman-plugins
      - podman-remote
      - yum-utils
    git_repo:
      url: 'https://github.com/cloin/ee-builds.git'
      branch: 'main'
    work_dir: '/tmp/ee-containers'

  vars_prompt:
    - name: rh_username
      prompt: "Enter your Red Hat CDN username"
      private: false
    - name: rh_password
      prompt: "Enter your Red Hat CDN password"
      private: true
    - name: automation_hub_token
      prompt: "Enter your Automation Hub token from https://console.redhat.com/ansible/automation-hub/token (or press enter to skip)"
      private: true
    - name: galaxy_token
      prompt: "Enter your Galaxy token from https://galaxy.ansible.com/ui/token (or press enter to skip)"
      private: true
      default: ""

  pre_tasks:
    - name: Verify internet connectivity
      ansible.builtin.uri:
        url: https://google.com
        method: GET
      register: connectivity_check
      failed_when: connectivity_check.status != 200
      changed_when: false

    - name: Fail if no internet connection is detected
      ansible.builtin.fail:
        msg: "No internet connection detected."
      when: connectivity_check.status != 200

    - name: Install prerequisites
      tags: [setup, packages]
      vars:
        packages:
          - python3-pip
          - ansible-core
          - git
          - podman
          - ansible-dev-tools
          - podman-docker
          - podman-compose
          - podman-plugins
          - podman-remote
          - yum-utils
      block:
        - name: Install required packages
          ansible.builtin.package:
            name: "{{ packages }}"
            state: present

    - name: Do dnf upgrade all packages
      ansible.builtin.dnf:
        name: '*'
        state: latest

    - name: Ensure container policy directory exists
      ansible.builtin.file:
        path: /etc/containers/policy.d
        state: directory
        mode: '0755'

    - name: Create container policy file
      ansible.builtin.copy:
        dest: /etc/containers/policy.d/default.json
        mode: '0644'
        content: |
          {
            "default": [{"type": "reject"}],
            "transports": {
              "docker": {
                "registry.redhat.io": [{"type": "insecureAcceptAnything"}],
                "registry.access.redhat.com": [{"type": "insecureAcceptAnything"}],
                "quay.io": [{"type": "insecureAcceptAnything"}],
                "docker.io": [{"type": "insecureAcceptAnything"}]
              }
            }
          }

    - name: Check directories
      ansible.builtin.stat:
        path: "{{ item }}"
      loop:
        - environments
        - /tmp/ee-containers/environments
        - environments/.git
        - /tmp/ee-containers/environments/.git
        - /etc/containers/policy.d/
      register: dir_checks

    - name: Check if local environments directory exists
      ansible.builtin.stat:
        path: environments
      register: local_environments_dir

    - name: Check if local environments directory is empty
      ansible.builtin.find:
        paths: environments
        recurse: false
      register: local_environments_dir_content
      when: local_environments_dir.stat.exists

    - name: Ensure /tmp/ee-containers/environments directory exists
      ansible.builtin.file:
        path: /tmp/ee-containers/environments
        state: directory
        mode: '0755'

    - name: Check if /tmp/ee-containers/environments directory exists
      ansible.builtin.stat:
        path: /tmp/ee-containers/environments
      register: environments_dir

    - name: Check if /tmp/ee-containers/environments directory is empty
      ansible.builtin.find:
        paths: /tmp/ee-containers/environments
        recurse: false
      register: environments_dir_content
      when: environments_dir.stat.exists

    - name: Check if /tmp/ee-containers/environments is a git repository
      ansible.builtin.stat:
        path: /tmp/ee-containers/environments/.git
      register: git_repo_exists

    - name: Remove existing directory if it's not a git repository
      ansible.builtin.file:
        path: /tmp/ee-containers/environments
        state: absent
      when: environments_dir.stat.exists and not git_repo_exists.stat.exists

    - name: Clone or update GitHub repository
      ansible.builtin.git:
        repo: 'https://github.com/cloin/ee-builds.git'
        dest: /tmp/ee-containers/environments/
        version: 'main'
        clone: true
        update: true
        force: true
      when: not environments_dir.stat.exists or not git_repo_exists.stat.exists or environments_dir_content.matched == 0

    - name: Check if repository is already cloned in current directory
      ansible.builtin.stat:
        path: environments/.git
      register: repo_cloned_local

    - name: Clone GitHub repository to current directory if not already cloned
      ansible.builtin.git:
        repo: 'https://github.com/cloin/ee-builds.git'
        dest: environments/
        version: 'main'  # Specify the branch or commit
        clone: true
        update: true
        force: true
      when: not repo_cloned_local.stat.exists and not local_environments_dir.stat.exists

    - name: Install required collections
      ansible.builtin.command:
        cmd: ansible-galaxy collection install community.general
      changed_when: false

  tasks:
    - name: Ensure tmux is installed
      ansible.builtin.package:
        name: tmux
        state: present

    - name: Check if tmux session exists
      ansible.builtin.command:
        cmd: tmux has-session -t podman_watch
      register: tmux_session_check
      failed_when: false
      changed_when: false

    - name: Start tmux session and run watch command
      ansible.builtin.command:
        cmd: tmux new-session -d -s podman_watch 'watch -n .5 podman images'
      when: tmux_session_check.rc != 0
      async: 1
      poll: 0
      register: tmux_session
      changed_when: false

    - name: Check if already logged in to registries
      ansible.builtin.command:
        cmd: "podman login -u {{ rh_username }} -p {{ rh_password }} {{ item }}"
        creates: "/root/.config/containers/auth.json"
      loop:
        - registry.redhat.io
        - console.redhat.com
        - registry.access.redhat.com
        - quay.io
        - registry.connect.redhat.com
      register: login_result
      failed_when:
        - login_result.rc != 0
        - item != 'console.redhat.com'  # Ignore failures for console.redhat.com
      ignore_errors: "{{ item == 'console.redhat.com' }}"  # Only ignore errors for console.redhat.com
      no_log: true

    - name: Check if required container images exist
      ansible.builtin.command:
        cmd: "podman image exists {{ item }}"
      loop:
        - registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel8
        - registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel9
        - registry.redhat.io/ansible-automation-platform-25/de-supported-rhel8
        - registry.redhat.io/ansible-automation-platform-25/de-supported-rhel9
        - registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel8
        - registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel9
        - registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel8
        - registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel9
      register: image_check_results
      changed_when: false
      failed_when: false


    - name: Pull missing container images
      ansible.builtin.command:
        cmd: "podman pull {{ item.item }}"
      loop: "{{ image_check_results.results }}"
      when: item.rc != 0
      register: pull_results
      changed_when: "'Downloaded newer image' in pull_results.stdout"
      retries: 3
      delay: 5
      until: pull_results is success
      notify: Display pulled images status

    - name: Clean up unused images and build artifacts
      block:
        - name: Create consolidated protected images list
          ansible.builtin.set_fact:
            protected_images: >-
              {{
                [
                  'registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel8:latest',
                  'registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel9:latest',
                  'registry.redhat.io/ansible-automation-platform-25/de-supported-rhel8:latest',
                  'registry.redhat.io/ansible-automation-platform-25/de-supported-rhel9:latest',
                  'registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel8:latest',
                  'registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel9:latest',
                  'registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel8:latest',
                  'registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel9:latest'
                ] + (selected_environments | default([]))
              }}

        - name: Check if cleanup script template exists
          ansible.builtin.stat:
            path: templates/image_cleanup.sh.j2
          register: cleanup_template

        - name: Create cleanup script
          ansible.builtin.template:
            src: templates/image_cleanup.sh.j2
            dest: /tmp/image_cleanup.sh
            mode: '0755'
            validate: bash -n %s
          when: cleanup_template.stat.exists

        - name: Execute image cleanup
          ansible.builtin.command:
            cmd: /tmp/image_cleanup.sh
          register: cleanup_result
          changed_when: cleanup_result.rc == 0
          when: cleanup_template.stat.exists

        - name: Remove cleanup script
          ansible.builtin.file:
            path: /tmp/image_cleanup.sh
            state: absent
          when: cleanup_template.stat.exists

        - name: Display cleanup summary
          ansible.builtin.debug:
            msg: "Image cleanup completed successfully"
          when: cleanup_result.rc == 0 and cleanup_template.stat.exists

        - name: Debug cleanup removal
          ansible.builtin.debug:
            var: cleanup_result
            verbosity: 1
          when: cleanup_result.failed is defined and cleanup_template.stat.exists

      rescue:
        - name: Handle cleanup failure
          ansible.builtin.debug:
            msg: "Image cleanup failed: {{ cleanup_result.stderr | default('Unknown error') }}"

      always:
        - name: Ensure cleanup script is removed
          ansible.builtin.file:
            path: /tmp/cleanup_images.sh
            state: absent
          register: cleanup_result
          failed_when:
            - cleanup_result.failed is defined
            - cleanup_result.failed
            - '"Permission denied" not in cleanup_result.msg'

    - name: Check if requirements.txt exists
      ansible.builtin.stat:
        path: /tmp/ee-containers/files/requirements.txt
      register: requirements_txt

    - name: Install Python packages from requirements.txt if it exists
      ansible.builtin.pip:
        requirements: /tmp/ee-containers/files/requirements.txt
      when: requirements_txt.stat.exists

    - name: Check if requirements.yml exists
      ansible.builtin.stat:
        path: /tmp/ee-containers/files/requirements.yml
      register: requirements_yml

    - name: Install ansible-galaxy collections from requirements.yml if it exists
      ansible.builtin.command:
        cmd: "ansible-galaxy collection install -r /tmp/ee-containers/files/requirements.yml"
        creates: "/root/.ansible/collections/ansible_collections"
      when: requirements_yml.stat.exists
      failed_when: requirements_yml.rc != 0

    - name: Ensure /tmp/ee-containers/_build/configs directory exists
      ansible.builtin.file:
        path: /tmp/ee-containers/_build/configs
        state: directory
        mode: '0755'

    - name: Create ansible.cfg in /tmp/ee-containers/_build/configs
      ansible.builtin.copy:
        src: /home/sgallego/ee-containers/ansible.cfg
        dest: /tmp/ee-containers/_build/configs/ansible.cfg
        mode: '0644'

    - name: Copy ansible.cfg to build context
      ansible.builtin.copy:
        src: /tmp/ee-containers/_build/configs/ansible.cfg
        dest: /etc/ansible/ansible.cfg
        mode: '0644'
        remote_src: true
      become: true

    - name: Verify DNS resolution
      ansible.builtin.command:
        cmd: "nslookup {{ item }}"
      loop:
        - github.com
        - cdn-ubi.redhat.com
        - galaxy.ansible.com
      register: dns_checks
      changed_when: false
      failed_when: dns_checks.rc != 0

    - name: Set DNS servers for Podman
      ansible.builtin.copy:
        dest: /etc/containers/registries.conf
        content: |
          [registries.search]
          registries = ['docker.io', 'quay.io', 'registry.fedoraproject.org', 'registry.access.redhat.com', 'registry.redhat.io']

          [registries.insecure]
          registries = []

          [registries.block]
          registries = []

          [registries]
          registries = ['docker.io', 'quay.io', 'registry.fedoraproject.org', 'registry.access.redhat.com', 'registry.redhat.io']

          [engine]
          dns_servers = ['8.8.8.8', '8.8.4.4']
        mode: '0644'

    - name: Build a numeric menu for the user to select environment
      block:
        - name: Find environment directories
          ansible.builtin.find:
            paths: "environments/"
            patterns: "*-*e-*"  # Matches both ee and de
            recurse: false
            file_type: directory
          register: found_dirs

        - name: Sort environment directories
          ansible.builtin.set_fact:
            environment_mapping: "{{ found_dirs.files | map(attribute='path') | map('basename') | list | sort }}"

        - name: Display menu options
          ansible.builtin.debug:
            msg: |
              Available environments:
              {% for env in environment_mapping %}
              {{ loop.index }}. {{ env }}
              {% endfor %}

        - name: Prompt user for environment selection
          ansible.builtin.pause:
            prompt: |
              Enter numbers for environments to build (comma-separated, max {{ environment_mapping | length }}):
              {% for env in environment_mapping %}
              {{ loop.index }}. {{ env }}
              {% endfor %}
          register: user_selection

        - name: Parse selections
          ansible.builtin.set_fact:
            selection_numbers: "{{ user_selection.user_input.split(',') | map('trim') | map('int') | list }}"

        - name: Map selections to environments
          ansible.builtin.set_fact:
            selected_environments: >-
              {%- set result = [] -%}
              {%- for num in selection_numbers -%}
                {%- set index = (num | int) - 1 -%}
                {%- if index >= 0 and index < environment_mapping | length -%}
                  {{- result.append(environment_mapping[index]) -}}
                {%- endif -%}
              {%- endfor -%}
              {{ result }}

        - name: Validate selections
          ansible.builtin.assert:
            that:
              - "selection_numbers | length > 0"
              - "selection_numbers | min > 0"
              - "selection_numbers | max <= environment_mapping | length"
            fail_msg: "Invalid selection. Choose numbers between 1 and {{ environment_mapping | length }}"

        - name: Display selected environments
          ansible.builtin.debug:
            msg: |
              Selected environments to build:
              {% for env in selected_environments %}
              - {{ env }}
              {% endfor %}

    - name: Process each selected environment
      block:
        - name: Ensure build directories exist
          ansible.builtin.file:
            path: "{{ item }}"
            state: directory
            mode: '0755'
          loop:
            - "{{ work_dir }}/files"
            - "{{ work_dir }}/_build"
            - "{{ work_dir }}/context"

        - name: Set correct ownership for build directories
          ansible.builtin.file:
            path: "{{ item }}"
            state: directory
            recurse: true
            owner: "{{ ansible_user_id }}"
            group: "{{ ansible_user_id }}"
          loop:
            - "{{ work_dir }}/files"
            - "{{ work_dir }}/_build"
            - "{{ work_dir }}/context"
          become: true

      rescue:
        - name: Display build error
          ansible.builtin.debug:
            msg: |
              Build failed for {{ current_env }}:
              STDOUT:
              {{ build_output.stdout_lines | default([]) | to_nice_yaml }}
              STDERR:
              {{ build_output.stderr_lines | default([]) | to_nice_yaml }}

      always:
        - name: Clean up build directories
          ansible.builtin.file:
            path: "{{ item }}"
            state: absent
          loop:
            - "{{ work_dir }}/_build"
            - "{{ work_dir }}/context"
          ignore_errors: true

    - name: Include build environment tasks
      include_tasks: tasks/build_environment.yml
      loop: "{{ selected_environments }}"
      loop_control:
        loop_var: current_env
      vars:
        current_env: "{{ current_env }}"

    - name: Handle build result
      block:
        - name: Check if image exists
          ansible.builtin.command:
            cmd: "podman image exists {{ current_env }}"
          register: image_exists
          changed_when: false
          failed_when: false

        - name: Stop and remove containers using the image
          ansible.builtin.command:
            cmd: >-
              podman ps -a --filter ancestor={{ current_env }} --format "{{ '{{.ID}}' }}" | xargs -r podman rm -f
          ignore_errors: true
          when: image_exists.rc != 0

        - name: Build EE container image
          ansible.builtin.command:
            cmd: >-
              ansible-builder build
              --tag {{ current_env }}
              --container-runtime podman
              --verbosity 2
              --prune-images
              --context {{ work_dir }}/context
              -f {{ playbook_dir }}/environments/{{ current_env }}/execution-environment.yml
          register: build_result
          ignore_errors: true
          when: image_exists.rc != 0
          changed_when: "'Downloaded newer image' in build_result.stdout or 'Successfully built' in build_result.stdout"

        - name: Display build error
          ansible.builtin.debug:
            msg: |
              Build failed with the following output:
              STDOUT:
              {{ build_result.stdout_lines | default([]) | to_nice_yaml }}
              STDERR:
              {{ build_result.stderr_lines | default([]) | to_nice_yaml }}
          when: build_result is failed

        - name: Clean up on build failure
          when: build_result is failed
          block:
            - name: Remove build artifacts
              ansible.builtin.file:
                path: "{{ item }}"
                state: absent
              loop:
                - "{{ selected_env }}/_build"
                - "{{ selected_env }}/Containerfile"

        - name: Fail if build failed
          ansible.builtin.fail:
            msg: "Container build failed. See above for details."
          when: build_result is failed
