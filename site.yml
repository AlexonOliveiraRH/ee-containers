---
# Ansible Automation Platform - Execution Environment Builder
# This playbook builds customized execution environments based on Red Hat AAP base images.
- name: Setup and store credentials
  hosts: localhost
  connection: local
  gather_facts: true
  environment:
    ANSIBLE_LOCALHOST_WARNING: "False" 
    ANSIBLE_DEPRECATION_WARNINGS: "False"
    ANSIBLE_COMMAND_WARNINGS: "False"
    ANSIBLE_SYSTEM_WARNINGS: "False"

  vars:
    container_registries:
      - registry.redhat.io
      - registry.access.redhat.com
      - registry.connect.redhat.com

    required_images:
      - registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel8
      - registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel9
      - registry.redhat.io/ansible-automation-platform-25/de-supported-rhel8
      - registry.redhat.io/ansible-automation-platform-25/de-supported-rhel9
      - registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel8
      - registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel9
      - registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel8
      - registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel9

    protected_images:
      - "registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel9"
      - "registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel9:latest"
      - "registry.redhat.io/ansible-automation-platform-25/de-supported-rhel9"
      - "registry.redhat.io/ansible-automation-platform-25/de-supported-rhel9:latest"
      - "registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel9"
      - "registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel9:latest"
      - "registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel9"
      - "registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel9:latest"
      - "rhel9-de-minimal"
      - "rhel9-de-minimal-cloudstrike"
      - "rhel9-de-supported"
      - "rhel9-ee-minimal"
      - "rhel9-ee-minimal-cloud"
      - "rhel9-ee-minimal-general"
      - "rhel9-ee-minimal-vmware"
      - "rhel9-ee-minimal-windows"
      - "rhel9-ee-supported"
      - "rhel9-ee-supported-vmware"

    dns_servers:
      - '8.8.8.8'
      - '8.8.4.4'

    required_packages:
      - python3-pip
      - ansible-builder
      - ansible-core
      - git
      - podman
      - podman-docker
      - tmux
      - xdg-utils
      - yum-utils

    update_protected_list: true

  tasks:
    - name: Verify internet connectivity  
      ansible.builtin.uri:
        url: https://google.com
        method: GET
      register: connectivity_check
      failed_when: connectivity_check.status != 200  
      changed_when: false
      tags: [connectivity, validation]
      
    # Create static ansible.cfg before any template processing
    - name: Create static ansible.cfg file for initial setup
      ansible.builtin.copy:
        dest: "{{ playbook_dir }}/ansible.cfg"
        mode: '0644'
        force: false  # Don't overwrite if exists
        content: |
          [defaults]
          inventory = localhost,
          ansible_localhost_warning=false
          ansible_deprecation_warnings=false
          force_color = True

          [galaxy]
          server_list = validated, published, galaxy

          [galaxy_server.published]
          url=https://console.redhat.com/api/automation-hub/content/published/
          auth_url=https://sso.redhat.com/auth/realms/redhat-external/protocol/openid-connect/token

          [galaxy_server.validated]
          url=https://console.redhat.com/api/automation-hub/content/validated/
          auth_url=https://sso.redhat.com/auth/realms/redhat-external/protocol/openid-connect/token

          [galaxy_server.galaxy]
          url=https://galaxy.ansible.com/
      tags: [always]

    - name: Create collections requirements file
      ansible.builtin.copy:
        dest: "/tmp/requirements.yml"
        mode: '0644'
        content: |
          ---
          collections:
            - name: ansible.utils
            - name: ansible.posix
            - name: community.general
            - name: infra.aap_configuration
            - name: infra.aap_utilities
      tags: [setup, always, collections]

    - name: Create requirements.txt file
      ansible.builtin.copy:
        dest: "/tmp/requirements.txt"
        mode: '0644'
        content: |
          ansible-builder>=3.0.0
          ansible-core>=2.15.0,<2.16
          ansible-lint>=24.0.0
      tags: [setup, always, collections]

    - name: Create inventory file
      ansible.builtin.copy:
        dest: "/tmp/inventory"
        state: presant
        mode: '0644'
        content: |
          [devnode]
          localhost ansible_connection=localhost
      tags: [always, setup]
     
    - name: Force install community.general collection system-wide
      ansible.builtin.command:
        cmd: "sudo ansible-galaxy collection install community.general ansible.posix -p /usr/share/ansible/collections --force"
      register: galaxy_install
      changed_when: galaxy_install.rc == 0
      failed_when: galaxy_install.rc != 0

    - name: Verify community.general collection installation
      ansible.builtin.command:
        cmd: "ansible-galaxy collection list community.general"
      register: collection_verify
      failed_when: collection_verify.rc != 0

    - name: Show installation path
      ansible.builtin.debug:
        msg: "Collection installed at: {{ collection_verify.stdout_lines | select('search', 'Path:') | first | default('Unknown location') }}"

    # Improved user detection logic
    - name: Get effective and real user info
      ansible.builtin.shell: |
        echo "EUID=$(id -u)"
        if [ -n "$SUDO_USER" ]; then
          echo "SUDO_USER=$SUDO_USER"
          echo "SUDO_UID=$(id -u $SUDO_USER)"
          echo "SUDO_HOME=$(eval echo ~$SUDO_USER)"
        else
          echo "SUDO_USER="
          echo "SUDO_UID="
          echo "SUDO_HOME="
        fi
        echo "USER=$(whoami)"
        echo "HOME=$HOME"
      register: user_info_output
      changed_when: false
      tags: [always]
    
    - name: Parse user info
      ansible.builtin.set_fact:
        parsed_user_info: "{{ dict(user_info_output.stdout_lines | map('regex_replace', '^([^=]+)=(.*)$', '\\1:\\2') | map('split', ':') | list) }}"
      tags: [always]
    
    - name: Set user facts
      ansible.builtin.set_fact:
        is_root: "{{ ansible_user_id == '0' }}"
        actual_user: "{{ ansible_user_id }}"
        user_home: "{{ ansible_env.HOME }}"
      tags: [always]
    
    - name: Set current_user fact
      ansible.builtin.set_fact:
        current_user: "{{ actual_user }}"
    
    - name: Debug user detection
      ansible.builtin.debug:
        msg: |
          User detection results:
          - Effective UID: {{ parsed_user_info.EUID }}
          - Running as root: {{ is_root }}
          - Original user: {{ actual_user }}
          - User home: {{ user_home }}
      tags: [always]

    # Skip credential setup if running as root directly (not via sudo)
    - name: Skip credential setup if running as root directly
      ansible.builtin.set_fact:
        skip_credential_setup: "{{ ansible_user_id == 'root' and lookup('env', 'SUDO_USER') == '' }}"
      tags: [always]

    - name: Show credential setup status
      ansible.builtin.debug:
        msg: "{{ skip_credential_setup | ternary('Running as direct root user - skipping credential setup', 'Setting up credentials for user ' + actual_user) }}"
      tags: [always]

    # Only run credential setup if not skipping
    - name: Setup user credentials
      when: not skip_credential_setup
      block:
        - name: Ensure ansible vars directory exists in user's home
          ansible.builtin.file:
            path: "{{ user_home }}/.ansible/vars"
            state: directory
            mode: '0700'
          tags: [setup, credential_setup]
    
        - name: Check if credentials file exists
          ansible.builtin.stat:
            path: "{{ user_home }}/.ansible/vars/config"
          register: config_file
          tags: [always]
    
        - name: Set first run flag 
          ansible.builtin.set_fact:
            first_run: "{{ not config_file.stat.exists }}"
          tags: [always]
    
        - name: Load stored credentials if they exist
          ansible.builtin.include_vars:
            file: "{{ user_home }}/.ansible/vars/config"
            name: stored_credentials
          when: config_file.stat.exists
          tags: [always]
    
        - name: Request credentials if needed
          block:
            - name: Collect Red Hat CDN username
              ansible.builtin.pause:
                prompt: "Enter your Red Hat CDN username"
                echo: true
              register: rh_username_input
              when: stored_credentials is not defined or stored_credentials.rh_username is not defined
              
            - name: Collect Red Hat CDN password
              ansible.builtin.pause:
                prompt: "Enter your Red Hat CDN password"
                echo: false
              register: rh_password_input
              when: stored_credentials is not defined or stored_credentials.rh_password is not defined
              no_log: true
              
            - name: Collect Automation Hub token
              ansible.builtin.pause:
                prompt: "Enter your Automation Hub token (or press enter to skip)"
                echo: false
              register: automation_hub_token_input
              when: stored_credentials is not defined or stored_credentials.automation_hub_token is not defined
              no_log: true
              
            - name: Collect Galaxy token
              ansible.builtin.pause:
                prompt: "Enter your Galaxy token (or press enter to skip)"
                echo: false
              register: galaxy_token_input
              when: stored_credentials is not defined or stored_credentials.galaxy_token is not defined
              no_log: true
              
            - name: Set collected credential facts
              ansible.builtin.set_fact:
                rh_username: "{{ rh_username_input.user_input | default(stored_credentials.rh_username | default('')) }}"
                rh_password: "{{ rh_password_input.user_input | default(stored_credentials.rh_password | default('')) }}"
                automation_hub_token: "{{ automation_hub_token_input.user_input | default(stored_credentials.automation_hub_token | default('')) }}"
                galaxy_token: "{{ galaxy_token_input.user_input | default(stored_credentials.galaxy_token | default('')) }}"
              no_log: true  # Ensure sensitive data is not logged

            - name: Create credentials file
              ansible.builtin.copy:
                dest: "{{ user_home }}/.ansible/vars/config"
                content: |
                  ---
                  # Ansible EE Builder Configuration - Last updated {{ ansible_date_time.iso8601 }}
                  rh_username: '{{ rh_username }}'
                  rh_password: '{{ rh_password }}'
                  automation_hub_token: '{{ automation_hub_token }}'
                  galaxy_token: '{{ galaxy_token }}'
                mode: '0600'
              no_log: true  # Prevent sensitive data from being logged

            - name: Recreate ansible.cfg in the current ee-containers directory
              ansible.builtin.template:
                src: templates/ansible.cfg.j2
                dest: "{{ playbook_dir }}/ansible.cfg"
                mode: '0644'

            - name: Recreate ansible.cfg in the working directory
              ansible.builtin.template:
                src: templates/ansible.cfg.j2
                dest: "/tmp/ee-containers/_build/ansible.cfg"
                mode: '0644'

            - name: Create ansible.cfg in /tmp/ee-containers/
              ansible.builtin.template:
                src: templates/ansible.cfg.j2
                dest: /tmp/ee-containers/ansible.cfg
                         
            - name: Set proper ownership on credentials file when needed
              ansible.builtin.file:
                path: "{{ user_home }}/.ansible/vars/config"
                owner: "{{ actual_user }}"
                group: "{{ actual_user }}"
                mode: '0600'
              when: actual_user != 'root' and actual_user != ''
              no_log: true  # Ensure no sensitive data is logged
              
            - name: Report stored credentials
              ansible.builtin.debug:
                msg: |
                  ┌────────────────────────────────────────────────────────────────┐
                  │                  CREDENTIALS STORED                            │
                  ├────────────────────────────────────────────────────────────────┤
                  │ Credentials have been stored at: {{ user_home }}/.ansible/vars/config │
                  │ These will be used for future runs.                            │
                  └────────────────────────────────────────────────────────────────┘
              when: not no_log  # Avoid logging sensitive data if no_log is true
          when: first_run or (stored_credentials is not defined)
          tags: [always]

        - name: Set collected credential facts
          ansible.builtin.set_fact:
            rh_username: "{{ stored_credentials.rh_username | default('') }}"
            rh_password: "{{ stored_credentials.rh_password | default('') }}"
            automation_hub_token: "{{ stored_credentials.automation_hub_token | default('') }}"
            galaxy_token: "{{ stored_credentials.galaxy_token | default('') }}"
          no_log: true

    - name: Show run mode
      ansible.builtin.debug:
        msg: |
          ┌────────────────────────────────────────────────────────────────────┐
          │                     RUN MODE INFORMATION                           │
          ├────────────────────────────────────────────────────────────────────┤
          │ {{ "FIRST RUN DETECTED: Running full setup" if first_run | default(false) else "SUBSEQUENT RUN: Using stored configuration" }} │
          │                                                                    │
          │ User: {{ actual_user | default('Unknown') }}                                            │
          │ Credentials: {{ "New" if first_run | default(false) else "Loaded from file" }}      │
          └────────────────────────────────────────────────────────────────────┘
      tags: [always]

    # Use sudo_user's home directory for config in the main play
    - name: Set config path for main play
      ansible.builtin.set_fact:
        config_path: "{{ user_home }}/.ansible/vars/config"
      tags: [always]

# Play 2: Display title and introduction
- name: Display title screen
  hosts: localhost
  connection: local
  gather_facts: false
  environment:
    ANSIBLE_LOCALHOST_WARNING: "False" 
    ANSIBLE_DEPRECATION_WARNINGS: "False"
    ANSIBLE_COMMAND_WARNINGS: "False"
    ANSIBLE_SYSTEM_WARNINGS: "False"
  tasks:
    - name: Show ascii title
      ansible.builtin.debug:
        msg: |
          ┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
          │                                                                                      ..:-=@@@@=-:..          │
          │                                                                                    .*%@@@@@@@@@@@@%*.        │
          │                                                                                 .:@@@@@@@@@@@@@@@@@@@@:.     │
          │                                                                                .*@@@@@@@@@@*-@@@@@@@@@@*.    │
          │                                                                               .@@@@@@@@@@@*. =@@@@@@@@@@@.   │
          │                                                                              .%@@@@@@@@@@@ .@ +@@@@@@@@@@%.  │
          │                                                                              -%@@@@@@@@@@..@%-.*@@@@@@@@@%-  │
          │     "A Streamlined Approach to Building Ansible Execution Environments"     .+@@@@@@@@@@= =@@@.:@@@@@@@@@@+. │
          │                                                                             .+@@@@@@@@@@ ..:+@%.-@@@@@@@@@+. │
          │                                                                             .=@@@@@@@@@ .@@+. *+.-@@@@@@@%=  │
          │                                                                              .%@@@@@@@:.*@@@@%.  .+@@@@@@%.  │
          │                                                                               .@@@@@@= =@@@@@@@%=.:%@@@@@.   │
          │                                                                                :%@@@@@@@@@@@@@@@@@@@@@@%:    │
          │                                                                                 .*@@@@@@@@@@@@@@@@@@@@*.     │
          │                                                                                   .+@@@@@@@@@@@@@@@@+..      │
          │                                                                                     ..+*%@@@@@@%*+..         │
          └──────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
      tags: [always]

    - name: Title screen
      ansible.builtin.pause:
        seconds: 3
      tags: [always]

# Play 2: Environment Selection
- name: Environment Selection
  hosts: localhost
  connection: local
  gather_facts: false
  tasks:
    - name: Prompt for distribution selection
      ansible.builtin.pause:
        prompt: |
          Please select the distribution:
          Enter '8' for RHEL 8, '9' for RHEL 9, or 'all' for both
      register: user_input

    - name: Set distribution_selection based on user input
      ansible.builtin.set_fact:
        distribution_selection: "{{ user_input.user_input }}"
      when: user_input.user_input is defined

    - name: Set default values for build_rhel8 and build_rhel9
      ansible.builtin.set_fact:
        build_rhel8: false
        build_rhel9: false
      when: build_rhel8 is not defined or build_rhel9 is not defined

    - name: Filter available environments based on distribution selection
      block:
        - name: Get all available environments
          ansible.builtin.find:
            paths: "environments"
            file_type: directory
          register: all_environments

        - name: Process environments for filtering
          ansible.builtin.set_fact:
            rhel8_environments: "{{ all_environments.files | selectattr('path', 'search', 'rhel8') | rejectattr('path', 'search', '\\.bak$') | map(attribute='path') | list }}"
            rhel9_environments: "{{ all_environments.files | selectattr('path', 'search', 'rhel9') | rejectattr('path', 'search', '\\.bak$') | map(attribute='path') | list }}"
            neutral_environments: "{{ all_environments.files | rejectattr('path', 'search', 'rhel[89]') | rejectattr('path', 'search', '\\.bak$') | map(attribute='path') | list }}"

        - name: Set available environments based on distribution selection
          ansible.builtin.set_fact:
            available_environments: >-
              {{
                (distribution_selection == '8') | ternary(rhel8_environments, []) +
                (distribution_selection == '9') | ternary(rhel9_environments, []) +
                (distribution_selection == 'all') | ternary(rhel8_environments + rhel9_environments, []) +
                neutral_environments
              }}

    - name: Display environment selection menu header
      ansible.builtin.debug:
        msg: |
          **************************************************
          ENVIRONMENT SELECTION MENU

          Selected distribution: RHEL {{ distribution_selection }}

          Available environments:
          {% for env in available_environments %}
          {{ loop.index }}. {{ env | basename }}
          {% endfor %}
          **************************************************

    - name: Prompt for environment selection
      ansible.builtin.pause:
        prompt: |
          **************************************************
          ENVIRONMENT SELECTION MENU

          Selected distribution: RHEL {{ distribution_selection }}

          Available environments:
          {% for env in available_environments %}
          {{ loop.index }}. {{ env | basename }}
          {% endfor %}
          **************************************************

          Enter numbers for environments to build (comma-separated, max {{ available_environments | length }}):
          Enter 'all' to select all environments
          Enter 'q' to quit without selecting:
      register: user_input

    - name: Parse user input for environment selection
      ansible.builtin.set_fact:
        selected_environments: >-
          {{
            available_environments if user_input.user_input == 'all' else
            available_environments | zip(range(1, available_environments | length + 1)) |
            selectattr(1, 'in', user_input.user_input.split(',')) |
            map(attribute=0) | list
          }}
      vars:
        user_input: "{{ user_input.user_input | default('') }}"

    - name: Set basename for the selected environment
      ansible.builtin.set_fact:
        basename: "{{ selected_environments | first | basename }}"
      when: selected_environments | length > 0

    - name: Debug selected basename
      ansible.builtin.debug:
        msg: "Selected environment basename: {{ basename }}"

    - name: Debug selected environments
      ansible.builtin.debug:
        var: selected_environments

    - name: Debug work_dir
      ansible.builtin.debug:
        msg: "Work directory: Not yet defined (will be set during processing)"
      when: work_dir is not defined

    - name: Debug selected basename
      ansible.builtin.debug:
        msg: "Selected basename: {{ item | basename }}"
      loop: "{{ selected_environments }}"
      when: selected_environments is defined and selected_environments | length > 0

    - name: Kill existing monitoring tmux session (if any)
      ansible.builtin.command: tmux has-session -t podman-monitor
      register: tmux_monitor_check
      changed_when: false
      failed_when: false

    - name: Close existing monitoring tmux session
      ansible.builtin.shell: tmux kill-session -t podman-monitor
      when: tmux_monitor_check.rc == 0
      changed_when: true

    - name: Create scripts directory
      ansible.builtin.file:
        path: "{{ playbook_dir }}/scripts"
        state: directory
        mode: '0755'
      tags: [setup, monitoring]

    - name: Clean up dangling images
      ansible.builtin.command:
        cmd: podman images | awk '$1=="<none>" {print $3}' | xargs podman rmi --force
      register: prune_output
      changed_when: "'Total reclaimed space:' in prune_output.stdout and not 'Total reclaimed space: 0B' in prune_output.stdout"
      ignore_errors: true
      failed_when: false

    - name: Create Podman monitoring script
      ansible.builtin.copy:
        dest: "{{ playbook_dir }}/scripts/start_monitor.sh"
        content: |
          #!/bin/bash
          
          # Kill existing session if it exists
          if tmux has-session -t podman-monitor 2>/dev/null; then
            tmux kill-session -t podman-monitor
            pkill -f "tmux" || true
            sleep 1
          fi
          
          # Create basic session with forced dimensions
          tmux new-session -d -s podman-monitor
          
          # IMPORTANT: First split into top and bottom
          # Then split the top portion to create the middle line
          # This approach gives better control over the middle pane height
          tmux split-window -t podman-monitor:0.0 -v -p 60  # Bottom pane is 60% of the screen
          tmux split-window -t podman-monitor:0.0 -v -l 1   # Middle pane is exactly 1 line tall
          
          # Create initial status file with default message
          echo "NOTHING BUILDING YET" > /tmp/current_env
          
          # Now we have:
          # podman-monitor:0.0 - Top pane (header)
          # podman-monitor:0.1 - Middle pane (build info - exactly one line)
          # podman-monitor:0.2 - Bottom pane (podman images)
          
          # Configure the top pane with ASCII art header (pane 0)
          tmux select-pane -t podman-monitor:0.0
          tmux send-keys -t podman-monitor:0.0 "clear; cat << 'EOF'

          Starting Podman monitoring...
          

                            ●●●●●●●
                           ●●●●●●●●●
                          ●●●●●●●●●●●
                         ●●●●●  ●●●●●●
              ╔═════════●●●●●════●●●●●●════════════════════════════════════════════════════╗
              ║        ●●●●●      ●●●●●●                                                   ║
              ║       ●●●●●        ●●●●●●                                                  ║
              ║      ●●●●●          ●●●●●●                                                 ║
              ║     ●●●●●●           ●●●●●●●                                               ║
              ║    ●●●●●●              ●●●●●●                                              ║
              ║   ●●●●●●●●●             ●●●●●●                                             ║
              ║  ●●●●●● ●●●●●●●●         ●●●●●●                                            ║
              ║ ●●●●●●      ●●●●●●●       ●●●●●● ANSIBLE & PODMAN                          ║
              ╠●●●●●●══════════●●●●●●●════●●●●●●●══════════════════════════════════════════╣
              ●●●●●●              ●●●●●●●●●●●●●●● EXECUTION BUILD MONITOR                  ║
            ●●●●●●══════════════════●●●●●●●●●●●●═══════════════════════════════════════════╝
          ●●●●●●●
          EOF
          " C-m
          
          # Configure middle pane for Build info with progress spinner (pane 1) - exactly one line
          tmux select-pane -t podman-monitor:0.1
          tmux send-keys -t podman-monitor:0.1 "
          while true; do
            BUILDING_FILE=/tmp/current_env
            if [ -f \"\$BUILDING_FILE\" ]; then
              BUILDING_ENV=\$(cat \"\$BUILDING_FILE\")
              
              # Default output with no spinner
              OUTPUT=\"\$BUILDING_ENV\"
              
              # Check if this is an active build (not SKIPPED, COMPLETED, or default message)
              if [[ \"\$BUILDING_ENV\" != \"SKIPPED\"* && 
                    \"\$BUILDING_ENV\" != \"COMPLETED\"* && 
                    \"\$BUILDING_ENV\" != \"NOTHING BUILDING YET\" ]]; then
                # Add spinner only for active builds
                SPINNER_CHARS=(\"|\" \"/\" \"-\" \"\\\\\")
                SPINNER_INDEX=\$(( (SECONDS / 1) % 4 ))
                SPINNER=\${SPINNER_CHARS[\$SPINNER_INDEX]}
                
                # Format with 'Building:' prefix and spinner suffix
                OUTPUT=\"Building: \$BUILDING_ENV \${SPINNER}\"
              fi
              
              # Clear line and print output
              clear
              printf \" %s\" \"\$OUTPUT\"
            else
              # Fallback if file doesn't exist
              clear
              printf \" NOTHING BUILDING YET\"
            fi
            sleep 0.5
          done
          " C-m
          
          # Configure bottom pane for podman images with continuous update
          tmux select-pane -t podman-monitor:0.2
          tmux send-keys -t podman-monitor:0.2 "watch -n 0.5 'podman images | (echo \"REPOSITORY                            TAG       IMAGE ID      CREATED       SIZE\" && echo \"--------------------------------------------------------------------------------------------\" && grep -v \"REPOSITORY\")'" C-m
          
          # Now, let's attach to the session rather than detaching from it
          tmux attach -t podman-monitor
        mode: '0755'

    - name: Make script executable
      ansible.builtin.file:
        path: "{{ playbook_dir }}/scripts/start_monitor.sh"
        mode: '0755'
      
    - name: Kill any existing tmux session
      ansible.builtin.shell: |
        if tmux has-session -t podman-monitor 2>/dev/null; then
          tmux kill-session -t podman-monitor
        fi
      changed_when: true
      failed_when: false

    - name: Launch monitoring in terminal window
      ansible.builtin.shell: >
        nohup {{ playbook_dir }}/scripts/start_monitor.sh > /tmp/monitor.log 2>&1 &
      args:
        executable: /bin/bash
      register: term_launch
      changed_when: true
      ignore_errors: true
      tags: [monitoring]

    - name: Show terminal launch status
      ansible.builtin.debug:
        msg: "Monitoring launched in terminal: {{ term_launch.stdout }}"
      when: term_launch is not skipped
      tags: [monitoring]

    - name: Show monitoring script location
      ansible.builtin.debug:
        msg: "Monitoring script location: {{ playbook_dir }}/scripts/start_monitor.sh"
      tags: [monitoring]

    - name: Try to open terminal with tmux session
      ansible.builtin.shell: |
        for term in gnome-terminal konsole xfce4-terminal terminator xterm; do
          if command -v $term >/dev/null 2>&1; then
            case $term in
              gnome-terminal)
                $term -- tmux attach -t podman-monitor &
                ;;
              *)
                $term -e "tmux attach -t podman-monitor" &
                ;;
            esac
            echo "Opened terminal: $term"
            exit 0
          fi
        done
        echo "No suitable terminal found"
      register: term_open
      ignore_errors: true
      changed_when: term_open.stdout is search("Opened terminal")

- name: Registry Authentication
  hosts: localhost
  connection: local
  gather_facts: false
  vars:
    container_registries:
      - registry.redhat.io
      - registry.access.redhat.com
      - registry.connect.redhat.com
  tasks:
    - name: Verify Podman is working properly
      ansible.builtin.command:
        cmd: >-
          {% raw %}podman info --format '{{ .Store.GraphDriverName }}'{% endraw %}
      environment:
        PODMAN_IGNORE_CGROUPSV1_WARNING: "1"
      register: podman_check
      failed_when: podman_check.rc != 0
      tags: [podman, validation]

    - name: Load Automation Hub token from config
      ansible.builtin.include_vars:
        file: "{{ ansible_env.HOME }}/.ansible/vars/config"
      ignore_errors: true

    - name: Check if the config file exists
      ansible.builtin.stat:
        path: "{{ ansible_env.HOME }}/.ansible/vars/config"
      register: config_file

    - name: Load variables from config file
      ansible.builtin.include_vars:
        file: "{{ ansible_env.HOME }}/.ansible/vars/config"
      when: config_file.stat.exists
      no_log: true

    - name: Set default value for container_registries
      ansible.builtin.set_fact:
        container_registries: "{{ container_registries | default(['registry.redhat.io', 'registry.access.redhat.com', 'quay.io', 'registry.connect.redhat.com']) }}"

    - name: Login to each container registry
      ansible.builtin.command:
        cmd: "podman login -u {{ rh_username }} -p {{ rh_password }} {{ item }}"
      loop: "{{ container_registries }}"
      register: registry_login_results
      no_log: true

    - name: Initialize registry login success
      ansible.builtin.set_fact:
        registry_login_success: false

    - name: Process registry login results
      ansible.builtin.set_fact:
        registry_login_success: >-
          {{ registry_login_success or
              (item.item != 'quay.io' and item.rc == 0) }}
        registry_login_results: "{{ registry_login_results | combine({item.item: (item.rc == 0)}) }}"
      loop: "{{ registry_login_results.results }}"
      loop_control:
        label: "{{ item.item }}"
      no_log: true

    - name: Display registry login results
      ansible.builtin.debug:
        msg: |
          Registry Authentication Results:
          {% for registry, success in registry_login_results.items() %}
          - {{ registry }}: {{ 'SUCCESS' if success else 'FAILED' }}
          {% endfor %}

    - name: Fail if authentication failed for all critical registries
      ansible.builtin.fail:
        msg: |
          CRITICAL ERROR: Failed to authenticate with any required container registries.
          Authentication to at least one Red Hat registry is required for this playbook to function.
          Please check your Red Hat credentials and network connectivity.
      when: not registry_login_success

# Play 3: Build Execution Environments
- name: Build Execution Environments
  hosts: localhost
  connection: local
  gather_facts: false
  tasks:
    - name: Initialize build_results
      ansible.builtin.set_fact:
        build_results: []
        cacheable: true  # This makes the variable available across plays

    - name: Ensure /tmp/ee-builder/context directory exists
      ansible.builtin.file:
        path: "/tmp/ee-builder/context"
        state: directory
        mode: '0755'

    - name: Ensure /tmp/ee-builder/context/environments directory exists
      ansible.builtin.file:
        path: "/tmp/ee-builder/context/environments"
        state: directory
        mode: '0755'
        
    - name: Ensure consistent path structures
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        mode: '0755'
      loop:
        - "/tmp/ee-builder"
        - "/tmp/ee-builder/context"
        - "/tmp/ee-builder/context/environments"

    - name: Ensure /tmp/ee-containers/_build/environments directory exists
      ansible.builtin.file:
        path: "/tmp/ee-containers/_build/environments"
        state: directory
        mode: '0755'
      tags: [setup, build]

    - name: Ensure tasks/ folder exists in the playbook directory
      ansible.builtin.file:
        path: "{{ playbook_dir }}/tasks"
        state: directory
        mode: '0755'

    - name: Create process_environment.yml dynamically in tasks/ folder
      ansible.builtin.copy:
        dest: "{{ playbook_dir }}/tasks/process_environment.yml"
        content: |
          - name: Set work_dir for the current environment
            ansible.builtin.set_fact:
              work_dir: "/tmp/ee-builder/context/environments/{{ '{{' }} item | basename {{ '}}' }}"
              build_context: "/tmp/ee-builder/context/environments/{{ '{{' }} item | basename {{ '}}' }}"
          
          - name: Debug work_dir
            ansible.builtin.debug:
              msg: "Work directory: {{ '{{' }} work_dir {{ '}}' }}"
            
          - name: Create work_dir for the current environment
            ansible.builtin.file:
              path: "{{ '{{' }} work_dir {{ '}}' }}"
              state: directory
              mode: '0755'

          # Show that we're starting to build this environment in the monitoring display
          - name: Update build status file - starting build
            ansible.builtin.shell: "BASENAME=$(basename {{ '{{' }} item {{ '}}' }}) && echo $BASENAME > /tmp/current_env"
            changed_when: false
          
          - name: Copy selected environment to work_dir
            ansible.builtin.copy:
              src: "{{ '{{' }} item {{ '}}' }}"
              dest: "{{ '{{' }} work_dir {{ '}}' }}"
              remote_src: true

          - name: Validate execution-environment.yml syntax
            ansible.builtin.command:
              cmd: "python3 -c \"import yaml; yaml.safe_load(open('{{ '{{' }} work_dir {{ '}}' }}/execution-environment.yml'));\""
            register: yaml_validation
            changed_when: false
            failed_when: false

          # Handle YAML validation failures
          - name: Handle YAML validation failures
            when: yaml_validation.rc != 0
            block:
              - name: Update build status file - skipping build due to YAML error
                ansible.builtin.shell: "BASENAME=$(basename {{ '{{' }} item {{ '}}' }}) && echo SKIPPED: $BASENAME \\(invalid YAML\\) > /tmp/current_env"
                changed_when: false
                
              - name: Debug skip message
                ansible.builtin.debug:
                  msg: "SKIPPING BUILD due to invalid YAML in execution-environment.yml"
                  
              - name: Record skipped build in results
                ansible.builtin.set_fact:
                  build_results: "{{ '{{' }} build_results | default([]) + [{'image': item | basename, 'success': false, 'output': {'rc': 1, 'stderr': 'Invalid YAML syntax in execution-environment.yml', 'stderr_lines': ['Invalid YAML syntax in execution-environment.yml']}}] {{ '}}' }}"
                  cacheable: true
                changed_when: false
                
              - name: Skip remaining tasks for this environment
                ansible.builtin.meta: end_play
                  
          # Only run build if YAML validation passed
          - name: Build container image using ansible-builder
            ansible.builtin.command:
              cmd: >
                ansible-builder build
                --tag {{ '{{' }} item | basename {{ '}}' }}
                --container-runtime podman
                --verbosity 3
                --prune-images
                --context {{ '{{' }} build_context {{ '}}' }}
                -f {{ '{{' }} build_context {{ '}}' }}/execution-environment.yml
                --build-arg AH_TOKEN="{{ '{{' }} automation_hub_token {{ '}}' }}"
            args:
              chdir: "{{ '{{' }} build_context {{ '}}' }}"
            environment:
              ANSIBLE_BUILDER_HOME: "{{ '{{' }} build_context {{ '}}' }}"
              PODMAN_IGNORE_CGROUPSV1_WARNING: 1
            register: build_output
            changed_when: build_output.rc == 0
            # Don't make this task fail, we'll handle failures later
            failed_when: false
        mode: '0644'

    - name: Copy environment directories to /tmp/ee-builder/context
      ansible.builtin.copy:
        src: "{{ playbook_dir }}/environments"
        dest: "/tmp/ee-builder/context"
        remote_src: true
        mode: '0755'

    - name: Copy environment directories to _build directory
      ansible.builtin.copy:
        src: "{{ playbook_dir }}/environments"
        dest: "/tmp/ee-containers/_build"
        remote_src: true
        mode: '0755'
      tags: [setup, build]

    - name: Debug copied environments
      ansible.builtin.debug:
        msg: "Environment directories copied to /tmp/ee-builder/context"

    - name: Check if image already exists for each selected environment
      ansible.builtin.command:
        cmd: "podman image exists {{ item | basename }}"
      loop: "{{ selected_environments }}"
      register: existing_images
      changed_when: false
      failed_when: false

    - name: Filter images that do not exist
      ansible.builtin.set_fact:
        missing_environment_images: "{{ existing_images.results | selectattr('rc', 'ne', 0) | map(attribute='item') | list }}"

    - name: Show "NOTHING BUILDING YET"
      ansible.builtin.debug:
        msg: "NOTHING BUILDING YET"

    - name: Process each selected environment (skip images already present)
      ansible.builtin.include_tasks: "{{ playbook_dir }}/tasks/process_environment.yml"
      loop: "{{ missing_environment_images }}"
      loop_control:
        label: "{{ item | basename }}"

    - name: Copy execution-environment.yml to the build context
      ansible.builtin.copy:
        src: "{{ playbook_dir }}/environments/{{ basename }}/execution-environment.yml"
        dest: "{{ work_dir }}/context/execution-environment.yml"
        remote_src: true
      tags: [setup, build]

    - name: Copy ansible.cfg to build context
      ansible.builtin.template:
        src: templates/ansible.cfg.j2
        dest: "/tmp/ee-builder/context/environments/{{ basename }}/ansible.cfg"

    - name: Show "BUILD COMPLETE"
      ansible.builtin.debug:
        msg: "BUILD COMPLETE"

    - name: Enable verbose ansible-builder output
      ansible.builtin.set_fact:
        ansible_builder_verbose: "--verbosity 3"  # Use highest verbosity

# Play 4: Build Execution Environments for Ansible Automation Platform
- name: Build Execution Environments for Ansible Automation Platform
  hosts: localhost
  become: true
  gather_facts: true
  vars:
    protected_images:
      - "registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel8:latest"
      - "registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel9:latest"
      - "registry.redhat.io/ansible-automation-platform-25/de-supported-rhel9:latest"
      - "registry.redhat.io/ansible-automation-platform-25/de-supported-rhel8:latest"
      - "registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel9:latest"
      - "registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel8:latest"
      - "registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel8:latest"
      - "registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel9:latest"

  vars_files:
    - "{{ hostvars.localhost.config_path | default('~/.ansible/vars/config') }}"

  pre_tasks:
    - name: Check root status
      ansible.builtin.command: id -u
      register: user_id
      changed_when: false

    - name: Set root flag
      ansible.builtin.set_fact:
        is_root: "{{ user_id.stdout == '0' }}"
      failed_when: false
      tags: [setup, env_config, podman_warnings]
      
    - name: Add Podman warning suppression to environment files
      ansible.builtin.lineinfile:
        path: "{{ item }}"
        regexp: '^export PODMAN_IGNORE_CGROUPSV1_WARNING='
        line: 'export PODMAN_IGNORE_CGROUPSV1_WARNING=1'
        create: true
        mode: '0644'
      with_items:
        - /etc/environment

    # Include TMUX Header Display
    - name: Clear screen and display tmux header
      ansible.builtin.shell: |
        clear
        cat "{{ playbook_dir }}/files/tmux_header.txt"
      changed_when: false
      tags: [tmux, display]

    - name: Fail if required variables are missing
      ansible.builtin.fail:
        msg: >
          Required variables are missing:
          - rh_username: {{ rh_username is not defined }}
          - rh_password: {{ rh_password is not defined }}
          - container_registries: {{ container_registries is not defined }}
          - protected_images: {{ protected_images is not defined }}
      when:
        - rh_username is not defined or rh_username == ''
        - rh_password is not defined or rh_password == ''
        - container_registries is not defined or container_registries | length == 0
        - protected_images is not defined or protected_images | length == 0

    - name: Pull missing protected images
      block:
        - name: Check if protected images exist locally
          ansible.builtin.command:
            cmd: "podman image exists {{ item }}"
          loop: "{{ protected_images }}"
          register: image_check_results
          changed_when: false
          failed_when: false
          tags: [images, check]

        - name: Identify missing images
          ansible.builtin.set_fact:
            missing_images: "{{ image_check_results.results | selectattr('rc', 'ne', 0) | map(attribute='item') | list }}"
          tags: [images, identify_missing]

        - name: Pull missing images
          ansible.builtin.command:
            cmd: "podman pull {{ item }}"
          loop: "{{ missing_images }}"
          register: pull_results
          retries: 3
          delay: 5
          until: pull_results is succeeded
          tags: [images, pull]

        - name: Display image pull results
          ansible.builtin.debug:
            msg: |
              Image pull results:
              {% for result in pull_results.results %}
              - {{ result.item }}: {{ 'SUCCESS' if result.rc == 0 else 'FAILED' }}
              {% endfor %}
          tags: [images, pull]

    - name: Fail if any required images could not be pulled
      ansible.builtin.fail:
        msg: |
          Failed to download the following required images:
          {% for result in pull_results.results if result.rc != 0 %}
          - {{ result.item }}
          {% endfor %}
      when: pull_results.results | default([]) | selectattr('rc', 'ne', 0) | list | length > 0
      tags: [images, pull]

    # Build Container Images
    - name: Define required variables
      ansible.builtin.set_fact:
        image_name: "my_execution_environment"
        work_dir: "/tmp/build"
        playbook_dir: "{{ playbook_dir | default(ansible_playbook_dir) }}"

    - name: Define work_dir variable
      ansible.builtin.set_fact:
        work_dir: "/tmp/ee-containers"

    - name: Generate ansible.cfg for the _build/ directory
      ansible.builtin.template:
        src: templates/ansible.cfg.j2
        dest: "{{ work_dir }}/_build/ansible.cfg"
        mode: '0644'
      tags: [setup, build]

# Play 5: Image Pull
- name: Image Pull
  hosts: localhost
  connection: local
  gather_facts: false
  vars_files:
    - "{{ hostvars.localhost.config_path | default('~/.ansible/vars/config') }}"
  vars:
    required_images:
      - registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel8
      - registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel9
      - registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel9
 
  tasks:
    - name: Check if protected images exist locally
      ansible.builtin.command:
        cmd: "podman image exists {{ item }}"
      loop: "{{ required_images }}"
      register: image_check_results
      changed_when: false
      failed_when: false

    - name: Identify missing images
      ansible.builtin.set_fact:
        missing_images: "{{ image_check_results.results | selectattr('rc', 'ne', 0) | map(attribute='item') | list }}"

    - name: Pull missing images
      block:
        - name: Pull each missing image
          ansible.builtin.command:
            cmd: "podman pull {{ item }}"
          loop: "{{ missing_images }}"
          register: pull_results
          retries: 3
          delay: 5
          until: pull_results is succeeded

        - name: Display image pull results
          ansible.builtin.debug:
            msg: |
              Image pull results:
              {% for result in pull_results.results %}
              - {{ result.item }}: {{ 'SUCCESS' if result.rc == 0 else 'FAILED' }}
              {% endfor %}

# Play 6: Cleanup
- name: Cleanup
  hosts: localhost
  become: true
  gather_facts: false
  tasks:
    - name: Remove temporary build files
      ansible.builtin.file:
        path: "{{ work_dir }}"
        state: absent
      tags: [cleanup]

    - name: Remove dangling images
      ansible.builtin.shell: |
        podman images | awk '$1=="<none>" {print $3}' | xargs -r podman rmi -f
      args:
        executable: /bin/bash
      register: prune_results
      changed_when: prune_results.stdout is search("Deleted")
      failed_when: false
      ignore_errors: true
      tags: [cleanup]

    - name: Display cleanup completion message
      ansible.builtin.debug:
        msg: "Cleanup completed successfully."

- name: Persist all variables to ~/.ansible/vars/config
  hosts: localhost
  tasks:
    - name: Write variables to ~/.ansible/vars/config
      ansible.builtin.copy:
        dest: "{{ ansible_env.HOME }}/.ansible/vars/config"
        content: |
          ---
          container_registries:
            - registry.redhat.io
            - registry.access.redhat.com
            - registry.connect.redhat.com

          required_images:
            - registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel8
            - registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel9
            - registry.redhat.io/ansible-automation-platform-25/de-supported-rhel8
            - registry.redhat.io/ansible-automation-platform-25/de-supported-rhel9
            - registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel8
            - registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel9
            - registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel8
            - registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel9

          dns_servers:
            - '8.8.8.8'
            - '8.8.4.4'

          required_packages:
            - python3-pip
            - ansible-builder
            - ansible-core
            - git
            - podman
            - podman-docker
            - tmux
            - xdg-utils
            - yum-utils

          update_protected_list: true

          rh_username: "{{ rh_username | default('') }}"
          rh_password: "{{ rh_password | default('') }}"
          automation_hub_token: "{{ automation_hub_token | default('') }}"
          galaxy_token: "{{ automation_hub_token | default('') }}"
        mode: '0600'
      no_log: true  # Prevent sensitive data from being logged

- name: Load stored credentials
  hosts: localhost
  tasks:
    - name: Check if the config file exists
      ansible.builtin.stat:
        path: "{{ ansible_env.HOME }}/.ansible/vars/config"
      register: config_file

    - name: Load credentials from config file
      ansible.builtin.include_vars:
        file: "{{ ansible_env.HOME }}/.ansible/vars/config"
      when: config_file.stat.exists

    - name: Prompt for missing credentials
      block:
        - name: Prompt for Red Hat username
          ansible.builtin.pause:
            prompt: "Enter your Red Hat CDN username"
            echo: true
          register: rh_username_input
          when: rh_username is not defined

        - name: Prompt for Red Hat password
          ansible.builtin.pause:
            prompt: "Enter your Red Hat CDN password"
            echo: false
          register: rh_password_input
          when: rh_password is not defined
          no_log: true

        - name: Set collected credentials
          ansible.builtin.set_fact:
            rh_username: "{{ rh_username_input.user_input | default(rh_username) }}"
            rh_password: "{{ rh_password_input.user_input | default(rh_password) }}"
          no_log: true

    - name: Save credentials to config file
      ansible.builtin.copy:
        dest: "{{ ansible_env.HOME }}/.ansible/vars/config"
        content: |
          ---
          rh_username: "{{ rh_username }}"
          rh_password: "{{ rh_password }}"
        mode: '0600'
      when: rh_username is defined and rh_password is defined
      no_log: true

- name: Setup default variables
  hosts: localhost
  connection: local
  gather_facts: false
  tasks:
    - name: Set default work_dir
      ansible.builtin.set_fact:
        work_dir: "/tmp/ee-builder/context"

- name: Summarize build results
  hosts: localhost
  connection: local
  gather_facts: false
  tasks:
    - name: Display build summary
      ansible.builtin.debug:
        msg: |
          =================================================
          EXECUTION ENVIRONMENT BUILD SUMMARY
          =================================================
          
          SUCCESSFUL BUILDS:
          {% for result in build_results | selectattr('success', 'equalto', true) | list %}
          ✅ {{ result.image }}
          {% else %}
          (none)
          {% endfor %}
          
          FAILED BUILDS:
          {% for result in build_results | selectattr('success', 'equalto', false) | list %}
          ❌ {{ result.image }}
          {% else %}
          (none)
          {% endfor %}
          
          =================================================
          
          Total successful: {{ build_results | selectattr('success', 'equalto', true) | list | length }}
          Total failed: {{ build_results | selectattr('success', 'equalto', false) | list | length }}
          
          {% if build_results | selectattr('success', 'equalto', false) | list | length > 0 %}
          For details on failed builds, look at the full playbook output above.
          {% endif %}

    - name: Display detailed failure information
      ansible.builtin.debug:
        msg: |
          FAILURE DETAILS FOR: {{ result.image }}
          
          Exit code: {{ result.output.rc }}
          
          ERROR OUTPUT:
          {{ result.output.stderr_lines | join('\n') }}
          
          -------------------------------------------------
      loop: "{{ build_results | selectattr('success', 'equalto', false) | list }}"
      loop_control:
        loop_var: result
        label: "{{ result.image }}"
      when: build_results | selectattr('success', 'equalto', false) | list | length > 0

