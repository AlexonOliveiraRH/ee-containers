---
# Ansible Automation Platform - Execution Environment Builder
# This playbook builds customized execution environments based on Red Hat AAP base images.
- name: Setup and store credentials
  hosts: localhost
  connection: local
  gather_facts: true
  environment:
    ANSIBLE_LOCALHOST_WARNING: "False" 
    ANSIBLE_DEPRECATION_WARNINGS: "False"
    ANSIBLE_COMMAND_WARNINGS: "False"
    ANSIBLE_SYSTEM_WARNINGS: "False"

  vars:
    container_registries:
      - registry.redhat.io
      - registry.access.redhat.com
      - registry.connect.redhat.com

    required_images:
      - registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel8
      - registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel9
      - registry.redhat.io/ansible-automation-platform-25/de-supported-rhel8
      - registry.redhat.io/ansible-automation-platform-25/de-supported-rhel9
      - registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel8
      - registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel9
      - registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel8
      - registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel9

    protected_images:
      - "registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel9"
      - "registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel9:latest"
      - "registry.redhat.io/ansible-automation-platform-25/de-supported-rhel9"
      - "registry.redhat.io/ansible-automation-platform-25/de-supported-rhel9:latest"
      - "registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel9"
      - "registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel9:latest"
      - "registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel9"
      - "registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel9:latest"
      - "rhel9-de-minimal"
      - "rhel9-de-minimal-cloudstrike"
      - "rhel9-de-supported"
      - "rhel9-ee-minimal"
      - "rhel9-ee-minimal-cloud"
      - "rhel9-ee-minimal-general"
      - "rhel9-ee-minimal-vmware"
      - "rhel9-ee-minimal-windows"
      - "rhel9-ee-supported"
      - "rhel9-ee-supported-vmware"

    dns_servers:
      - '8.8.8.8'
      - '8.8.4.4'

    required_packages:
      - python3-pip
      - ansible-builder
      - ansible-core
      - git
      - podman
      - podman-docker
      - tmux
      - xdg-utils
      - yum-utils

    update_protected_list: true

  tasks:
    - name: Verify internet connectivity  
      ansible.builtin.uri:
        url: https://google.com
        method: GET
      register: connectivity_check
      failed_when: connectivity_check.status != 200  
      changed_when: false
      tags: [connectivity, validation]
      
    # Create static ansible.cfg before any template processing
    - name: Create static ansible.cfg file for initial setup
      ansible.builtin.copy:
        dest: "{{ playbook_dir }}/ansible.cfg"
        mode: '0644'
        force: false  # Don't overwrite if exists
        content: |
          [defaults]
          inventory = localhost,
          ansible_localhost_warning=false
          ansible_deprecation_warnings=false
          force_color = True

          [galaxy]
          server_list = validated, published, galaxy

          [galaxy_server.published]
          url=https://console.redhat.com/api/automation-hub/content/published/
          auth_url=https://sso.redhat.com/auth/realms/redhat-external/protocol/openid-connect/token

          [galaxy_server.validated]
          url=https://console.redhat.com/api/automation-hub/content/validated/
          auth_url=https://sso.redhat.com/auth/realms/redhat-external/protocol/openid-connect/token

          [galaxy_server.galaxy]
          url=https://galaxy.ansible.com/
      tags: [always]

    - name: Create collections requirements file
      ansible.builtin.copy:
        dest: "/tmp/requirements.yml"
        mode: '0644'
        content: |
          ---
          collections:
            - name: ansible.utils
            - name: ansible.posix
            - name: community.general
            - name: infra.aap_configuration
            - name: infra.aap_utilities
      tags: [setup, always, collections]

    - name: Create requirements.txt file
      ansible.builtin.copy:
        dest: "/tmp/requirements.txt"
        mode: '0644'
        content: |
          ansible-builder>=3.0.0
          ansible-core>=2.15.0,<2.16
          ansible-lint>=24.0.0
      tags: [setup, always, collections]

    - name: Create inventory file
      ansible.builtin.copy:
        dest: "/tmp/inventory"
        state: presant
        mode: '0644'
        content: |
          [devnode]
          localhost ansible_connection=localhost
      tags: [always, setup]
     
    - name: Force install community.general collection system-wide
      ansible.builtin.command:
        cmd: "sudo ansible-galaxy collection install community.general ansible.posix -p /usr/share/ansible/collections --force"
      register: galaxy_install
      changed_when: galaxy_install.rc == 0
      failed_when: galaxy_install.rc != 0

    - name: Verify community.general collection installation
      ansible.builtin.command:
        cmd: "ansible-galaxy collection list community.general"
      register: collection_verify
      failed_when: collection_verify.rc != 0

    - name: Show installation path
      ansible.builtin.debug:
        msg: "Collection installed at: {{ collection_verify.stdout_lines | select('search', 'Path:') | first | default('Unknown location') }}"

    # Improved user detection logic
    - name: Get effective and real user info
      ansible.builtin.shell: |
        echo "EUID=$(id -u)"
        if [ -n "$SUDO_USER" ]; then
          echo "SUDO_USER=$SUDO_USER"
          echo "SUDO_UID=$(id -u $SUDO_USER)"
          echo "SUDO_HOME=$(eval echo ~$SUDO_USER)"
        else
          echo "SUDO_USER="
          echo "SUDO_UID="
          echo "SUDO_HOME="
        fi
        echo "USER=$(whoami)"
        echo "HOME=$HOME"
      register: user_info_output
      changed_when: false
      tags: [always]
    
    - name: Parse user info
      ansible.builtin.set_fact:
        parsed_user_info: "{{ dict(user_info_output.stdout_lines | map('regex_replace', '^([^=]+)=(.*)$', '\\1:\\2') | map('split', ':') | list) }}"
      tags: [always]
    
    - name: Set user facts
      ansible.builtin.set_fact:
        is_root: "{{ ansible_user_id == '0' }}"
        actual_user: "{{ ansible_user_id }}"
        user_home: "{{ ansible_env.HOME }}"
      tags: [always]
    
    - name: Debug user detection
      ansible.builtin.debug:
        msg: |
          User detection results:
          - Effective UID: {{ parsed_user_info.EUID }}
          - Running as root: {{ is_root }}
          - Original user: {{ actual_user }}
          - User home: {{ user_home }}
      tags: [always]

    # Skip credential setup if running as root directly (not via sudo)
    - name: Skip credential setup if running as root directly
      ansible.builtin.set_fact:
        skip_credential_setup: "{{ ansible_user_id == 'root' and lookup('env', 'SUDO_USER') == '' }}"
      tags: [always]

    - name: Show credential setup status
      ansible.builtin.debug:
        msg: "{{ skip_credential_setup | ternary('Running as direct root user - skipping credential setup', 'Setting up credentials for user ' + actual_user) }}"
      tags: [always]

    # Only run credential setup if not skipping
    - name: Setup user credentials
      when: not skip_credential_setup
      block:
        - name: Ensure ansible vars directory exists in user's home
          ansible.builtin.file:
            path: "{{ user_home }}/.ansible/vars"
            state: directory
            mode: '0700'
          tags: [setup, credential_setup]
    
        - name: Check if credentials file exists
          ansible.builtin.stat:
            path: "{{ user_home }}/.ansible/vars/config"
          register: config_file
          tags: [always]
    
        - name: Set first run flag 
          ansible.builtin.set_fact:
            first_run: "{{ not config_file.stat.exists }}"
          tags: [always]
    
        - name: Load stored credentials if they exist
          ansible.builtin.include_vars:
            file: "{{ user_home }}/.ansible/vars/config"
            name: stored_credentials
          when: config_file.stat.exists
          tags: [always]
    
        - name: Request credentials if needed
          block:
            - name: Collect Red Hat CDN username
              ansible.builtin.pause:
                prompt: "Enter your Red Hat CDN username"
                echo: true
              register: rh_username_input
              when: stored_credentials is not defined or stored_credentials.rh_username is not defined
              
            - name: Collect Red Hat CDN password
              ansible.builtin.pause:
                prompt: "Enter your Red Hat CDN password"
                echo: false
              register: rh_password_input
              when: stored_credentials is not defined or stored_credentials.rh_password is not defined
              no_log: true
              
            - name: Collect Automation Hub token
              ansible.builtin.pause:
                prompt: "Enter your Automation Hub token (or press enter to skip)"
                echo: false
              register: automation_hub_token_input
              when: stored_credentials is not defined or stored_credentials.automation_hub_token is not defined
             #no_log: true
              
            - name: Collect Galaxy token
              ansible.builtin.pause:
                prompt: "Enter your Galaxy token (or press enter to skip)"
                echo: false
              register: galaxy_token_input
              when: stored_credentials is not defined or stored_credentials.galaxy_token is not defined
              #no_log: true
              
            - name: Set collected credential facts
              ansible.builtin.set_fact:
                rh_username: "{{ rh_username_input.user_input | default(stored_credentials.rh_username | default('')) }}"
                rh_password: "{{ rh_password_input.user_input | default(stored_credentials.rh_password | default('')) }}"
                automation_hub_token: "{{ automation_hub_token_input.user_input | default(stored_credentials.automation_hub_token | default('')) }}"
                galaxy_token: "{{ galaxy_token_input.user_input | default(stored_credentials.galaxy_token | default('')) }}"
              no_log: true  # Ensure sensitive data is not logged

            - name: Create credentials file
              ansible.builtin.copy:
                dest: "{{ user_home }}/.ansible/vars/config"
                content: |
                  ---
                  # Ansible EE Builder Configuration - Last updated {{ ansible_date_time.iso8601 }}
                  rh_username: '{{ rh_username }}'
                  rh_password: '{{ rh_password }}'
                  automation_hub_token: '{{ automation_hub_token }}'
                  galaxy_token: '{{ galaxy_token }}'
                mode: '0600'
              no_log: true  # Prevent sensitive data from being logged

            - name: Recreate ansible.cfg in the current ee-containers directory
              ansible.builtin.template:
                src: templates/ansible.cfg.j2
                dest: "{{ playbook_dir }}/ansible.cfg"
                mode: '0644'

            - name: Recreate ansible.cfg in the working directory
              ansible.builtin.template:
                src: templates/ansible.cfg.j2
                dest: "/tmp/ee-containers/_build/ansible.cfg"
                mode: '0644'
              
            - name: Set proper ownership on credentials file when needed
              ansible.builtin.file:
                path: "{{ user_home }}/.ansible/vars/config"
                owner: "{{ actual_user }}"
                group: "{{ actual_user }}"
                mode: '0600'
              when: actual_user != 'root' and actual_user != ''
              no_log: true  # Ensure no sensitive data is logged
              
            - name: Report stored credentials
              ansible.builtin.debug:
                msg: |
                  ┌────────────────────────────────────────────────────────────────┐
                  │                  CREDENTIALS STORED                            │
                  ├────────────────────────────────────────────────────────────────┤
                  │ Credentials have been stored at: {{ user_home }}/.ansible/vars/config │
                  │ These will be used for future runs.                            │
                  └────────────────────────────────────────────────────────────────┘
              when: not no_log  # Avoid logging sensitive data if no_log is true
          when: first_run or (stored_credentials is not defined)
          tags: [always]

        - name: Set collected credential facts
          ansible.builtin.set_fact:
            rh_username: "{{ stored_credentials.rh_username | default('') }}"
            rh_password: "{{ stored_credentials.rh_password | default('') }}"
            automation_hub_token: "{{ stored_credentials.automation_hub_token | default('') }}"
            galaxy_token: "{{ stored_credentials.galaxy_token | default('') }}"
          no_log: true

        - name: Debug credentials
          ansible.builtin.debug:
            msg:
              - "Red Hat username: {{ rh_username }}"
              - "Red Hat password: {{ rh_password | regex_replace('.+', '******') }}"
              - "Automation Hub token: {{ automation_hub_token | regex_replace('.+', '******') }}"
              - "Galaxy token: {{ galaxy_token | regex_replace('.+', '******') }}"

    - name: Show run mode
      ansible.builtin.debug:
        msg: |
          ┌────────────────────────────────────────────────────────────────────┐
          │                     RUN MODE INFORMATION                           │
          ├────────────────────────────────────────────────────────────────────┤
          │ {{ "FIRST RUN DETECTED: Running full setup" if first_run | default(false) else "SUBSEQUENT RUN: Using stored configuration" }} │
          │                                                                    │
          │ User: {{ actual_user | default('Unknown') }}                                            │
          │ Credentials: {{ "New" if first_run | default(false) else "Loaded from file" }}      │
          └────────────────────────────────────────────────────────────────────┘
      tags: [always]

    # Use sudo_user's home directory for config in the main play
    - name: Set config path for main play
      ansible.builtin.set_fact:
        config_path: "{{ user_home }}/.ansible/vars/config"
      tags: [always]

# Play 2: Display title and introduction
- name: Display title screen
  hosts: localhost
  connection: local
  gather_facts: false
  environment:
    ANSIBLE_LOCALHOST_WARNING: "False" 
    ANSIBLE_DEPRECATION_WARNINGS: "False"
    ANSIBLE_COMMAND_WARNINGS: "False"
    ANSIBLE_SYSTEM_WARNINGS: "False"
  tasks:
    - name: Show ascii title
      ansible.builtin.debug:
        msg: |
          ┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
          │                                                                                      ..:-=@@@@=-:..          │
          │                                                                                    .*%@@@@@@@@@@@@%*.        │
          │                                                                                 .:@@@@@@@@@@@@@@@@@@@@:.     │
          │                                                                                .*@@@@@@@@@@*-@@@@@@@@@@*.    │
          │                                                                               .@@@@@@@@@@@*. =@@@@@@@@@@@.   │
          │                                                                              .%@@@@@@@@@@@ .@ +@@@@@@@@@@%.  │
          │                                                                              -%@@@@@@@@@@..@%-.*@@@@@@@@@%-  │
          │     "A Streamlined Approach to Building Ansible Execution Environments"     .+@@@@@@@@@@= =@@@.:@@@@@@@@@@+. │
          │                                                                             .+@@@@@@@@@@ ..:+@%.-@@@@@@@@@+. │
          │                                                                             .=@@@@@@@@@ .@@+. *+.-@@@@@@@%=  │
          │                                                                              .%@@@@@@@:.*@@@@%.  .+@@@@@@%.  │
          │                                                                               .@@@@@@= =@@@@@@@%=.:%@@@@@.   │
          │                                                                                :%@@@@@@@@@@@@@@@@@@@@@@%:    │
          │                                                                                 .*@@@@@@@@@@@@@@@@@@@@*.     │
          │                                                                                   .+@@@@@@@@@@@@@@@@+..      │
          │                                                                                     ..+*%@@@@@@%*+..         │
          └──────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
      tags: [always]

    - name: Title screen
      ansible.builtin.pause:
        seconds: 3
      tags: [always]

# Play 2: Environment Selection
- name: Environment Selection
  hosts: localhost
  connection: local
  gather_facts: false
  tasks:
    - name: Prompt for distribution selection
      ansible.builtin.pause:
        prompt: |
          Please select the distribution:
          Enter '8' for RHEL 8 or '9' for RHEL 9
      register: user_input

    - name: Set distribution_selection based on user input
      ansible.builtin.set_fact:
        distribution_selection: "{{ user_input.user_input }}"
      when: user_input.user_input is defined

    - name: Set default values for build_rhel8 and build_rhel9
      ansible.builtin.set_fact:
        build_rhel8: false
        build_rhel9: false
      when: build_rhel8 is not defined or build_rhel9 is not defined

    - name: Filter available environments based on distribution selection
      block:
        - name: Get all available environments
          ansible.builtin.find:
            paths: "environments"
            file_type: directory
          register: all_environments

        - name: Process environments for filtering
          ansible.builtin.set_fact:
            rhel8_environments: "{{ all_environments.files | selectattr('path', 'search', 'rhel8') | rejectattr('path', 'search', '\\.bak$') | map(attribute='path') | list }}"
            rhel9_environments: "{{ all_environments.files | selectattr('path', 'search', 'rhel9') | rejectattr('path', 'search', '\\.bak$') | map(attribute='path') | list }}"
            neutral_environments: "{{ all_environments.files | rejectattr('path', 'search', 'rhel[89]') | rejectattr('path', 'search', '\\.bak$') | map(attribute='path') | list }}"

        - name: Set available environments based on distribution selection
          ansible.builtin.set_fact:
            available_environments: >-
              {{
                (distribution_selection == '8') | ternary(rhel8_environments, []) +
                (distribution_selection == '9') | ternary(rhel9_environments, []) +
                neutral_environments
              }}

    - name: Display environment selection menu header
      ansible.builtin.debug:
        msg: |
          **************************************************
          ENVIRONMENT SELECTION MENU

          Selected distribution: RHEL {{ distribution_selection }}

          Available environments:
          {% for env in available_environments %}
          {{ loop.index }}. {{ env | basename }}
          {% endfor %}
          **************************************************

    - name: Prompt for environment selection
      ansible.builtin.pause:
        prompt: |
          **************************************************
          ENVIRONMENT SELECTION MENU

          Selected distribution: RHEL {{ distribution_selection }}

          Available environments:
          {% for env in available_environments %}
          {{ loop.index }}. {{ env | basename }}
          {% endfor %}
          **************************************************

          Enter numbers for environments to build (comma-separated, max {{ available_environments | length }}):
          Enter 'all' to select all environments
          Enter 'q' to quit without selecting:
      register: user_input

    - name: Parse user input for environment selection
      ansible.builtin.set_fact:
        selected_environments: >-
          {{
            available_environments if user_input.user_input == 'all' else
            available_environments | zip(range(1, available_environments | length + 1)) |
            selectattr(1, 'in', user_input.user_input.split(',')) |
            map(attribute=0) | list
          }}
      vars:
        user_input: "{{ user_input.user_input | default('') }}"

    - name: Set basename for the selected environment
      ansible.builtin.set_fact:
        basename: "{{ selected_environments | first | basename }}"
      when: selected_environments | length > 0

    - name: Debug selected basename
      ansible.builtin.debug:
        msg: "Selected environment basename: {{ basename }}"

    - name: Debug selected environments
      ansible.builtin.debug:
        var: selected_environments

    - name: Debug work_dir
      ansible.builtin.debug:
        msg: "Work directory: Not yet defined (will be set during processing)"
      when: work_dir is not defined

    - name: Create scripts directory
      ansible.builtin.file:
        path: "{{ playbook_dir }}/scripts"
        state: directory
        mode: '0755'
      tags: [setup, monitoring]

    - name: Create Podman monitoring script
      ansible.builtin.copy:
        dest: "{{ playbook_dir }}/scripts/start_monitor.sh"
        content: |
          #!/bin/bash
          # start_monitor.sh - Opens a terminal window with tmux session attached

          # Function to try opening a terminal with tmux
          open_terminal_with_tmux() {
            # If we're already in tmux, create a new window
            if [ -n "$TMUX" ]; then
              tmux new-window "tmux attach -t podman-monitor"
              return 0
            fi

            # Try different terminal emulators in order of preference
            for terminal in gnome-terminal konsole xfce4-terminal terminator mate-terminal xterm; do
              if command -v $terminal >/dev/null 2>&1; then
                case $terminal in
                  gnome-terminal)
                    nohup $terminal -- tmux attach -t podman-monitor >/dev/null 2>&1 &
                    ;;
                  *)
                    nohup $terminal -e "tmux attach -t podman-monitor" >/dev/null 2>&1 &
                    ;;
                esac
                echo "Opened tmux session in $terminal"
                return 0
              fi
            done
            
            # If none of the above worked, try X-terminal-emulator alternative
            if command -v x-terminal-emulator >/dev/null 2>&1; then
              nohup x-terminal-emulator -e "tmux attach -t podman-monitor" >/dev/null 2>&1 &
              echo "Opened tmux session in x-terminal-emulator"
              return 0
            fi
            
            echo "Warning: Could not find a suitable terminal emulator"
            return 1
          }

          # Create the tmux session if it doesn't exist
          if ! tmux has-session -t podman-monitor 2>/dev/null; then
            tmux new-session -d -s podman-monitor 'watch -n 2 "podman ps -a; echo; podman images; echo; podman volume ls"'
            echo "Created new tmux session: podman-monitor"
          fi

          # Open terminal with the tmux session
          open_terminal_with_tmux

          # If we get here and still in terminal, provide instructions
          echo "To manually attach to monitoring: tmux attach -t podman-monitor"
        mode: '0755'
      tags: [setup, monitoring]

    - name: Copy Podman monitoring script
      ansible.builtin.copy:
        src: "{{ playbook_dir }}/scripts/start_monitor.sh"
        dest: "{{ playbook_dir }}/scripts/start_monitor.sh"
        mode: '0755'
      tags: [setup, monitoring]

    - name: Create and start Podman monitoring session
      ansible.builtin.block:
        - name: Check if tmux is installed
          ansible.builtin.command: which tmux
          register: tmux_check
          changed_when: false
          failed_when: false
          
        - name: Create Podman monitoring tmux session
          ansible.builtin.shell: |
            if ! tmux has-session -t podman-monitor 2>/dev/null; then
              tmux new-session -d -s podman-monitor 'watch -n 2 "podman ps -a; echo; podman images; echo; podman volume ls"'
              echo "Created new tmux session: podman-monitor"
            fi
          when: tmux_check.rc == 0
          changed_when: true
          
        - name: Launch monitoring script in new terminal window
          ansible.builtin.command: "{{ playbook_dir }}/scripts/start_monitor.sh"
          when: tmux_check.rc == 0
          changed_when: true
          ignore_errors: true
          async: 10  # Run in background
          poll: 0    # Don't wait for completion
      tags: [monitoring, setup]

- name: Registry Authentication
  hosts: localhost
  connection: local
  gather_facts: false
  vars:
    container_registries:
      - registry.redhat.io
      - registry.access.redhat.com
      - registry.connect.redhat.com
  tasks:
    - name: Verify Podman is working properly
      ansible.builtin.command:
        cmd: >-
          {% raw %}podman info --format '{{ .Store.GraphDriverName }}'{% endraw %}
      environment:
        PODMAN_IGNORE_CGROUPSV1_WARNING: "1"
      register: podman_check
      failed_when: podman_check.rc != 0
      tags: [podman, validation]


    - name: Check if the config file exists
      ansible.builtin.stat:
        path: "{{ ansible_env.HOME }}/.ansible/vars/config"
      register: config_file

    - name: Load variables from config file
      ansible.builtin.include_vars:
        file: "{{ ansible_env.HOME }}/.ansible/vars/config"
      when: config_file.stat.exists
      no_log: true

    - name: Set default value for container_registries
      ansible.builtin.set_fact:
        container_registries: "{{ container_registries | default(['registry.redhat.io', 'registry.access.redhat.com', 'quay.io', 'registry.connect.redhat.com']) }}"

    - name: Login to each container registry
      ansible.builtin.command:
        cmd: "podman login -u {{ rh_username }} -p {{ rh_password }} {{ item }}"
      loop: "{{ container_registries }}"
      register: registry_login_results
      no_log: true

    - name: Initialize registry login success
      ansible.builtin.set_fact:
        registry_login_success: false

    - name: Process registry login results
      ansible.builtin.set_fact:
        registry_login_success: >-
          {{ registry_login_success or
              (item.item != 'quay.io' and item.rc == 0) }}
        registry_login_results: "{{ registry_login_results | combine({item.item: (item.rc == 0)}) }}"
      loop: "{{ registry_login_results.results }}"
      loop_control:
        label: "{{ item.item }}"
      no_log: true

    - name: Display registry login results
      ansible.builtin.debug:
        msg: |
          Registry Authentication Results:
          {% for registry, success in registry_login_results.items() %}
          - {{ registry }}: {{ 'SUCCESS' if success else 'FAILED' }}
          {% endfor %}

    - name: Fail if authentication failed for all critical registries
      ansible.builtin.fail:
        msg: |
          CRITICAL ERROR: Failed to authenticate with any required container registries.
          Authentication to at least one Red Hat registry is required for this playbook to function.
          Please check your Red Hat credentials and network connectivity.
      when: not registry_login_success

# Play 3: Build Execution Environments
- name: Build Execution Environments
  hosts: localhost
  connection: local
  gather_facts: false
  pre_tasks:
    - name: Ensure /tmp/ee-builder/context directory exists
      ansible.builtin.file:
        path: "/tmp/ee-builder/context"
        state: directory
        mode: '0755'

    - name: Ensure /tmp/ee-builder/context/environments directory exists
      ansible.builtin.file:
        path: "/tmp/ee-builder/context/environments"
        state: directory
        mode: '0755'

    - name: Ensure tasks/ folder exists in the playbook directory
      ansible.builtin.file:
        path: "{{ playbook_dir }}/tasks"
        state: directory
        mode: '0755'

    - name: Create process_environment.yml dynamically in tasks/ folder
      ansible.builtin.copy:
        dest: "{{ playbook_dir }}/tasks/process_environment.yml"
        content: |
          - name: Set work_dir for the current environment
            ansible.builtin.set_fact:
              work_dir: "/tmp/ee-builder/context/environments/{% raw %}{{ item | basename }}{% endraw %}"

          - name: Debug work_dir
            ansible.builtin.debug:
              msg: "Work directory: {% raw %}{{ work_dir }}{% endraw %}"

          - name: Create work_dir for the current environment
            ansible.builtin.file:
              path: "{% raw %}{{ work_dir }}{% endraw %}"
              state: directory
              mode: '0755'

          - name: Copy selected environment to work_dir
            ansible.builtin.copy:
              src: "{% raw %}{{ item }}{% endraw %}"
              dest: "{% raw %}{{ work_dir }}{% endraw %}"
              remote_src: true

          - name: Build container image using ansible-builder
            ansible.builtin.command:
              cmd: >-
                ansible-builder build
                --tag {% raw %}{{ item | basename }}{% endraw %}
                --container-runtime podman
                --verbosity 2
                --prune-images
                --context {% raw %}{{ work_dir }}{% endraw %}
                -f {% raw %}{{ work_dir }}{% endraw %}/execution-environment.yml
              chdir: "{% raw %}{{ work_dir }}{% endraw %}"
            register: build_output
            changed_when: "'Downloaded newer image' in build_output.stdout or 'Successfully built' in build_output.stdout"
            environment:
              ANSIBLE_BUILDER_HOME: "{% raw %}{{ work_dir }}{% endraw %}"

          - name: Verify image was built successfully
            ansible.builtin.command:
              cmd: "podman images | grep {% raw %}{{ item | basename }}{% endraw %}"
            register: verify_image
            failed_when: verify_image.rc != 0

          - name: Display build result summary
            ansible.builtin.debug:
              msg: |
                Build Summary for {% raw %}{{ item | basename }}{% endraw %}:
                - Image Name: {% raw %}{{ item | basename }}{% endraw %}
                - Build Status: {% raw %}{{ 'SUCCESS' if verify_image.rc == 0 else 'FAILED' }}{% endraw %}"
        mode: '0644'

    - name: Copy environment directories to /tmp/ee-builder/context
      ansible.builtin.copy:
        src: "{{ playbook_dir }}/environments"
        dest: "/tmp/ee-builder/context"
        remote_src: true
        mode: '0755'

    - name: Debug copied environments
      ansible.builtin.debug:
        msg: "Environment directories copied to /tmp/ee-builder/context"

  tasks:
    - name: Process each selected environment
      ansible.builtin.include_tasks: "{{ playbook_dir }}/tasks/process_environment.yml"
      loop: "{{ selected_environments }}"
      loop_control:
        label: "{{ item | basename }}"

# Play 4: Build Execution Environments for Ansible Automation Platform
- name: Build Execution Environments for Ansible Automation Platform
  hosts: localhost
  become: true
  gather_facts: true
  vars_files:
    - "{{ hostvars.localhost.config_path | default('~/.ansible/vars/config') }}"
  pre_tasks:
    - name: Check root status
      ansible.builtin.command: id -u
      register: user_id
      changed_when: false

    - name: Set root flag
      ansible.builtin.set_fact:
        is_root: "{{ user_id.stdout == '0' }}"
      failed_when: false
      tags: [setup, env_config, podman_warnings]
      
    - name: Add Podman warning suppression to environment files
      ansible.builtin.lineinfile:
        path: "{{ item }}"
        regexp: '^export PODMAN_IGNORE_CGROUPSV1_WARNING='
        line: 'export PODMAN_IGNORE_CGROUPSV1_WARNING=1'
        create: true
        mode: '0644'
      with_items:
        - /etc/environment

    # Include TMUX Header Display
    - name: Clear screen and display tmux header
      ansible.builtin.shell: |
        clear
        cat "{{ playbook_dir }}/files/tmux_header.txt"
      changed_when: false
      tags: [tmux, display]

    - name: Fail if required variables are missing
      ansible.builtin.fail:
        msg: >
          Required variables are missing:
          - rh_username: {{ rh_username is not defined }}
          - rh_password: {{ rh_password is not defined }}
          - container_registries: {{ container_registries is not defined }}
          - protected_images: {{ protected_images is not defined }}
      when:
        - rh_username is not defined or rh_username == ''
        - rh_password is not defined or rh_password == ''
        - container_registries is not defined or container_registries | length == 0
        - protected_images is not defined or protected_images | length == 0

    - name: Login to container registries
      block:
        - name: Login to each container registry
          ansible.builtin.command:
            cmd: "podman login -u {{ rh_username }} -p {{ rh_password }} {{ item }}"
          loop: "{{ container_registries }}"
          register: registry_login_results
          failed_when: registry_login_results.rc != 0
          changed_when: false
          vars:
            rh_username: "{{ rh_username | default(omit) }}"
            rh_password: "{{ rh_password | default(omit) }}"
          tags: [registry, login]

        - name: Display registry login results
          ansible.builtin.debug:
            msg: |
              Registry login results:
              {% for result in registry_login_results.results %}
              - {{ result.item }}: {{ 'SUCCESS' if result.rc == 0 else 'FAILED' }}
              {% endfor %}
          tags: [registry, login]

    - name: Debug variables for registry login and image pull
      ansible.builtin.debug:
        msg:
          - "Red Hat username: {{ rh_username }}"
          - "Red Hat password: {{ rh_password | regex_replace('.+', '******') }}"
          - "Container registries: {{ container_registries }}"
          - "Protected images: {{ protected_images }}"

    - name: Pull missing protected images
      block:
        - name: Check if protected images exist locally
          ansible.builtin.command:
            cmd: "podman image exists {{ item }}"
          loop: "{{ protected_images }}"
          register: image_check_results
          changed_when: false
          failed_when: false
          tags: [images, check]

        - name: Identify missing images
          ansible.builtin.set_fact:
            missing_images: "{{ image_check_results.results | selectattr('rc', 'ne', 0) | map(attribute='item') | list }}"
          tags: [images, identify_missing]

        - name: Pull missing images
          ansible.builtin.command:
            cmd: "podman pull {{ item }}"
          loop: "{{ missing_images }}"
          register: pull_results
          retries: 3
          delay: 5
          until: pull_results is succeeded
          tags: [images, pull]

        - name: Display image pull results
          ansible.builtin.debug:
            msg: |
              Image pull results:
              {% for result in pull_results.results %}
              - {{ result.item }}: {{ 'SUCCESS' if result.rc == 0 else 'FAILED' }}
              {% endfor %}
          tags: [images, pull]

        - name: Fail if any protected images failed to download
          ansible.builtin.fail:
            msg: |
              Failed to download the following protected images:
              {% for result in pull_results.results if result.rc != 0 %}
              - {{ result.item }}
              {% endfor %}
          when: pull_results.results | selectattr('rc', 'ne', 0) | list | length > 0
          tags: [images, pull]

    # Build Container Images
    - name: Build container image using ansible-builder
      ansible.builtin.command:
        cmd: >-
          ansible-builder build
          --tag {{ image_name }}
          --container-runtime podman
          --verbosity 2
          --prune-images
          --context {{ work_dir }}/context
          -f {{ work_dir }}/context/execution-environment.yml
        chdir: "{{ work_dir }}/context"
      register: build_output
      changed_when: "'Downloaded newer image' in build_output.stdout or 'Successfully built' in build_output.stdout"
      environment:
        ANSIBLE_BUILDER_HOME: "{{ work_dir }}/context"

    - name: Define required variables
      ansible.builtin.set_fact:
        image_name: "my_execution_environment"
        work_dir: "/tmp/build"
        playbook_dir: "{{ playbook_dir | default(ansible_playbook_dir) }}"

    - name: Define work_dir variable
      ansible.builtin.set_fact:
        work_dir: "/tmp/ee-containers"

    - name: Build container image using ansible-builder
      ansible.builtin.command:
        cmd: >-
          ansible-builder build
          --tag {{ image_name }}
          --container-runtime podman
          --verbosity 2
          --prune-images
          --context {{ work_dir }}/context
          -f {{ work_dir }}/context/execution-environment.yml
        chdir: "{{ work_dir }}/context"
      register: build_output
      changed_when: "'Downloaded newer image' in build_output.stdout or 'Successfully built' in build_output.stdout"
      environment:
        ANSIBLE_BUILDER_HOME: "{{ work_dir }}/context"

    - name: Define required variables
      ansible.builtin.set_fact:
        work_dir: "/tmp/ee-containers"
        basename: "my_environment"  # Replace with the actual environment name

    - name: Generate ansible.cfg for the _build/ directory
      ansible.builtin.template:
        src: templates/ansible.cfg.j2
        dest: "{{ work_dir }}/_build/ansible.cfg"
        mode: '0644'
      tags: [setup, build]

    - name: Copy execution-environment.yml to the build context
      ansible.builtin.copy:
        src: "environments/{{ basename }}/*"
        dest: "{{ work_dir }}/context/execution-environment.yml"
        remote_src: true
      tags: [setup, build]

    - name: Build container image using ansible-builder
      ansible.builtin.command:
        cmd: >-
          ansible-builder build
          --tag {{ image_name }}
          --container-runtime podman
          --verbosity 2
          --prune-images
          --context {{ work_dir }}/context
          -f {{ work_dir }}/context/execution-environment.yml
        chdir: "{{ work_dir }}/context"
      register: build_output
      changed_when: "'Downloaded newer image' in build_output.stdout or 'Successfully built' in build_output.stdout"
      environment:
        ANSIBLE_BUILDER_HOME: "{{ work_dir }}/context"

# Play 5: Image Pull
- name: Image Pull
  hosts: localhost
  connection: local
  gather_facts: false
  tasks:
    - name: Check if protected images exist locally
      ansible.builtin.command:
        cmd: "podman image exists {{ item }}"
      loop: "{{ required_images }}"
      register: image_check_results
      changed_when: false
      failed_when: false

    - name: Identify missing images
      ansible.builtin.set_fact:
        missing_images: "{{ image_check_results.results | selectattr('rc', 'ne', 0) | map(attribute='item') | list }}"

    - name: Pull missing images
      block:
        - name: Pull each missing image
          ansible.builtin.command:
            cmd: "podman pull {{ item }}"
          loop: "{{ missing_images }}"
          register: pull_results
          retries: 3
          delay: 5
          until: pull_results is succeeded

        - name: Display image pull results
          ansible.builtin.debug:
            msg: |
              Image pull results:
              {% for result in pull_results.results %}
              - {{ result.item }}: {{ 'SUCCESS' if result.rc == 0 else 'FAILED' }}
              {% endfor %}

    - name: Fail if any required images could not be pulled
      ansible.builtin.fail:
        msg: |
          Failed to download the following required images:
          {% for result in pull_results.results if result.rc != 0 %}
          - {{ result.item }}
          {% endfor %}

# Play 6: Cleanup
- name: Cleanup
  hosts: localhost
  become: true
  gather_facts: false
  tasks:
    - name: Remove temporary build files
      ansible.builtin.file:
        path: "{{ work_dir }}"
        state: absent
      tags: [cleanup]

    - name: Remove dangling images
      ansible.builtin.command:
        cmd: "podman image prune -f"
      register: prune_results
      changed_when: "'Deleted' in prune_results.stdout"
      tags: [cleanup]

    - name: Display cleanup completion message
      ansible.builtin.debug:
        msg: "Cleanup completed successfully."

- name: Backup
  hosts: localhost
  become: true
  gather_facts: false
  tasks:
    - name: Define backup directory
      set_fact:
        backup_dir: "{{ playbook_dir }}/../backup/ee-containers-{{ ansible_date_time.date }}-{{ ansible_date_time.time }}"
        log_file: "{{ backup_dir }}/backup_log.txt"

    - name: Create backup directory
      ansible.builtin.file:
        path: "{{ backup_dir }}"
        state: directory
        mode: '0755'

    - name: Log backup start
      ansible.builtin.lineinfile:
        path: "{{ log_file }}"
        create: true
        line: |
          Backup started at {{ ansible_date_time.iso8601 }}
          Source directory: {{ playbook_dir }}
          -------------------------------------------

    - name: Move backup files
      block:
        - name: Find and move backup files
          ansible.builtin.find:
            paths: "{{ playbook_dir }}"
            patterns: "*.bak"
            recurse: yes
          register: backup_files

        - name: Move backup files to backup directory
          ansible.builtin.command:
            cmd: "mv {{ item.path }} {{ backup_dir }}/{{ item.path | basename }}"
          loop: "{{ backup_files.files }}"
          loop_control:
            label: "{{ item.path }}"
          when: backup_files.matched > 0

    - name: Move retry files
      block:
        - name: Find and move retry files
          ansible.builtin.find:
            paths: "{{ playbook_dir }}"
            patterns: "*.retry"
            recurse: yes
          register: retry_files

        - name: Move retry files to backup directory
          ansible.builtin.command:
            cmd: "mv {{ item.path }} {{ backup_dir }}/{{ item.path | basename }}"
          loop: "{{ retry_files.files }}"
          loop_control:
            label: "{{ item.path }}"
          when: retry_files.matched > 0

    - name: Move temporary files
      block:
        - name: Find and move temporary files
          ansible.builtin.find:
            paths: "{{ playbook_dir }}"
            patterns: "*.tmp"
            recurse: yes
          register: tmp_files

        - name: Move temporary files to backup directory
          ansible.builtin.command:
            cmd: "mv {{ item.path }} {{ backup_dir }}/{{ item.path | basename }}"
          loop: "{{ tmp_files.files }}"
          loop_control:
            label: "{{ item.path }}"
          when: tmp_files.matched > 0

    - name: Move specific templates
      block:
        - name: Move ansible.cfg.old.j2 if it exists
          ansible.builtin.command:
            cmd: "mv templates/ansible.cfg.old.j2 {{ backup_dir }}/ansible.cfg.old.j2"
          args:
            warn: false
          when: ansible.builtin.stat(path="templates/ansible.cfg.old.j2").stat.exists

        - name: Move ansible.cfg.bak.j2 if it exists
          ansible.builtin.command:
            cmd: "mv templates/ansible.cfg.bak.j2 {{ backup_dir }}/ansible.cfg.bak.j2"
          args:
            warn: false
          when: ansible.builtin.stat(path="templates/ansible.cfg.bak.j2").stat.exists

        - name: Move protected_images.old.j2 if it exists
          ansible.builtin.command:
            cmd: "mv templates/protected_images.old.j2 {{ backup_dir }}/protected_images.old.j2"
          args:
            warn: false
          when: ansible.builtin.stat(path="templates/protected_images.old.j2").stat.exists

    - name: Clean environments directory
      block:
        - name: Find and move environment backup files
          ansible.builtin.find:
            paths: "environments"
            patterns: "*.bak"
            recurse: yes
          register: env_backup_files

        - name: Move environment backup files to backup directory
          ansible.builtin.command:
            cmd: "mv {{ item.path }} {{ backup_dir }}/environments/{{ item.path | basename }}"
          loop: "{{ env_backup_files.files }}"
          loop_control:
            label: "{{ item.path }}"
          when: env_backup_files.matched > 0

        - name: Find and move old YAML files
          ansible.builtin.find:
            paths: "environments"
            patterns: "*.yml.old"
            recurse: yes
          register: old_yaml_files

        - name: Move old YAML files to backup directory
          ansible.builtin.command:
            cmd: "mv {{ item.path }} {{ backup_dir }}/environments/{{ item.path | basename }}"
          loop: "{{ old_yaml_files.files }}"
          loop_control:
            label: "{{ item.path }}"
          when: old_yaml_files.matched > 0

    - name: Log backup completion
      ansible.builtin.lineinfile:
        path: "{{ log_file }}"
        line: |
          -------------------------------------------
          Backup completed at {{ ansible_date_time.iso8601 }}
          Total files/directories moved: {{ backup_files.matched + retry_files.matched + tmp_files.matched + env_backup_files.matched + old_yaml_files.matched }}

- name: Persist all variables to ~/.ansible/vars/config
  hosts: localhost
  tasks:
    - name: Write variables to ~/.ansible/vars/config
      ansible.builtin.copy:
        dest: "{{ ansible_env.HOME }}/.ansible/vars/config"
        content: |
          ---
          container_registries:
            - registry.redhat.io
            - registry.access.redhat.com
            - registry.connect.redhat.com

          required_images:
            - registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel8
            - registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel9
            - registry.redhat.io/ansible-automation-platform-25/de-supported-rhel8
            - registry.redhat.io/ansible-automation-platform-25/de-supported-rhel9
            - registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel8
            - registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel9
            - registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel8
            - registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel9

          dns_servers:
            - '8.8.8.8'
            - '8.8.4.4'

          required_packages:
            - python3-pip
            - ansible-builder
            - ansible-core
            - git
            - podman
            - podman-docker
            - tmux
            - xdg-utils
            - yum-utils

          update_protected_list: true

          rh_username: "{{ rh_username | default('') }}"
          rh_password: "{{ rh_password | default('') }}"
          automation_hub_token: "{{ automation_hub_token | default('') }}"
          galaxy_token: "{{ automation_hub_token | default('') }}"
        mode: '0600'
      no_log: true  # Prevent sensitive data from being logged

- name: Load stored credentials
  hosts: localhost
  tasks:
    - name: Check if the config file exists
      ansible.builtin.stat:
        path: "{{ ansible_env.HOME }}/.ansible/vars/config"
      register: config_file

    - name: Load credentials from config file
      ansible.builtin.include_vars:
        file: "{{ ansible_env.HOME }}/.ansible/vars/config"
      when: config_file.stat.exists

    - name: Prompt for missing credentials
      block:
        - name: Prompt for Red Hat username
          ansible.builtin.pause:
            prompt: "Enter your Red Hat CDN username"
            echo: true
          register: rh_username_input
          when: rh_username is not defined

        - name: Prompt for Red Hat password
          ansible.builtin.pause:
            prompt: "Enter your Red Hat CDN password"
            echo: false
          register: rh_password_input
          when: rh_password is not defined
          no_log: true

        - name: Set collected credentials
          ansible.builtin.set_fact:
            rh_username: "{{ rh_username_input.user_input | default(rh_username) }}"
            rh_password: "{{ rh_password_input.user_input | default(rh_password) }}"
          no_log: true

    - name: Save credentials to config file
      ansible.builtin.copy:
        dest: "{{ ansible_env.HOME }}/.ansible/vars/config"
        content: |
          ---
          rh_username: "{{ rh_username }}"
          rh_password: "{{ rh_password }}"
        mode: '0600'
      when: rh_username is defined and rh_password is defined
      no_log: true

- name: Process each selected environment
  hosts: localhost
  connection: local
  gather_facts: false
  tasks:
    - name: Create base working directory
      ansible.builtin.file:
        path: "/tmp/ee-builder/context/environments"
        state: directory
        mode: '0755'

    - name: Create tasks/ folder for dynamic task files
      ansible.builtin.file:
        path: "{{ playbook_dir }}/tasks"
        state: directory
        mode: '0755'

    - name: Create process_environment.yml dynamically
      ansible.builtin.copy:
        dest: "{{ playbook_dir }}/tasks/process_environment.yml"
        content: |
          # Your task file content
        mode: '0644'

    - name: Process each selected environment
      ansible.builtin.include_tasks: "{{ playbook_dir }}/tasks/process_environment.yml"
      loop: "{{ selected_environments }}"
      loop_control:
        label: "{{ item | basename }}"

- name: Process each selected environment
  hosts: localhost
  connection: local
  gather_facts: false
  tasks:
    - name: Create tasks/ folder for dynamic task files
      ansible.builtin.file:
        path: "{{ playbook_dir }}/tasks"
        state: directory
        mode: '0755'

    - name: Create process_environment.yml dynamically
      ansible.builtin.copy:
        dest: "{{ playbook_dir }}/tasks/process_environment.yml"
        content: |
          - name: Set work_dir for the current environment
            ansible.builtin.set_fact:
              work_dir: "/tmp/ee-builder/context/environments/{{ item | basename }}"

          - name: Debug work_dir
            ansible.builtin.debug:
              msg: "Work directory: {{ work_dir }}"

          - name: Create work_dir for the current environment
            ansible.builtin.file:
              path: "{{ work_dir }}"
              state: directory
              mode: '0755'

          - name: Copy selected environment to work_dir
            ansible.builtin.copy:
              src: "{{ item }}"
              dest: "{{ work_dir }}"
              remote_src: true

          - name: Build container image using ansible-builder
            ansible.builtin.command:
              cmd: >-
                ansible-builder build
                --tag {{ item | basename }}
                --container-runtime podman
                --verbosity 2
                --prune-images
                --context {{ work_dir }}
                -f {{ work_dir }}/execution-environment.yml
              chdir: "{{ work_dir }}"
            register: build_output
            changed_when: "'Downloaded newer image' in build_output.stdout or 'Successfully built' in build_output.stdout"
            environment:
              ANSIBLE_BUILDER_HOME: "{{ work_dir }}"
            ignore_errors: true

          - name: Record build status
            ansible.builtin.set_fact:
              build_results: "{{ build_results | default([]) + [{'image': item | basename, 'success': build_output.rc == 0, 'output': build_output }] }}"
            changed_when: false

          - name: Verify image was built successfully
            ansible.builtin.command:
              cmd: "podman images | grep {{ item | basename }}"
            register: verify_image
            failed_when: verify_image.rc != 0

          - name: Display build result summary
            ansible.builtin.debug:
              msg: |
                Build Summary for {{ item | basename }}:
                - Image Name: {{ item | basename }}
                - Build Status: {{ 'SUCCESS' if verify_image.rc == 0 else 'FAILED' }}"
        mode: '0644'

    - name: Process each selected environment
      ansible.builtin.include_tasks: "{{ playbook_dir }}/tasks/process_environment.yml"
      loop: "{{ selected_environments }}"
      loop_control:
        label: "{{ item | basename }}"

- name: Setup default variables
  hosts: localhost
  connection: local
  gather_facts: false
  tasks:
    - name: Set default work_dir
      ansible.builtin.set_fact:
        work_dir: "/tmp/ee-builder/context"

- name: Summarize build results
  hosts: localhost
  connection: local
  gather_facts: false
  tasks:
    - name: Display build summary
      ansible.builtin.debug:
        msg: |
          =================================================
          EXECUTION ENVIRONMENT BUILD SUMMARY
          =================================================
          
          SUCCESSFUL BUILDS:
          {% for result in build_results | selectattr('success', 'equalto', true) | list %}
          ✅ {{ result.image }}
          {% else %}
          (none)
          {% endfor %}
          
          FAILED BUILDS:
          {% for result in build_results | selectattr('success', 'equalto', false) | list %}
          ❌ {{ result.image }}
          {% else %}
          (none)
          {% endfor %}
          
          =================================================
          
          Total successful: {{ build_results | selectattr('success', 'equalto', true) | list | length }}
          Total failed: {{ build_results | selectattr('success', 'equalto', false) | list | length }}
          
          {% if build_results | selectattr('success', 'equalto', false) | list | length > 0 %}
          For details on failed builds, look at the full playbook output above.
          {% endif %}

    - name: Display detailed failure information
      ansible.builtin.debug:
        msg: |
          FAILURE DETAILS FOR: {{ result.image }}
          
          Exit code: {{ result.output.rc }}
          
          ERROR OUTPUT:
          {{ result.output.stderr_lines | join('\n') }}
          
          -------------------------------------------------
      loop: "{{ build_results | selectattr('success', 'equalto', false) | list }}"
      loop_control:
        loop_var: result
        label: "{{ result.image }}"
      when: build_results | selectattr('success', 'equalto', false) | list | length > 0
