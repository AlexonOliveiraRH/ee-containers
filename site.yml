---
# Ansible Automation Platform - Execution Environment Builder
# This playbook builds customized execution environments based on Red Hat AAP base images.
- name: Setup and store credentials
  hosts: localhost
  connection: local
  gather_facts: true
  environment:
    ANSIBLE_LOCALHOST_WARNING: "False" 
    ANSIBLE_DEPRECATION_WARNINGS: "False"
    ANSIBLE_COMMAND_WARNINGS: "False"
    ANSIBLE_SYSTEM_WARNINGS: "False"

  vars:
    container_registries:
      - registry.redhat.io
      - registry.access.redhat.com
      - registry.connect.redhat.com

    required_images:
      - registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel8
      - registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel9
      - registry.redhat.io/ansible-automation-platform-25/de-supported-rhel8
      - registry.redhat.io/ansible-automation-platform-25/de-supported-rhel9
      - registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel8
      - registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel9
      - registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel8
      - registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel9

    protected_images:
      - "registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel9"
      - "registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel9:latest"
      - "registry.redhat.io/ansible-automation-platform-25/de-supported-rhel9"
      - "registry.redhat.io/ansible-automation-platform-25/de-supported-rhel9:latest"
      - "registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel9"
      - "registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel9:latest"
      - "registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel9"
      - "registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel9:latest"
      - "rhel9-de-minimal"
      - "rhel9-de-minimal-cloudstrike"
      - "rhel9-de-supported"
      - "rhel9-ee-minimal"
      - "rhel9-ee-minimal-cloud"
      - "rhel9-ee-minimal-general"
      - "rhel9-ee-minimal-vmware"
      - "rhel9-ee-minimal-windows"
      - "rhel9-ee-supported"
      - "rhel9-ee-supported-vmware"

    dns_servers:
      - '8.8.8.8'
      - '8.8.4.4'

    required_packages:
      - python3-pip
      - ansible-builder
      - ansible-core
      - git
      - podman
      - podman-docker
      - tmux
      - xdg-utils
      - yum-utils

    update_protected_list: true

  tasks:
    - name: Verify internet connectivity  
      ansible.builtin.uri:
        url: https://google.com
        method: GET
      register: connectivity_check
      failed_when: connectivity_check.status != 200  
      changed_when: false
      tags: [connectivity, validation, init]
      
    # Create static ansible.cfg before any template processing
    - name: Create static ansible.cfg file for initial setup
      ansible.builtin.copy:
        dest: "{{ playbook_dir }}/ansible.cfg"
        mode: '0644'
        force: false  # Don't overwrite if exists
        content: |
          [defaults]
          inventory = localhost,
          ansible_localhost_warning=false
          ansible_deprecation_warnings=false
          force_color = True

          [galaxy]
          server_list = validated, published, galaxy

          [galaxy_server.published]
          url=https://console.redhat.com/api/automation-hub/content/published/
          auth_url=https://sso.redhat.com/auth/realms/redhat-external/protocol/openid-connect/token

          [galaxy_server.validated]
          url=https://console.redhat.com/api/automation-hub/content/validated/
          auth_url=https://sso.redhat.com/auth/realms/redhat-external/protocol/openid-connect/token

          [galaxy_server.galaxy]
          url=https://galaxy.ansible.com/
      tags: [always, setup, init]

    - name: Create collections requirements file
      ansible.builtin.copy:
        dest: "/tmp/requirements.yml"
        mode: '0644'
        content: |
          ---
          collections:
            - name: ansible.utils
            - name: ansible.posix
            - name: community.general
            - name: infra.aap_configuration
            - name: infra.aap_utilities
      tags: [setup, always, collections, init]

    - name: Create requirements.txt file
      ansible.builtin.copy:
        dest: "/tmp/requirements.txt"
        mode: '0644'
        content: |
          ansible-builder>=3.0.0
          ansible-core>=2.15.0,<2.16
          ansible-lint>=24.0.0
      tags: [setup, always, collections, init]

    - name: Create inventory file
      ansible.builtin.copy:
        dest: "/tmp/inventory"
        state: present
        mode: '0644'
        content: |
          [devnode]
          localhost ansible_connection=localhost
      tags: [always, setup, init]
     
    - name: Force install community.general collection system-wide
      ansible.builtin.command:
        cmd: "sudo ansible-galaxy collection install community.general ansible.posix -p /usr/share/ansible/collections --force"
      register: galaxy_install
      changed_when: galaxy_install.rc == 0
      failed_when: galaxy_install.rc != 0
      tags: [setup, init]

    - name: Verify community.general collection installation
      ansible.builtin.command:
        cmd: "ansible-galaxy collection list community.general"
      register: collection_verify
      failed_when: collection_verify.rc != 0
      tags: [setup, validation, init]

    - name: Show installation path
      ansible.builtin.debug:
        msg: "Collection installed at: {{ collection_verify.stdout_lines | select('search', 'Path:') | first | default('Unknown location') }}"
      tags: [setup, init]

    # Improved user detection logic
    - name: Get effective and real user info
      ansible.builtin.shell: |
        echo "EUID=$(id -u)"
        if [ -n "$SUDO_USER" ]; then
          echo "SUDO_USER=$SUDO_USER"
          echo "SUDO_UID=$(id -u $SUDO_USER)"
          echo "SUDO_HOME=$(eval echo ~$SUDO_USER)"
        else
          echo "SUDO_USER="
          echo "SUDO_UID="
          echo "SUDO_HOME="
        fi
        echo "USER=$(whoami)"
        echo "HOME=$HOME"
      register: user_info_output
      changed_when: false
      tags: [always, init]
    
    - name: Parse user info
      ansible.builtin.set_fact:
        parsed_user_info: "{{ dict(user_info_output.stdout_lines | map('regex_replace', '^([^=]+)=(.*)$', '\\1:\\2') | map('split', ':') | list) }}"
      tags: [always, init]
    
    - name: Set user facts
      ansible.builtin.set_fact:
        is_root: "{{ ansible_user_id == '0' }}"
        actual_user: "{{ ansible_user_id }}"
        user_home: "{{ ansible_env.HOME }}"
      tags: [always, init]
    
    - name: Set current_user fact
      ansible.builtin.set_fact:
        current_user: "{{ actual_user }}"
      tags: [always, init]
    
    - name: Debug user detection
      ansible.builtin.debug:
        msg: |
          User detection results:
          - Effective UID: {{ parsed_user_info.EUID }}
          - Running as root: {{ is_root }}
          - Original user: {{ actual_user }}
          - User home: {{ user_home }}
      tags: [always, init]

    # Skip credential setup if running as root directly (not via sudo)
    - name: Skip credential setup if running as root directly
      ansible.builtin.set_fact:
        skip_credential_setup: "{{ ansible_user_id == 'root' and lookup('env', 'SUDO_USER') == '' }}"
      tags: [always, creds]

    - name: Show credential setup status
      ansible.builtin.debug:
        msg: "{{ skip_credential_setup | ternary('Running as direct root user - skipping credential setup', 'Setting up credentials for user ' + actual_user) }}"
      tags: [always, creds]

    - name: Setup user credentials properly
      when: not skip_credential_setup
      block:
        - name: Ensure ansible vars directory exists in user's home
          ansible.builtin.file:
            path: "{{ user_home }}/.ansible/vars"
            state: directory
            mode: '0700'
          tags: [setup, credential_setup, creds]

        - name: Check if credentials file exists
          ansible.builtin.stat:
            path: "{{ user_home }}/.ansible/vars/config"
          register: config_file
          tags: [always, creds]

        - name: Create empty config file if it doesn't exist
          ansible.builtin.copy:
            dest: "{{ user_home }}/.ansible/vars/config"
            content: |
              ---
              # Ansible EE Builder Configuration - Last updated {{ ansible_date_time.iso8601 }}
              rh_username: ''
              rh_password: ''
              automation_hub_token: ''
              galaxy_token: ''
            mode: '0600'
          when: not config_file.stat.exists
          tags: [setup, credential_setup, creds]

        - name: Load stored credentials
          ansible.builtin.include_vars:
            file: "{{ user_home }}/.ansible/vars/config"
            name: stored_credentials
          tags: [always, creds]

        - name: Check if config file has required variables
          ansible.builtin.set_fact:
            has_rh_username: "{{ stored_credentials.rh_username is defined and stored_credentials.rh_username != '' }}"
            has_rh_password: "{{ stored_credentials.rh_password is defined and stored_credentials.rh_password != '' }}"
            has_automation_hub_token: "{{ stored_credentials.automation_hub_token is defined }}"
            has_galaxy_token: "{{ stored_credentials.galaxy_token is defined }}"
          tags: [always, creds]

        - name: Collect Red Hat CDN username if missing
          ansible.builtin.pause:
            prompt: "Enter your Red Hat CDN username"
            echo: true
          register: rh_username_input
          when: not has_rh_username
          tags: [creds]
              
        - name: Collect Red Hat CDN password if missing
          ansible.builtin.pause:
            prompt: "Enter your Red Hat CDN password"
            echo: false
          register: rh_password_input
          when: not has_rh_password
          no_log: true
          tags: [creds]
              
        - name: Collect Automation Hub token if missing
          ansible.builtin.pause:
            prompt: "Enter your Automation Hub token (or press enter to skip)"
            echo: false
          register: automation_hub_token_input
          when: not has_automation_hub_token
          no_log: true
          tags: [creds]
              
        - name: Collect Galaxy token if missing
          ansible.builtin.pause:
            prompt: "Enter your Galaxy token (or press enter to skip)"
            echo: false
          register: galaxy_token_input
          when: not has_galaxy_token
          no_log: true
          tags: [creds]
              
        - name: Update credentials while preserving existing values
          ansible.builtin.set_fact:
            rh_username: "{{ rh_username_input.user_input if rh_username_input is defined else stored_credentials.rh_username | default('') }}"
            rh_password: "{{ rh_password_input.user_input if rh_password_input is defined else stored_credentials.rh_password | default('') }}"
            automation_hub_token: "{{ automation_hub_token_input.user_input if automation_hub_token_input is defined else stored_credentials.automation_hub_token | default('') }}"
            galaxy_token: "{{ galaxy_token_input.user_input if galaxy_token_input is defined else stored_credentials.galaxy_token | default('') }}"
          no_log: true
          tags: [creds]

        - name: Save updated credentials to file (preserving existing values)
          ansible.builtin.copy:
            dest: "{{ user_home }}/.ansible/vars/config"
            content: |
              ---
              # Ansible EE Builder Configuration - Last updated {{ ansible_date_time.iso8601 }}
              rh_username: '{{ rh_username }}'
              rh_password: '{{ rh_password }}'
              automation_hub_token: '{{ automation_hub_token }}'
              galaxy_token: '{{ galaxy_token }}'
            mode: '0600'
          no_log: true
          tags: [creds]

        - name: Show run mode
          ansible.builtin.debug:
            msg: |
              ┌────────────────────────────────────────────────────────────────────┐
              │                     RUN MODE INFORMATION                           │
              ├────────────────────────────────────────────────────────────────────┤
              │ {{ "FIRST RUN DETECTED: Running full setup" if first_run | default(false) else "SUBSEQUENT RUN: Using stored configuration" }} │
              │                                                                    │
              │ User: {{ actual_user | default('Unknown') }}                                            │
              │ Credentials: {{ "New" if first_run | default(false) else "Loaded from file" }}      │
              └────────────────────────────────────────────────────────────────────┘
          tags: [always, creds]

        # Use sudo_user's home directory for config in the main play
        - name: Set config path for main play
          ansible.builtin.set_fact:
            config_path: "{{ user_home }}/.ansible/vars/config"
          tags: [always, creds]

# Play 2: Display title and introduction
- name: Display title screen
  hosts: localhost
  connection: local
  gather_facts: false
  environment:
    ANSIBLE_LOCALHOST_WARNING: "False" 
    ANSIBLE_DEPRECATION_WARNINGS: "False"
    ANSIBLE_COMMAND_WARNINGS: "False"
    ANSIBLE_SYSTEM_WARNINGS: "False"
  tasks:
    - name: Show ascii title
      ansible.builtin.debug:
        msg: |
          ┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
          │                                                                                      ..:-=@@@@=-:..          │
          │                                                                                    .*%@@@@@@@@@@@@%*.        │
          │                                                                                 .:@@@@@@@@@@@@@@@@@@@@:.     │
          │                                                                                .*@@@@@@@@@@*-@@@@@@@@@@*.    │
          │                                                                               .@@@@@@@@@@@*. =@@@@@@@@@@@.   │
          │                                                                              .%@@@@@@@@@@@ .@ +@@@@@@@@@@%.  │
          │                                                                              -%@@@@@@@@@@..@%-.*@@@@@@@@@%-  │
          │     "A Streamlined Approach to Building Ansible Execution Environments"     .+@@@@@@@@@@= =@@@.:@@@@@@@@@@+. │
          │                                                                             .+@@@@@@@@@@ ..:+@%.-@@@@@@@@@+. │
          │                                                                             .=@@@@@@@@@ .@@+. *+.-@@@@@@@%=  │
          │                                                                              .%@@@@@@@:.*@@@@%.  .+@@@@@@%.  │
          │                                                                               .@@@@@@= =@@@@@@@%=.:%@@@@@.   │
          │                                                                                :%@@@@@@@@@@@@@@@@@@@@@@%:    │
          │                                                                                 .*@@@@@@@@@@@@@@@@@@@@*.     │
          │                                                                                   .+@@@@@@@@@@@@@@@@+..      │
          │                                                                                     ..+*%@@@@@@%*+..         │
          └──────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
      tags: [always, init]

    - name: Title screen
      ansible.builtin.pause:
        seconds: 3
      tags: [always, init]

# Play 2: Environment Selection
- name: Environment Selection
  hosts: localhost
  connection: local
  gather_facts: false
  tasks:
    - name: Setup monitoring
      block:
        - name: Kill existing monitoring tmux session (if any)
          ansible.builtin.command: tmux has-session -t podman-monitor
          register: tmux_monitor_check
          changed_when: false
          failed_when: false
          tags: [monitoring, cleanup]

        - name: Create scripts directory if it doesn't exist
          ansible.builtin.file:
            path: "{{ playbook_dir }}/scripts"
            state: directory
            mode: '0755'
          tags: [setup, monitoring]

        - name: Create unified Podman monitoring script
          ansible.builtin.copy:
            dest: "{{ playbook_dir }}/scripts/start_monitor.sh"
            content: |
              #!/bin/bash
              
              # Create basic session with forced dimensions
              tmux new-session -d -s podman-monitor
              
              # Create initial status file with default message
              echo "NOTHING BUILDING YET" > /tmp/current_env
              
              # Configure the top pane with ASCII art header
              tmux select-pane -t podman-monitor:0.0
              tmux send-keys -t podman-monitor:0.0 "clear; cat << 'EOF'
         
                                ●●●●●●●
                               ●●●●●●●●●
                              ●●●●●●●●●●●
                             ●●●●●  ●●●●●●
                  ╔═════════●●●●●════●●●●●●════════════════════════════════════════════════════╗
                  ║        ●●●●●      ●●●●●●                                                   ║
                  ║       ●●●●●        ●●●●●●                                                  ║
                  ║      ●●●●●          ●●●●●●                                                 ║
                  ║     ●●●●●●           ●●●●●●●                                               ║
                  ║    ●●●●●●              ●●●●●●                                              ║
                  ║   ●●●●●●●●●             ●●●●●●                                             ║
                  ║  ●●●●●● ●●●●●●●●         ●●●●●●                                            ║
                  ║ ●●●●●●      ●●●●●●●       ●●●●●● ANSIBLE & PODMAN                          ║
                  ╠●●●●●●══════════●●●●●●●════●●●●●●●══════════════════════════════════════════╣
                  ●●●●●●              ●●●●●●●●●●●●●●● EXECUTION BUILD MONITOR                  ║
                ●●●●●●══════════════════●●●●●●●●●●●●═══════════════════════════════════════════╝
              ●●●●●●●
              EOF
              " C-m
              # Split into bottom panes
              tmux split-window -v -t podman-monitor
              tmux split-window -v -t podman-monitor:0.1
              
              # Set pane sizes
              tmux resize-pane -t podman-monitor:0.0 -y 15
              tmux resize-pane -t podman-monitor:0.1 -y 2
              tmux resize-pane -t podman-monitor:0.2 -y 20
              
              # Configure middle pane for current build status with spinner
              tmux select-pane -t podman-monitor:0.1
              tmux send-keys -t podman-monitor:0.1 "
              while true; do
                BUILDING_FILE=/tmp/current_env
                if [ -f \"\$BUILDING_FILE\" ]; then
                  BUILDING_ENV=\$(cat \"\$BUILDING_FILE\")
                  
                  # Default output with no spinner
                  OUTPUT=\"\$BUILDING_ENV\"
                  
                  # Check if this is an active build (not SKIPPED, COMPLETED, or default message)
                  if [[ \"\$BUILDING_ENV\" != \"SKIPPED\"* && 
                        \"\$BUILDING_ENV\" != \"COMPLETED\"* && 
                        \"\$BUILDING_ENV\" != \"NOTHING BUILDING YET\" && 
                        \"\$BUILDING_ENV\" != \"FAILED\"* ]]; then
                    # Add spinner only for active builds
                    SPINNER_CHARS=(\"|\" \"/\" \"-\" \"\\\\\")
                    SPINNER_INDEX=\$(( (SECONDS / 1) % 4 ))
                    SPINNER=\${SPINNER_CHARS[\$SPINNER_INDEX]}
                    
                    # Format with 'Building:' prefix and spinner suffix
                    OUTPUT=\"Building: \$BUILDING_ENV \${SPINNER}\"
                  elif [[ \"\$BUILDING_ENV\" == \"FAILED\"* ]]; then
                    # Red for failed builds
                    OUTPUT=\"\033[1;31m\$BUILDING_ENV\033[0m\"
                  elif [[ \"\$BUILDING_ENV\" == \"COMPLETED\"* ]]; then
                    # Green for completed builds
                    OUTPUT=\"\033[1;32m\$BUILDING_ENV\033[0m\"
                  fi
                  
                  # Clear line and print output
                  clear
                  printf \" %b\" \"\$OUTPUT\"
                else
                  # Fallback if file doesn't exist
                  clear
                  printf \" NOTHING BUILDING YET\"
                fi
                sleep 0.5
              done
              " C-m
              
              # Configure bottom pane for podman images
              tmux select-pane -t podman-monitor:0.2
              tmux send-keys -t podman-monitor:0.2 "watch -n 0.5 'podman images | (echo \"REPOSITORY                                                            TAG            IMAGE ID      CREATED       SIZE\" && echo \"----------------------------------------------------------------------------------------------------------------\" && grep -v \"REPOSITORY\")'" C-m
              
              # Do NOT attach - let the session run detached
              # This way Ansible can continue and the monitor stays running
              echo "Monitor session started. Use 'tmux attach -t podman-monitor' to view."
            mode: '0755'
          tags: [monitoring]

        - name: Launch monitoring script in the background
          ansible.builtin.shell: >
            {{ playbook_dir }}/scripts/start_monitor.sh
          register: term_launch
          changed_when: true
          ignore_errors: true
          tags: [monitoring]

        - name: Show monitoring script location and instructions
          ansible.builtin.debug:
            msg: |
              ======================================================
              MONITORING SETUP
              
              Monitor script: {{ playbook_dir }}/scripts/start_monitor.sh
              
              To view the build monitor, open a new terminal and run:
                tmux attach -t podman-monitor
              ======================================================
          tags: [monitoring]

        # Try to automatically open a terminal window
        - name: Try to open terminal with tmux session
          ansible.builtin.shell: |
            # Try to detect the environment
            is_wsl=0
            is_gui=0
            
            # Check for WSL
            if grep -qi microsoft /proc/version 2>/dev/null; then
              is_wsl=1
            fi
            
            # Check for GUI
            if [ -n "$DISPLAY" ]; then
              is_gui=1
            fi
            
            # For WSL, try Windows Terminal
            if [ $is_wsl -eq 1 ]; then
              powershell.exe -Command "Start-Process wt -ArgumentList 'wsl.exe', '-e', 'tmux', 'attach', '-t', 'podman-monitor'" >/dev/null 2>&1
              echo "Attempted to open Windows Terminal"
              exit 0
            fi
            
            # For GUI Linux, try various terminals
            if command -v $term >/dev/null 2>&1; then
              for term in gnome-terminal konsole xfce4-terminal terminator xterm; do
                if command -v $term >/dev/null 2>&1; then
                  case $term in
                    gnome-terminal)
                      $term -- tmux attach -t podman-monitor &
                      ;;
                    *)
                      $term -e "tmux attach -t podman-monitor" &
                      ;;
                  esac
                  echo "Opened terminal: $term"
                  exit 0
                fi
              done
            fi
            
            echo "No suitable terminal found - use manual command"
            exit 1
          register: term_open
          ignore_errors: true
          changed_when: term_open.stdout is search("Opened terminal")
          tags: [monitoring]
      tags: [monitoring, setup]

    - name: Clean up dangling images before starting builds
      ansible.builtin.shell: |
        podman image prune -f
      register: pre_prune
      changed_when: pre_prune.stdout is search("deleted")
      ignore_errors: true
      tags: [cleanup, build, pre_build]

    - name: Prompt for distribution selection
      ansible.builtin.pause:
        prompt: |
          Please select the distribution:
          Enter '8' for RHEL 8, '9' for RHEL 9, or 'all' for both
      register: user_input
      tags: [selection]

    - name: Set distribution_selection based on user input
      ansible.builtin.set_fact:
        distribution_selection: "{{ user_input.user_input }}"
      when: user_input.user_input is defined
      tags: [selection]

    - name: Set default values for build_rhel8 and build_rhel9
      ansible.builtin.set_fact:
        build_rhel8: false
        build_rhel9: false
      when: build_rhel8 is not defined or build_rhel9 is not defined
      tags: [selection]

    - name: Filter available environments based on distribution selection
      block:
        - name: Get all available environments
          ansible.builtin.find:
            paths: "environments"
            file_type: directory
          register: all_environments
          tags: [selection]

        - name: Process environments for filtering
          ansible.builtin.set_fact:
            rhel8_environments: "{{ all_environments.files | selectattr('path', 'search', 'rhel8') | rejectattr('path', 'search', '\\.bak$') | map(attribute='path') | list }}"
            rhel9_environments: "{{ all_environments.files | selectattr('path', 'search', 'rhel9') | rejectattr('path', 'search', '\\.bak$') | map(attribute='path') | list }}"
            neutral_environments: "{{ all_environments.files | rejectattr('path', 'search', 'rhel[89]') | rejectattr('path', 'search', '\\.bak$') | map(attribute='path') | list }}"
          tags: [selection]

        - name: Set available environments based on distribution selection
          ansible.builtin.set_fact:
            available_environments: >-
              {{
                (distribution_selection == '8') | ternary(rhel8_environments, []) +
                (distribution_selection == '9') | ternary(rhel9_environments, []) +
                (distribution_selection == 'all') | ternary(rhel8_environments + rhel9_environments, []) +
                neutral_environments
              }}
          tags: [selection]

    - name: Display environment selection menu header
      ansible.builtin.debug:
        msg: |
          **************************************************
          ENVIRONMENT SELECTION MENU

          Selected distribution: RHEL {{ distribution_selection }}

          Available environments:
          {% for env in available_environments %}
          {{ loop.index }}. {{ env | basename }}
          {% endfor %}
          **************************************************
      tags: [selection]

    - name: Prompt for environment selection
      ansible.builtin.pause:
        prompt: |
          **************************************************
          ENVIRONMENT SELECTION MENU

          Selected distribution: RHEL {{ distribution_selection }}

          Available environments:
          {% for env in available_environments %}
          {{ loop.index }}. {{ env | basename }}
          {% endfor %}
          **************************************************

          Enter numbers for environments to build (comma-separated, max {{ available_environments | length }}):
          Enter 'all' to select all environments
          Enter 'q' to quit without selecting:
      register: user_input
      tags: [selection]

    - name: Parse user input for environment selection
      ansible.builtin.set_fact:
        selected_environments: "{{ (user_input.user_input == 'all') | ternary(available_environments, []) }}"
      when: user_input.user_input == 'all'
      tags: [selection]

    - name: Parse numeric selection input 
      block:
        - name: Convert input to list of numbers
          ansible.builtin.set_fact:
            selected_numbers: "{{ user_input.user_input.split(',') | map('trim') | map('int') | list }}"
          when: user_input.user_input != 'all' and user_input.user_input != ''
          tags: [selection]

        - name: Map numbers to environments
          ansible.builtin.set_fact:
            selected_environments: "{{ selected_environments | default([]) + [available_environments[item|int - 1]] }}"
          loop: "{{ selected_numbers }}"
          when: selected_numbers is defined
          tags: [selection]
      when: user_input.user_input != 'all' and user_input.user_input != ''
      tags: [selection]

    - name: Debug parsed selection
      ansible.builtin.debug:
        msg: "Selected environment numbers: {{ selected_numbers | default([]) }}"
      when: selected_numbers is defined
      tags: [selection]

    - name: Set basename for the selected environment
      ansible.builtin.set_fact:
        basename: "{{ selected_environments | first | basename }}"
      when: selected_environments is defined and selected_environments | length > 0
      tags: [selection]
      
    - name: Debug selected basename
      ansible.builtin.debug:
        msg: "Selected environment basename: {{ basename | default('None') }}"
      when: basename is defined
      tags: [selection]

    - name: Debug selected environments
      ansible.builtin.debug:
        var: selected_environments
      tags: [selection]

    - name: Debug work_dir
      ansible.builtin.debug:
        msg: "Work directory: Not yet defined (will be set during processing)"
      when: work_dir is not defined
      tags: [selection]

    - name: Debug selected basename
      ansible.builtin.debug:
        msg: "Selected basename: {{ item | basename }}"
      loop: "{{ selected_environments }}"
      when: selected_environments is defined and selected_environments | length > 0
      tags: [selection]

    - name: Debug environment selection
      ansible.builtin.debug:
        msg: |
          Selected environments: {{ selected_environments | length }} items
          {% for env in selected_environments %}
          - {{ env | basename }} ({{ env }})
          {% else %}
          NO ENVIRONMENTS SELECTED!
          {% endfor %}
        verbosity: 0  # Always show this
      tags: [selection]

    - name: Check if image already exists for each selected environment
      ansible.builtin.command:
        cmd: "podman image exists {{ item | basename }}"
      loop: "{{ selected_environments }}"
      register: existing_images
      changed_when: false
      failed_when: false
      when: force_rebuild is not defined or not force_rebuild
      tags: [images, validation]

    - name: Filter missing environments
      ansible.builtin.set_fact:
        missing_environment_images: >-
          {{ selected_environments | 
             difference(
               existing_images.results | 
               selectattr('rc', 'eq', 0) | 
               map(attribute='item') | 
               list
             )
          }}
      when: force_rebuild is not defined or not force_rebuild
      tags: [images]

    - name: Create scripts directory
      ansible.builtin.file:
        path: "{{ playbook_dir }}/scripts"
        state: directory
        mode: '0755'
      tags: [setup, monitoring]

    - name: Clean up dangling images
      ansible.builtin.command:
        cmd: podman images | awk '$1=="<none>" {print $3}' | xargs podman rmi --force
      register: prune_output
      changed_when: "'Total reclaimed space:' in prune_output.stdout and not 'Total reclaimed space: 0B' in prune_output.stdout"
      ignore_errors: true
      failed_when: false
      tags: [cleanup]

    - name: Copy environment directories to required locations
      ansible.builtin.copy:
        src: "{{ playbook_dir }}/environments"
        dest: "{{ item }}"
        remote_src: true
        mode: '0755'
      loop:
        - "/tmp/ee-builder/context"
        - "/tmp/ee-containers/_build"
      tags: [setup, build]

    - name: Copy ansible.cfg to each build context
      ansible.builtin.template:
        src: templates/ansible.cfg.j2
        dest: "/tmp/ee-builder/context/environments/{{ item | basename }}/ansible.cfg"
      loop: "{{ selected_environments | default([]) }}"
      when: selected_environments is defined and selected_environments | length > 0
      tags: [setup, build]

    - name: Create process_environment.yml dynamically in tasks/ folder
      ansible.builtin.file:
        path: "{{ playbook_dir }}/tasks"
        state: directory
        mode: '0755'
      tags: [setup, build]

    - name: Create process_environment.yml for build
      ansible.builtin.copy:
        dest: "{{ playbook_dir }}/tasks/process_environment.yml"
        content: |
          - name: Clean dangling images before building
            ansible.builtin.shell: podman image prune -f
            register: pre_prune
            changed_when: pre_prune.stdout is search("deleted")
            ignore_errors: true
          
          - name: Update /tmp/current_env for monitoring showing build start
            ansible.builtin.copy:
              content: "STARTING: {% raw %}{{ item | basename }}{% endraw %}"
              dest: /tmp/current_env
            changed_when: false
          
          - name: Set work_dir for the current environment
            ansible.builtin.set_fact:
              work_dir: "/tmp/ee-builder/context/environments/{% raw %}{{ item | basename }}{% endraw %}"

          # Wrap the build process in a block with rescue
          - name: "Build environment {% raw %}{{ item | basename }}{% endraw %}"
            block:
              - name: Debug work_dir
                ansible.builtin.debug:
                  msg: "Work directory: {% raw %}{{ work_dir }}{% endraw %}"
              
              - name: Build container image using ansible-builder
                ansible.builtin.shell: |
                  cd {% raw %}{{ work_dir }}{% endraw %} && \
                  ansible-builder build \
                    --tag {% raw %}{{ item | basename }}{% endraw %} \
                    --container-runtime podman \
                    --verbosity 2 \
                    --prune-images \
                    --context . \
                    -f execution-environment.yml
                register: build_output
                environment:
                  ANSIBLE_BUILDER_HOME: "{% raw %}{{ work_dir }}{% endraw %}"
                ignore_errors: true
                
              - name: Record build status
                ansible.builtin.set_fact:
                  build_results: "{% raw %}{{ build_results | default([]) + [{'image': item | basename, 'success': build_output.rc == 0, 'output': build_output }] }}{% endraw %}"
                  cacheable: true
                
            rescue:
              - name: Record failed build
                ansible.builtin.set_fact:
                  build_results: "{% raw %}{{ build_results | default([]) + [{'image': item | basename, 'success': false, 'output': {'rc': 999} }] }}{% endraw %}"
                  cacheable: true
                  
            always:
              - name: Update /tmp/current_env showing build completed
                ansible.builtin.copy:
                  content: "COMPLETED: {% raw %}{{ item | basename }}{% endraw %}"
                  dest: /tmp/current_env
                changed_when: false
        mode: '0644'
      tags: [setup, build]

    - name: Show "NOTHING BUILDING YET"
      ansible.builtin.debug:
        msg: "NOTHING BUILDING YET"
      tags: [build]

    - name: Process each selected environment
      ansible.builtin.include_tasks: "{{ playbook_dir }}/tasks/process_environment.yml"
      loop: "{{ missing_environment_images }}"
      loop_control:
        label: "{{ item | basename }}"
      tags: [build]

    - name: Show "BUILD COMPLETE"
      ansible.builtin.debug:
        msg: "BUILD COMPLETE"
      tags: [build, post_build]

    - name: Force build_results to be visible in summary
      ansible.builtin.set_fact:
        build_results: "{{ build_results | default([]) }}"
        cacheable: true
      tags: [post_build]

# Play 3: Summary and Status Report
- name: Summary and Status Report
  hosts: localhost
  connection: local
  gather_facts: false
  tasks:
    - name: Generate build summary report
      ansible.builtin.debug:
        msg: |
          ┌──────────────────────────────────────────────────────────────────────────┐
          │                       EXECUTION ENVIRONMENT BUILD REPORT                 │
          ├──────────────────────────────────────────────────────────────────────────┤
          │ STATUS │ ENVIRONMENT                                                     │
          ├──────────────────────────────────────────────────────────────────────────┤
          {% for result in build_results | default([]) %}
          │ {{ '✅ PASS' if result.success else '❌ FAIL' }} │ {{ '%-65s' | format(result.image) }} │
          {% else %}
          │                       No environments were built                         │
          {% endfor %}
          └──────────────────────────────────────────────────────────────────────────┘
          
          {% set successful = build_results | default([]) | selectattr('success') | list %}
          {% set failed = build_results | default([]) | rejectattr('success') | list %}
          
          Summary:
          - Total environments processed: {{ build_results | default([]) | length }}
          - Successfully built: {{ successful | length }}
          - Failed builds: {{ failed | length }}
          
          {% if failed %}
          Failed environments:
          {% for result in failed %}
          - {{ result.image }} (exit code: {{ result.output.rc }})
          {% endfor %}
          {% endif %}
      when: build_results is defined
      tags: [report]

    - name: Show no build results message
      ansible.builtin.debug:
        msg: "No build results available. Did you select any environments to build?"
      when: build_results is not defined or build_results | length == 0
      tags: [report]

# Play 4: Final cleanup
- name: Final cleanup
  hosts: localhost
  connection: local
  gather_facts: false
  tasks:
    - name: Force remove images with <none> tag
      ansible.builtin.shell: |
        # Find any images with "<none>" tag and remove them forcefully
        podman images | awk '$1=="<none>" {print $3}' | xargs -r podman rmi --force
      register: cleanup_output
      changed_when: cleanup_output.stdout != ""
      ignore_errors: true
      tags: [cleanup, post_build]

    - name: Kill existing monitoring tmux session (if any)
      ansible.builtin.command: tmux has-session -t podman-monitor
      register: tmux_monitor_check
      changed_when: false
      failed_when: false
      tags: [cleanup, post_build]

    - name: Close existing monitoring tmux session
      ansible.builtin.shell: tmux kill-session -t podman-monitor
      when: tmux_monitor_check.rc == 0
      changed_when: true
      tags: [cleanup, post_build]
    
    - name: Show cleanup results
      ansible.builtin.debug:
        msg: "Cleanup completed: {{ 'No dangling images found' if cleanup_output.stdout == '' else cleanup_output.stdout }}"
      tags: [cleanup, post_build]

    - name: Final image pruning
      ansible.builtin.shell: podman image prune -f
      register: final_prune
      changed_when: final_prune.stdout is search("deleted")
      ignore_errors: true
      tags: [cleanup, post_build]

